<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildProjectDirectory)\Properties\template-builder.props" 
          Condition="Exists('$(MSBuildProjectDirectory)\Properties\template-builder.props')" />
  <!--
  1. Discover all .vstemplate files
  2. For each .vstemplate file, go up one folder and create a .zip from the content (exluding the _Definitions folder)
  -->
  <PropertyGroup>
    <UseHostCompilerIfAvailable>false</UseHostCompilerIfAvailable>
    <CodeContractsEnableRuntimeChecking>false</CodeContractsEnableRuntimeChecking>
    <!-- 
    Constants 
    -->
    <ls-BuildRoot Condition=" '$(ls-BuildRoot)'=='' ">$(MSBuildProjectDirectory)\Build\</ls-BuildRoot>
    <ls-TasksRoot Condition=" '$(ls-TasksRoot)'==''">$(MSBuildThisFileDirectory)</ls-TasksRoot>
    <!-- This is needed if you need to make changes across templatebuilder/SlowCheetah.Xdt -->
    <ls-SlowCheetahXdtTaskRoot Condition=" '$(ls-SlowCheetahXdtTaskRoot)'=='' ">$(ls-TasksRoot)</ls-SlowCheetahXdtTaskRoot>
    <ls-BuildLib Condition=" '$(ls-BuildLib)'=='' and Exists('$(MSBuildThisFileDirectory)\ligershark.templates.targets')">$(MSBuildThisFileDirectory)\</ls-BuildLib>
    <ls-BuildLib Condition=" '$(ls-BuildLib)'=='' ">$(ls-BuildRoot)Lib\</ls-BuildLib>
    <ls-TemplateReportPath Condition=" '$(ls-TemplateReportPath)'=='' ">$(MSBuildProjectDirectory)\template-report.xml</ls-TemplateReportPath>
    <ls-GenerateTemplateReport Condition=" '$(ls-GenerateTemplateReport)'=='' ">true</ls-GenerateTemplateReport>
    <ls-EnableModifyProjectOnCopyToRemoveTemplateElements Condition=" '$(ls-EnableModifyProjectOnCopyToRemoveTemplateElements)'=='' ">true</ls-EnableModifyProjectOnCopyToRemoveTemplateElements>
    <ls-EnableMultiProjExpandVsTemplateFiles Condition=" '$(ls-EnableMultiProjExpandVsTemplateFiles)'=='' ">true</ls-EnableMultiProjExpandVsTemplateFiles>
      <!--ls-MultiProjExpandVsTemplateFiles=""-->
    <!-- 
      Instead of using $(IntermediateOutputPath) this new property should be used for template related content.
      If we copy the .csproj and source files under $(IntermediateOutputPath)\ then Visual Studio gets confused
      and tries to compile the files under obj\debug\ls-Templates\...\ which have been tokenized.
      Because of this we need to move this folder out of obj\debug\. I'm making it a sibling folder to obj\Debug
      
      Note: turns out it doesn't matter where we stick the output, VS still tries to pick it up. Moving back
      under obj\Debug.
    -->    
    <ls-TemplatesIntermediateOutputPath Condition=" '$(ls-TemplatesIntermediateOutputPath)'=='' ">$(IntermediateOutputPath)</ls-TemplatesIntermediateOutputPath>
    <!-- 
    Item Templates 
    -->    
    <ls-ItemTemplateRoot Condition=" '$(ls-ItemTemplateRoot)'=='' ">$(MSBuildProjectDirectory)\ItemTemplates\</ls-ItemTemplateRoot>
    <ls-ItemTemplateOutputRoot Condition=" '$(ls-ItemTemplateOutputRoot)'=='' ">$(ls-TemplatesIntermediateOutputPath)ls-Templates\</ls-ItemTemplateOutputRoot>
    
    <ls-ItemTemplatesExtendBuild Condition=" '$(ls-ItemTemplatesExtendBuild)'=='' ">true</ls-ItemTemplatesExtendBuild>
    <!-- This is where all the Item Template .zip files will be located -->
    <ls-ItemTemplateZipRootFolder Condition=" '$(ls-ItemTemplateZipRootFolder)'=='' ">Output\ItemTemplates\</ls-ItemTemplateZipRootFolder>
    
    <!--
    Project Templates
    -->
    <ls-ProjectTemplateRoot Condition=" '$(ls-ProjectTemplateRoot)'=='' ">$(MSBuildProjectDirectory)\ProjectTemplates\</ls-ProjectTemplateRoot>
    <ls-ProjectTemplateOutputRoot Condition=" '$(ls-ProjectTemplateOutputRoot)'=='' ">$(ls-TemplatesIntermediateOutputPath)ls-Templates\ProjectTemplate\</ls-ProjectTemplateOutputRoot>
    <!-- This is where all the Project Template .zip files will be located -->
    <ls-ProjectTemplateZipRootFolder Condition=" '$(ls-ProjectTemplateZipRootFolder)'=='' ">Output\ProjectTemplates\</ls-ProjectTemplateZipRootFolder>

    <ls-SnippetFolderRoot Condition=" '$(ls-SnippetFolderRoot)'=='' ">$(MSBuildProjectDirectory)\Snippets\</ls-SnippetFolderRoot>
    
    <!-- This is normally defined by the .props file imported above ( $(MSBuildProjectDirectory)\Properties\template-builder.props )-->
    <ls-TemplateSubFolder Condition=" '$(ls-TemplateSubFolder)'=='' ">Custom Templates</ls-TemplateSubFolder>
    
    <ls-MSBuildLibPathLocal Condition=" '$(ls-MSBuildLibPathLocal)'=='' ">$(LocalAppData)\Microsoft\MSBuild\TemplateBuilder\v1.0.0.0\</ls-MSBuildLibPathLocal>
    <ls-MSBuildLibPath Condition=" '$(ls-MSBuildLibPath)'=='' ">$(MSBuildThisFileDirectory)</ls-MSBuildLibPath>

    <ls-VsTemplateXmlSchema Condition=" '$(ls-VsTemplateXmlSchema)'=='' ">http://schemas.microsoft.com/developer/vstemplate/2005</ls-VsTemplateXmlSchema>
    <ls-UseHardLinksForItemTemplatesCopy Condition=" '$(ls-UseHardLinksForItemTemplatesCopy)'=='' ">false</ls-UseHardLinksForItemTemplatesCopy>

    <ls-enable-remove-proj-extensions Condition=" '$(ls-enable-remove-proj-extensions)'=='' ">true</ls-enable-remove-proj-extensions>

    <RoboCopyExePath Condition=" '$(RoboCopyExePath)'=='' and Exists('$([System.Environment]::SystemDirectory)\robocopy.exe')">$([System.Environment]::SystemDirectory)\robocopy.exe</RoboCopyExePath>
    <RobocopyLoggingOptions Condition=" '$(RobocopyLoggingOptions)'=='' ">/NFL /NDL /NJS /NJH /NP</RobocopyLoggingOptions>
  </PropertyGroup>

  <ItemGroup>
    <ls-BuildAssemblies Include="$(ls-MSBuildLibPath)*.dll"/>
    <!-- 
    For project templates (new ones) files with these item types will be ignored when ouputting
    the files to be copied in the template.
    -->
    <ls-NonFileTypes Include="
                     Reference;
                     ProjectReference;
                     AppConfigFileDestination;
                     IntermediateAssembly;
                     ApplicationManifest;
                     DeployManifest;
                     BuiltProjectOutputGroupKeyOutput;
                     DebugSymbolsProjectOutputGroupOutput;
                     AvailableItemName;
                     Clean;
                     XamlBuildTaskTypeGenerationExtensionName;
                     WebPublishExtnsionsToExcludeItem;
                     COMReference;
                     DocumentationProjectOutputGroupOutput;
                     XapFilesInputCollection;
                     BootstrapperPackage;
                     Import"/>
  </ItemGroup>
  <Target Name="CopyMSBuildFilesToLocalAppData"
          Inputs="@(ls-BuildAssemblies)"
          Outputs="@(ls-BuildAssemblies->'$(ls-MSBuildLibPathLocal)%(FileName)%(Extension)')">
    
    <MakeDir Directories="$(ls-MSBuildLibPathLocal)"/>
    <Copy SourceFiles="@(ls-BuildAssemblies)"
          DestinationFiles="@(ls-BuildAssemblies->'$(ls-MSBuildLibPathLocal)%(FileName)%(Extension)')"
          Condition="!Exists('$(ls-MSBuildLibPathLocal)%(ls-BuildAssemblies.FileName)%(ls-BuildAssemblies.Extension)')"
          />
  </Target>

  <UsingTask AssemblyFile="$(ls-MSBuildLibPathLocal)MSBuild.ExtensionPack.dll" TaskName="MSBuild.ExtensionPack.Compression.Zip" />
  
  <!-- This hooks up the ItemTemplate targets to the Build Process -->
  <PropertyGroup>
    <MarkupCompilePass1DependsOn>
      RemoveTemplateFilesFromCompile;
      $(MarkupCompilePass1DependsOn);
    </MarkupCompilePass1DependsOn>

    <CoreCompileDependsOn Condition=" '$(ls-ItemTemplatesExtendBuild)'=='true' ">
      CopyMSBuildFilesToLocalAppData;
      PrepareTemplatesIntOutput;
      RemoveTemplateFilesFromCompile;
      IncludeSnippetFilesInVsix;
      $(CoreCompileDependsOn);
      ls-ProcessItemTemplates;
      ls-GenerateTemplateReport
    </CoreCompileDependsOn>
  
    <ls-ProcessItemTemplatesDependsOn>
      $(ls-ProcessItemTemplatesDependsOn);
      ls-DiscoverItemTemplateFiles;
      ls-CreateZipForEachItemTemplate;
      ls-AddCreatedItemTemplateZipFilesToProject;
    </ls-ProcessItemTemplatesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareTemplatesIntOutput">
    <Message Text="Template intermediate output folder, ls-TemplatesIntermediateOutputPath: $(ls-TemplatesIntermediateOutputPath)" Importance="low"/>
    <MakeDir Directories="$(ls-TemplatesIntermediateOutputPath)"/>
  </Target>
  <Target Name="RemoveTemplateFilesFromCompile" BeforeTargets="CoreCompile">
    <Message Text="Removing ItemTemplate and ProjectTemplate files from Compile list" Importance="high"/>

    <!-- Files under ItemTemplates and ProjectTemplates should not be included in the Compile list -->
    <ItemGroup>
      <Compile Remove="$(ls-ItemTemplateRoot)**\*"/>
      <Compile Remove="$(ls-ProjectTemplateRoot)**\*"/>

      <Compile Remove="ProjectTemplates\**\*"/>
      <Compile Remove="ItemTemplates\**\*"/>


      <Page Remove="$(ls-ItemTemplateRoot)**\*"/>
      <Page Remove="$(ls-ProjectTemplateRoot)**\*"/>

      <Page Remove="ProjectTemplates\**\*"/>
      <Page Remove="ItemTemplates\**\*"/>
    </ItemGroup>

    <Message Text="ls-ItemTemplateRoot:[$(ls-ItemTemplateRoot)]" Importance="low"/>
    <Message Text="ls-ProjectTemplateRoot:[$(ls-ProjectTemplateRoot)]" Importance="low"/>
  </Target>

  <Target Name="ls-ProcessItemTemplates" DependsOnTargets="$(ls-ProcessItemTemplatesDependsOn)" />
  <PropertyGroup>
    <ls-DiscoverItemTemplateFilesDependsOn>
      $(ls-DiscoverItemTemplateFilesDependsOn);
      ls-CoreDiscoverItemTemplateFiles;
      ls-DiscoverProjectTemplatesFromReferences
    </ls-DiscoverItemTemplateFilesDependsOn>
  </PropertyGroup>
  <Target Name="ls-DiscoverItemTemplateFiles" DependsOnTargets="$(ls-DiscoverItemTemplateFilesDependsOn)" />
  <Target Name="ls-CoreDiscoverItemTemplateFiles">
    <Message Text="Looking for item and project templates" Importance="high"/>
    <!-- Look through Item Templates folder for all .vstemplate files in the project (as Content) -->
    <ItemGroup>
      <!-- Item Templates -->
      <ls-VsTemplateFiles Include="$(ls-ItemTemplateRoot)**\*.vstemplate" 
                          Exclude="$(ls-ItemTemplateRoot)**\MyTemplate.vstemplate;$(ls-ProjectTemplateRoot)**\_project.vstemplate.xml">
        <TemplateType>ItemTemplate</TemplateType>
        <TemplatesRoot>$(ls-ItemTemplateRoot)</TemplatesRoot>
        <ZipRootFolder>$(ls-ItemTemplateZipRootFolder)</ZipRootFolder>
      </ls-VsTemplateFiles>
      
      <!-- Project Templates -->
      <ls-VsTemplateFiles Include="$(ls-ProjectTemplateRoot)**\*.vstemplate" 
                          Exclude="$(ls-ProjectTemplateRoot)**\MyTemplate.vstemplate;$(ls-ProjectTemplateRoot)**\_project.vstemplate.xml">
        <TemplateType>ProjectTemplate</TemplateType>
        <TemplatesRoot>$(ls-ProjectTemplateRoot)</TemplatesRoot>
        <ZipRootFolder>$(ls-ProjectTemplateZipRootFolder)</ZipRootFolder>
      </ls-VsTemplateFiles>
      
      <ls-VsNewProjTemplateFiles Include="$(ls-ProjectTemplateRoot)**\_project.vstemplate.xml">
        <TemplateType>ProjectTemplate</TemplateType>
        <TemplatesRoot>$(ls-ProjectTemplateRoot)</TemplatesRoot>
        <ZipRootFolder>$(ls-ProjectTemplateZipRootFolder)</ZipRootFolder>

        <OutputRoot>ProjectTemplate\</OutputRoot>
      </ls-VsNewProjTemplateFiles>
    </ItemGroup>

    <ItemGroup Condition=" '$(Configuration)'=='Release' " >
      <!-- If we are not building on release mode let's remove any item starting with _Sample -->
      <ls-IT-ToRemove Include="$(ls-ItemTemplateRoot)**\_Sample*\_Definitions\*.vstemplate;$(ls-ItemTemplateRoot)**\_Sample*\_Definitions\_project.vstemplate.xml" />
      <ls-PT-ToRemove Include="$(ls-ProjectTemplateRoot)**\_Sample*\_Definitions\*.vstemplate;$(ls-ProjectTemplateRoot)**\_Sample*\_Definitions\_project.vstemplate.xml" />
      
      <ls-VsTemplateFiles Remove="@(ls-IT-ToRemove);@(ls-PT-ToRemove)" />
      <ls-VsNewProjTemplateFiles Remove="@(ls-IT-ToRemove);@(ls-PT-ToRemove)" />
    </ItemGroup>
    <Message Text="Removed the following Sample templates from the VSIX because build is set to [$(Configuration)]. 
Item Templates: @(ls-IT-ToRemove)
Project Templates: @(ls-PT-ToRemove)"/>
    
    <Message Text="Vs Template Files found: @(ls-VsTemplateFiles,'%0a%0d')" />
  </Target>

  <PropertyGroup>
    <ls-DiscoverProjectTemplatesFromReferencesDependsOn>
      $(ls-DiscoverProjectTemplatesFromReferencesDependsOn);
      ls-MessageForDiscoverProjectTemplatesFromReferences;
      ls-DiscoverProjectTemplatesFromProjectReferences;
      ls-DiscoverProjectTemplatesFromTemplateReferences;
    </ls-DiscoverProjectTemplatesFromReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ls-MessageForDiscoverProjectTemplatesFromReferences">
    <Message Text="Looking for project templates from project references" />
  </Target>
  <Target Name="ls-DiscoverProjectTemplatesFromReferences" DependsOnTargets="$(ls-DiscoverProjectTemplatesFromReferencesDependsOn)"/>

  <Target Name="ls-DiscoverProjectTemplatesFromTemplateReferences"
          Outputs="%(TemplateReference.PathToProject)"
          Condition=" '@(TemplateReference)'!= '' ">
    <Message Text="TemplateReference: [@(TemplateReference)]" Importance="low"/>
    <ItemGroup>
      <_ls-temp-template-ref-path Remove="@(_ls-temp-template-ref-path)"/>
      <_ls-temp-template-ref-path Include="%(TemplateReference.PathToProject)"/>
    </ItemGroup>
    
    <!-- See if there is a _preprocess.xml file in the directory or not -->    
    <PropertyGroup>
      <_ls-ProjDirectory>%(_ls-temp-template-ref-path.RootDir)%(_ls-temp-template-ref-path.Directory)</_ls-ProjDirectory>
      <_ls-ExpectedPreprocessPath>$(_ls-ProjDirectory)_preprocess.xml</_ls-ExpectedPreprocessPath>

      <_ls-ExpectedVsTemplatePath>$(_ls-ProjDirectory)_Definitions\_project.vstemplate.xml</_ls-ExpectedVsTemplatePath>

      <_ls-FoundPreprocessFile>false</_ls-FoundPreprocessFile>
      <_ls-FoundPreprocessFile Condition=" Exists('$(_ls-ExpectedPreprocessPath)')=='true' ">true</_ls-FoundPreprocessFile>

      <_ls-FoundVsTemplateFile>false</_ls-FoundVsTemplateFile>
      <_ls-FoundVsTemplateFile Condition=" Exists('$(_ls-ExpectedVsTemplatePath)')">true</_ls-FoundVsTemplateFile>

      <_ls-FoundRequiredFiles>false</_ls-FoundRequiredFiles>
      <_ls-FoundRequiredFiles Condition= " '$(_ls-FoundPreprocessFile)'=='true' and '$(_ls-FoundVsTemplateFile)'=='true' ">true</_ls-FoundRequiredFiles>

      <_ls-ProjFileName>%(TemplateReference.Identity)</_ls-ProjFileName>
      <_ls-IsSample>false</_ls-IsSample>
      <_ls-IsSample>$(_ls-ProjFileName.StartsWith('_Sample'))</_ls-IsSample>

      <_ls-IncludeTemplate Condition=" '$(_ls-FoundRequiredFiles)'=='true'  ">true</_ls-IncludeTemplate>
      <_ls-IncludeTemplate Condition=" '$(Configuration)'=='Release' and '$(_ls-IsSample)'=='true' ">false</_ls-IncludeTemplate>
    </PropertyGroup>

    <Message Text="
ls-DiscoverProjectTemplatesFromTemplateReferences
  _ls-ProjDirectory: [$(_ls-ProjDirectory)]
  _ls-ExpectedPreprocessPath: [$(_ls-ExpectedPreprocessPath)]
  _ls-ExpectedVsTemplatePath: [$(_ls-ExpectedVsTemplatePath)]
  _ls-FoundPreprocessFile: [$(_ls-FoundPreprocessFile)]
  _ls-FoundVsTemplateFile: [$(_ls-FoundVsTemplateFile)]
  _ls-FoundRequiredFiles: [$(_ls-FoundRequiredFiles)]
  _ls-ProjFileName: [$(_ls-ProjFileName)]
  _ls-IncludeTemplate: [$(_ls-IncludeTemplate)]
"
             Importance="low"/>
    
    <ItemGroup>
      <ls-VsNewProjTemplateFiles
        Include="$(_ls-ExpectedVsTemplatePath)"
        Condition=" '$(_ls-IncludeTemplate)'=='true' ">
        <TemplateType>ProjectTemplate</TemplateType>
        <TemplatesRoot>$(_ls-ProjDirectory)</TemplatesRoot>
        <ZipRootFolder>$(ls-ProjectTemplateZipRootFolder)</ZipRootFolder>

        <OutputRoot>ProjectTemplate\</OutputRoot>
      </ls-VsNewProjTemplateFiles>
    </ItemGroup>    
  </Target>
  <!--
  This target will discover project templates which are coming in through
  as a ProjectReference.
  
  This target will be executed once per value in @(ProjectReference).
  
  NOTE: This is Deprectated, we should use TemplateReference instead of ProjectReference
  -->
  <Target Name="ls-DiscoverProjectTemplatesFromProjectReferences" 
          Outputs="%(ProjectReference.Identity)"
          Condition=" '@(ProjectReference)'!= '' ">

    <!-- See if there is a _preprocess.xml file in the directory or not -->
    <PropertyGroup>
      <_ls-ProjDirectory>%(ProjectReference.RootDir)%(ProjectReference.Directory)</_ls-ProjDirectory>
      <_ls-ExpectedPreprocessPath>$(_ls-ProjDirectory)_preprocess.xml</_ls-ExpectedPreprocessPath>

      <_ls-ExpectedVsTemplatePath>$(_ls-ProjDirectory)_Definitions\_project.vstemplate.xml</_ls-ExpectedVsTemplatePath>
    
      <_ls-FoundPreprocessFile>false</_ls-FoundPreprocessFile>
      <_ls-FoundPreprocessFile Condition=" Exists('$(_ls-ExpectedPreprocessPath)')=='true' ">true</_ls-FoundPreprocessFile>

      <_ls-FoundVsTemplateFile>false</_ls-FoundVsTemplateFile>
      <_ls-FoundVsTemplateFile Condition=" Exists('$(_ls-ExpectedVsTemplatePath)')">true</_ls-FoundVsTemplateFile>

      <_ls-FoundRequiredFiles>false</_ls-FoundRequiredFiles>
      <_ls-FoundRequiredFiles Condition= " '$(_ls-FoundPreprocessFile)'=='true' and '$(_ls-FoundVsTemplateFile)'=='true' ">true</_ls-FoundRequiredFiles>

      <_ls-ProjFileName>%(ProjectReference.FileName)</_ls-ProjFileName>
      <_ls-IsSample>false</_ls-IsSample>
      <_ls-IsSample>$(_ls-ProjFileName.StartsWith('_Sample'))</_ls-IsSample>

      <_ls-IncludeTemplate Condition=" '$(_ls-FoundRequiredFiles)'=='true'  ">true</_ls-IncludeTemplate>
      <_ls-IncludeTemplate Condition=" '$(Configuration)'=='Release' and '$(_ls-IsSample)'=='true' ">false</_ls-IncludeTemplate>
    </PropertyGroup>

    <!-- finally remove the projectreference as well -->
    <Message
      Text="Removing project reference for template project [%(ProjectReference.Identity)]"
      Importance="low"
      Condition=" '$(_ls-FoundRequiredFiles)'=='true' " />
    <ItemGroup>
      <ls-VsNewProjTemplateFiles 
        Include="$(_ls-ExpectedVsTemplatePath)"
        Condition=" '$(_ls-IncludeTemplate)'=='true' ">
        <TemplateType>ProjectTemplate</TemplateType>
        <TemplatesRoot>$(_ls-ProjDirectory)</TemplatesRoot>
        <ZipRootFolder>$(ls-ProjectTemplateZipRootFolder)</ZipRootFolder>

        <OutputRoot>ProjectTemplate\</OutputRoot>
      </ls-VsNewProjTemplateFiles>

      <!-- 
        Removing the refernece has the added benefit of not including the build
        output of these projects into the generated .vsix.
        
        Also we need to do this because if we do not for some reason Visual Studio
        gets confused and tries to load up the copy .csproj file in 
        obj\debug\ls-Templates\...\ instead of the source .csproj file. By removing
        the reference below it solves this issue as well.
      -->
      <ProjectReference Remove="%(ProjectReference.Identity)"
                        Condition=" '$(_ls-FoundRequiredFiles)'=='true' "/>      
    </ItemGroup>
  </Target>
  
  <PropertyGroup>
    <ls-CreateZipForEachItemTemplateDependsOn>
      ls-MessageForCreateZipForEachItemTemplate;
      $(ls-CreateZipForEachItemTemplateDependsOn);
      ls-DiscoverItemTemplateFiles;
      ls-InitalizeItemTemplateOutputFolder;
      ls-CalculateItemGroupOutputsForItemTemplates;
      ls-CopyTemplateFilesToIntermediateFolder;
      ls-PreprocessTemplates;
    </ls-CreateZipForEachItemTemplateDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <ls-CopyTemplateFilesToIntermediateFolderDependsOn>
      $(ls-CopyTemplateFilesToIntermediateFolderDependsOn);
      ls-MessageForCopyTemplateFilesToIntermediateFolder;
      ls-CoreCopyTemplateFilesToIntermediateFolder;
      ls-CopyNewProjectTemplateFilesToIntermediateFolder;
    </ls-CopyTemplateFilesToIntermediateFolderDependsOn>
  </PropertyGroup>
  <Target Name="ls-MessageForCopyTemplateFilesToIntermediateFolder">
    <Message Text="Copying template files to the intermediate folder" Importance="high"/>
  </Target>
  <Target Name="ls-CopyTemplateFilesToIntermediateFolder" DependsOnTargets="$(ls-CopyTemplateFilesToIntermediateFolderDependsOn)"/>
  
  <!-- This target will run once per value in @(ls-ItemTemplatesOutputs) -->
  <Target Name="ls-CoreCopyTemplateFilesToIntermediateFolder"
          Inputs="%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)" 
          Outputs="%(_ls-ItemTemplatesOutputs.Identity);All"
          DependsOnTargets="$(ls-CoreCopyTemplateFilesToIntermediateFolder)">
    
    <Message Text="Determining files to incude in Item Template .zip file for [%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)]"/>

    <!-- 
    Grab all the files from the folder (excluding any .vstemplate file and any files under _Definitions\)
    and create a .zip file from it in the output folder.    
    -->
    <ItemGroup>
      <_ls-ItemsToZip Remove="@(_ls-ItemsToZip)"/>
      <_ls-ItemsToZip Include="%(_ls-ItemTemplatesOutputs.ItemTemplateFolder)**\*" />
    </ItemGroup>
    
    <!-- We need to copy the files into a subfolder under obj\ and then create the .zip file from that -->
    <PropertyGroup>
      <_ls-IntermediateItemTemplateFolder>$(ls-ItemTemplateOutputRoot)%(_ls-ItemTemplatesOutputs.OutputRoot)%(_ls-ItemTemplatesOutputs.ItemTemplateName)\</_ls-IntermediateItemTemplateFolder>
    </PropertyGroup>

    <!-- delete the old content and copy it over from the source -->
    <ItemGroup>
      <_ls-FilesToDelete Remove="@(_ls-FilesToDelete)"/>
      <_ls-FilesToDelete Include="$(_ls-IntermediateItemTemplateFolder)"/>
    </ItemGroup>
    <Delete Files="@(_ls-FilesToDelete)" />   
    <MakeDir Directories="$(_ls-IntermediateItemTemplateFolder)"/>

    <ItemGroup>
      <ls-temp-FilesCopied Remove="@(ls-temp-FilesCopied)" />
    </ItemGroup>
    
    <!-- TODO: This needs to be refactored into its own target -->
    <!-- Copy over the .vstemplate to the root folder and then copy all files -->
    <Copy SourceFiles="%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)"
          DestinationFiles="$(_ls-IntermediateItemTemplateFolder)%(_ls-ItemTemplatesOutputs.Filename).vstemplate">
      <Output TaskParameter ="CopiedFiles" ItemName="ls-temp-FilesCopied"/>
    </Copy>
    
    <Copy SourceFiles="@(_ls-ItemsToZip)"
          DestinationFiles="@(_ls-ItemsToZip->'$(_ls-IntermediateItemTemplateFolder)%(RecursiveDir)%(Filename)%(Extension)')"
          UseHardLinksIfPossible="$(ls-UseHardLinksForItemTemplatesCopy)">
      <Output TaskParameter ="CopiedFiles" ItemName="ls-temp-FilesCopied"/>
    </Copy>

    <ItemGroup>
      <ls-OutputTemplateFiles Include="$(_ls-IntermediateItemTemplateFolder)%(_ls-ItemTemplatesOutputs.Filename).vstemplate"/>
    </ItemGroup>
    
    <Message Text="_ls-ItemTemplatesOutputs.Filename : [%(_ls-ItemTemplatesOutputs.Filename)]" Importance="low"/>
    <Message Text="Zipping the following files for Item Template: @(ls-temp-FilesCopied)" Importance="low"/>
    <Message Text="***: _ls-ItemTemplatesOutputs.OutputPathWithFileName:[%(_ls-ItemTemplatesOutputs.OutputPathWithFileName)]" Importance="low"/>
    <Message Text="***: _ls-IntermediateItemTemplateFolder:[$(_ls-IntermediateItemTemplateFolder)]" Importance="low" />
    <Message Text="***: _ls-ItemTemplatesOutputs.Identity:[%(_ls-ItemTemplatesOutputs.Identity)]" Importance="low" />
    <Message Text="***: _ls-ItemTemplatesOutputs.IntermediateItemTemplateFolder:[%(_ls-ItemTemplatesOutputs.IntermediateItemTemplateFolder)]" Importance="low" />
  </Target>
  <Target Name="ls-MessageForCreateZipForEachItemTemplate">
    <Message Text="Creating a zip file for each template" Importance="high"/>
  </Target>

  <ItemGroup>
    <!-- 
    Defines the list of extensions that will be always be
    copied from the project folder when project templates
    are built via the reference.
    -->
    <ls-projTempFileExtToAlwaysCopy Include="gif;png;jpg;bmp;" />
  </ItemGroup>
  <!--
  This target is called once per value in @(ls-VsNewProjTemplateFiles)
  -->
  <Target Name="ls-CopyNewProjectTemplateFilesToIntermediateFolder" 
          Outputs="%(ls-VsNewProjTemplateFiles.Identity)"
          DependsOnTargets="$(ls-CopyNewProjectTemplateFilesToIntermediateFolderDependsOn)"
          Condition=" '@(ls-VsNewProjTemplateFiles)'!= ''">
    <Error Text="robocopy.exe does not exist at $(RoboCopyExePath)" Condition="!Exists('$(RoboCopyExePath)')" />

    <!-- we need to figure out the name of the project that is contained in the _project.vstemplate.xml file -->
    <PropertyGroup>
      <_ls-vsTemplateProjFileXPath>dft:VSTemplate/dft:TemplateContent/dft:Project[1]/@File</_ls-vsTemplateProjFileXPath>
      <_ls-templateFilePath>%(ls-VsNewProjTemplateFiles.FullPath)</_ls-templateFilePath>
    </PropertyGroup>
    <XmlPeek Namespaces="&lt;Namespace Prefix='dft' Uri='$(ls-VsTemplateXmlSchema)'/&gt;"
             XmlInputPath="$(_ls-templateFilePath)"
             Query="dft:VSTemplate/dft:TemplateContent/dft:Project[1]/@File">
      <Output TaskParameter="Result" PropertyName="_ls-projFile"/>
    </XmlPeek>

    <Message Text="_ls-projFile: $(_ls-projFile)" Importance="low"/>

    <PropertyGroup>
      <_ls-projectPath>%(ls-VsNewProjTemplateFiles.RootDir)%(ls-VsNewProjTemplateFiles.Directory)..\</_ls-projectPath>
      <_ls-pathToFile>$(_ls-projectPath)$(_ls-projFile)</_ls-pathToFile>
      <_ls-fullPathToFile>$([System.IO.Path]::GetFullPath($(_ls-pathToFile)))</_ls-fullPathToFile>
    </PropertyGroup>

    <ItemGroup>
      <_ls-TempFileToAdd Include="$(_ls-fullPathToFile)"/>
    </ItemGroup>

    <GetItemTemplateNameFromVSTemplatePath
      VstemplateFilePath="$(_ls-templateFilePath)"
      ItemTemplateRoot="%(ls-VsNewProjTemplateFiles.TemplatesRoot)"
      ItemTemplateZipRootFolder="%(ls-VsNewProjTemplateFiles.ZipRootFolder)"
      CustomTemplatesFolder="$(ls-TemplateSubFolder)">
      <Output TaskParameter="ItemTemplateName" PropertyName="_ls-TemplateName2" />
      <Output TaskParameter="ItemTemplateFolder" PropertyName="_ls-TemplateFolder2" />
      <Output TaskParameter="OutputPathWithFileName" PropertyName="OutputPathWithFileName2" />
      <Output TaskParameter="OutputPathFolder" PropertyName="OutputPathFolder2"/>
    </GetItemTemplateNameFromVSTemplatePath>

    <PropertyGroup>
      <ls-DestTemplateOutputRoot>$(ls-ItemTemplateOutputRoot)%(ls-VsNewProjTemplateFiles.OutputRoot)$(_ls-TemplateName2)\</ls-DestTemplateOutputRoot>
      <_ls-DestVsTemplatePath>@(ls-VsNewProjTemplateFiles->'$(ls-DestTemplateOutputRoot)_project.vstemplate')</_ls-DestVsTemplatePath>
      <_ls-DestVsTemplateFullPath>$([System.IO.Path]::GetFullPath($(_ls-DestVsTemplatePath)))</_ls-DestVsTemplateFullPath>
      <_ls-IntermediateItemTemplateFolder>$(ls-ItemTemplateOutputRoot)%(ls-VsNewProjTemplateFiles.OutputRoot)$(_ls-TemplateName2)\</_ls-IntermediateItemTemplateFolder>
    </PropertyGroup>
    
    <ItemGroup>
      <_ls-DestVsTemplateItem Include="$(_ls-DestVsTemplateFullPath)"/>
      <ls-ProjectTemplateFilesToRemoveOnCopy Include="_preprocess.xml;_Definitions\_project.vstemplate.xml;Microsoft.ApplicationInsights.AspNetCore;Microsoft.AspNetCore;"/>
      <!-- %2A is the escaped value for the * character. See https://msdn.microsoft.com/en-us/library/bb383819.aspx -->
      <ls-ProjectTemplateFilesToRemoveOnCopyRegex Include="sw-.%2A;"/>
    </ItemGroup>
    <Message Text="
ls-VsNewProjTemplateFiles.Identity: [%(ls-VsNewProjTemplateFiles.Identity)]
_ls-TemplateFolder2: $(_ls-TemplateFolder2)
_ls-TempFileToAdd: [@(_ls-TempFileToAdd)]
OutputPathFolder2: [$(OutputPathFolder2)]
_ls-fullPathToFile: [$(_ls-fullPathToFile)]
_ls-TemplateFolder2:[$(_ls-TemplateFolder2)]
_ls-DestVsTemplatePath: [$(_ls-DestVsTemplatePath)]
_ls-DestVsTemplateFullPath: [$(_ls-DestVsTemplateFullPath)]" Importance="low"/>

    <MakeDir Directories="@(_ls-DestVsTemplateItem->'%(RootDir)%(Directory)')"/>

    <!-- Expand out the .vstemplate to include all files listed in the .csproj -->
    <CreateTemplateTask
      ProjectFile="$(_ls-fullPathToFile)"
      VsTemplateShell="%(ls-VsNewProjTemplateFiles.FullPath)"
      DestinationTemplateLocation="$(_ls-DestVsTemplateFullPath)"
      FilesExclude="@(ls-ProjectTemplateFilesToRemoveOnCopy)"
      FilesExcludeRegex="@(ls-ProjectTemplateFilesToRemoveOnCopyRegex)"
      NonFileTypes="@(ls-NonFileTypes)">
      <Output TaskParameter="FilesToCopy" ItemName="_ls-NewProjFilesToCopyRaw"/>
      <Output TaskParameter="FilesToExclude" ItemName="_ls-FilesToExcludeRaw"/>
    </CreateTemplateTask>

    <!-- TODO: now that we are copying the entire folder I think this step can be removed -->    
    <Copy SourceFiles="@(_ls-NewProjFilesToCopyRaw->'$(_ls-TemplateFolder2)%(Identity)')"
          DestinationFiles="@(_ls-NewProjFilesToCopyRaw->'$(ls-DestTemplateOutputRoot)%(Identity)')">
      <Output TaskParameter ="CopiedFiles" ItemName="ls-temp-FilesCopied"/>
    </Copy>
    <ItemGroup>
      <ls-FoldersToSkip Include="node_modules;bower_components;_Definitions;bin;obj"/>
    </ItemGroup>
    <!-- copy source folder to dest so that the files can be included in the generated vsix -->
    <PropertyGroup>
      <ls-CopyExcludeStatement Condition=" '$(ls-CopyExcludeStatement)'=='' ">*.user *.suo project.lock.json</ls-CopyExcludeStatement>
      <_cpysrcdir>$([System.IO.Path]::GetDirectoryName($(_ls-fullPathToFile)))</_cpysrcdir>
      <_cpysrcdir>$(_cpysrcdir.TrimEnd('\'))</_cpysrcdir>
      
      <_cpydestdir>$([System.IO.Path]::GetFullPath( $(ls-DestTemplateOutputRoot) ))</_cpydestdir>
      <_cpydestdir>$(_cpydestdir.TrimEnd('\'))</_cpydestdir>
      <_cpycomamnd>"$(RoboCopyExePath)" "$(_cpysrcdir)" "$(_cpydestdir)" $(RobocopyLoggingOptions) /E /XD @(ls-FoldersToSkip,' ') /XF $(ls-CopyExcludeStatement)</_cpycomamnd>     
    </PropertyGroup>
    <Message Text="Copying files with robocopy from [$(_cpysrcdir)] to [$(_cpydestdir)], command [$(_cpycomamnd)]" />
    <Exec Command="$(_cpycomamnd)" IgnoreExitCode="true" />  

    <ItemGroup>
      <_ls-DestProjFile Remove="@(_ls-DestProjFile)"/>
      <_ls-DestProjFile Include="$(_ls-fullPathToFile)"/>      
    </ItemGroup>

    <!-- Copy the project file to the dest but remove the TemplateBuilder elements during that copy -->
    <ModifyProject SourceProjectFilePath="$(_ls-fullPathToFile)"
                   ItemsToRemove="@(_ls-FilesToExcludeRaw)"
                   DestProjectFilePath="@(_ls-DestProjFile->'$(ls-DestTemplateOutputRoot)%(Filename)%(Extension)')"
                   Condition=" '$(ls-EnableModifyProjectOnCopyToRemoveTemplateElements)'=='true' "/>
    <Copy SourceFiles="$(_ls-fullPathToFile)"
          DestinationFiles="@(_ls-DestProjFile->'$(ls-DestTemplateOutputRoot)%(Filename)%(Extension)')"
          Condition=" '$(ls-EnableModifyProjectOnCopyToRemoveTemplateElements)'=='false' "/>
    
    <!-- We need to populate _ls-ItemTemplatesOutputs to ensure the rest of the process is invoked -->
    <ItemGroup>
      <_ls-ItemTemplatesOutputs
          Include="@(ls-VsNewProjTemplateFiles->'$(ls-ItemTemplateOutputRoot)$(_ls-TemplateName2).zip')">
        <OutputRoot>%(ls-VsNewProjTemplateFiles.TemplateType)\</OutputRoot>
        <TemplateType>%(ls-VsNewProjTemplateFiles.TemplateType)</TemplateType>
        <ItemTemplateName>$(_ls-TemplateName2)</ItemTemplateName>
        <VsTemplateSourcePath>%(ls-VsNewProjTemplateFiles.Identity)</VsTemplateSourcePath>
        <ItemTemplateFolder>$(_ls-TemplateFolder2)</ItemTemplateFolder>

        <OutputPathWithFileName>$(OutputPathWithFileName2)</OutputPathWithFileName>
        <OutputPathFolder>$(OutputPathFolder2)</OutputPathFolder>
      </_ls-ItemTemplatesOutputs>
    </ItemGroup>
  </Target>
  
  <!-- This target will run once per value in @(ls-ItemTemplatesOutputs) -->
  <Target Name="ls-CreateZipForEachItemTemplate"
          Inputs="%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)" 
          Outputs="%(_ls-ItemTemplatesOutputs.Identity);All"
          DependsOnTargets="$(ls-CreateZipForEachItemTemplateDependsOn)">    
    <PropertyGroup>
      <_ls-IntermediateItemTemplateFolder>$(ls-ItemTemplateOutputRoot)%(_ls-ItemTemplatesOutputs.OutputRoot)%(_ls-ItemTemplatesOutputs.ItemTemplateName)\</_ls-IntermediateItemTemplateFolder>
    </PropertyGroup>

    <Message Text="_ls-IntermediateItemTemplateFolder: $(_ls-IntermediateItemTemplateFolder)" Importance="low"/>
    
    <ItemGroup>
      <_ls-IntFilesToZip Remove="@(_ls-IntFilesToZip)"/>
      <!-- Exclude the _Definitions folder from being zipped -->
      <_ls-IntFilesToZip Include="$(_ls-IntermediateItemTemplateFolder)**\*"
                         Exclude="$(_ls-IntermediateItemTemplateFolder)_Definitions\**\*" />
    </ItemGroup>    
    
    <!-- TODO: Does the .vstemplate file need to go into the .zip file? -->
    <MSBuild.ExtensionPack.Compression.Zip
      TaskAction="Create"
      CompressFiles="@(_ls-IntFilesToZip)"
      ZipFileName="%(_ls-ItemTemplatesOutputs.Identity)"
      RemoveRoot="$(_ls-IntermediateItemTemplateFolder)"
      CompressionLevel="BestCompression" />
    
    <ItemGroup>
      <ls-ItemTempZipIntermediateFiles Include="%(_ls-ItemTemplatesOutputs.Identity)"/>
    </ItemGroup>    
  </Target>

  <Target Name="ls-InitalizeItemTemplateOutputFolder">
    <MakeDir Directories="$(ls-ItemTemplateOutputRoot)"/>
  </Target>

  <PropertyGroup>
    <ls-CalculateItemGroupOutputsForItemTemplates>
      $(ls-CalculateItemGroupOutputsForItemTemplates);
      ls-DiscoverItemTemplateFiles
    </ls-CalculateItemGroupOutputsForItemTemplates>
  </PropertyGroup>
  <!-- This target will run once per value in @(ls-ItemTemplateOutputRoot) -->
  <Target Name="ls-CalculateItemGroupOutputsForItemTemplates" 
          Inputs="%(ls-VsTemplateFiles.Identity)"
          Outputs="%(ls-VsTemplateFiles.Identity);All"
          DependsOnTargets="$(ls-CalculateItemGroupOutputsForItemTemplates)">

    <Message Text="ls-CalculateItemGroupOutputsForItemTemplates. ls-VsTemplateFiles:[ @(ls-VsTemplateFiles)]" />
    <!-- By the time this target is called the item ls-DiscoverItemTemplateFiles should be fully populated. 
    No additions after this point -->

    <PropertyGroup>
      <_TemplatesRoot>%(ls-VsTemplateFiles.TemplatesRoot)</_TemplatesRoot>
      <_ZipRootFolder>%(ls-VsTemplateFiles.ZipRootFolder)</_ZipRootFolder>
    </PropertyGroup>

    <Message Text="_TemplatesRoot:[$(_TemplatesRoot)]" />
    <Message Text="_ZipRootFolder:[$(_ZipRootFolder)]" />
    
    <!-- ls-ItemTemplateOutputRoot -->
    <GetItemTemplateNameFromVSTemplatePath 
      VstemplateFilePath="@(ls-VsTemplateFiles)"
      ItemTemplateRoot="$(_TemplatesRoot)"
      ItemTemplateZipRootFolder="$(_ZipRootFolder)"
      CustomTemplatesFolder="$(ls-TemplateSubFolder)">
      <Output TaskParameter="ItemTemplateName" PropertyName="_ls-ItemTemplateName" />
      <Output TaskParameter="ItemTemplateFolder" PropertyName="_ls-ItemTemplateFolder" />
      <Output TaskParameter="OutputPathWithFileName" PropertyName="OutputPathWithFileName" />
      <Output TaskParameter="OutputPathFolder" PropertyName="OutputPathFolder"/>
    </GetItemTemplateNameFromVSTemplatePath>

    <ItemGroup>
      <_ls-ItemTemplatesOutputs 
        Include="@(ls-VsTemplateFiles->'$(ls-ItemTemplateOutputRoot)%(OutputRoot)$(_ls-ItemTemplateName).zip')">
        <OutputRoot>%(ls-VsTemplateFiles.TemplateType)\</OutputRoot>
        <TemplateType>%(ls-VsTemplateFiles.TemplateType)</TemplateType>
        <ItemTemplateName>$(_ls-ItemTemplateName)</ItemTemplateName>
        <VsTemplateSourcePath>%(ls-VsTemplateFiles.Identity)</VsTemplateSourcePath>
        <ItemTemplateFolder>$(_ls-ItemTemplateFolder)</ItemTemplateFolder>

        <OutputPathWithFileName>$(OutputPathWithFileName)</OutputPathWithFileName>
        <OutputPathFolder>$(OutputPathFolder)</OutputPathFolder>
      </_ls-ItemTemplatesOutputs>
    </ItemGroup>

    <Message Text="
    _ls-ItemTemplatesOutputs.Identity: [%(_ls-ItemTemplatesOutputs.Identity)]
    _ls-ItemTemplatesOutputs.OutputRoot: [%(_ls-ItemTemplatesOutputs.OutputRoot)]
    _ls-ItemTemplatesOutputs.TemplateType: [%(_ls-ItemTemplatesOutputs.TemplateType)]
    _ls-ItemTemplatesOutputs.ItemTemplateName: [%(_ls-ItemTemplatesOutputs.ItemTemplateName)]
    _ls-ItemTemplatesOutputs.VsTemplateSourcePath: [%(_ls-ItemTemplatesOutputs.VsTemplateSourcePath)]
    _ls-ItemTemplatesOutputs.ItemTemplateFolder: [%(_ls-ItemTemplatesOutputs.ItemTemplateFolder)]
    _ls-ItemTemplatesOutputs.OutputPathWithFileName:[%(_ls-ItemTemplatesOutputs.ItemTemplateFolder)]
    _ls-ItemTemplatesOutputs.OutputPathFolder:[%(_ls-ItemTemplatesOutputs.OutputPathFolder)]" Importance="low"/>
  </Target>

  <!--
  For multi-projects we need to expand the mytemplate.vstemplate file so that it will contain
  the full list of files. This target is called after all files are copied to the templates
  temp folder.
  -->
  <Target Name="ls-MultiProjExpandVsTemplateFiles" 
          DependsOnTargets="$(ls-MultiProjExpandVsTemplateFilesDependsOn)"
          Condition=" '$(ls-EnableMultiProjExpandVsTemplateFiles)'=='true' " />
  <PropertyGroup>
    <ls-MultiProjExpandVsTemplateFilesDependsOn>
      ls-CopyTemplateFilesToIntermediateFolder;
      $(ls-MultiProjExpandVsTemplateFilesDependsOn);
      ls-MultiProjDiscoverTemplateFilesToExpand;
      ls-CoreMultiProjExpandVsTemplateFile;
    </ls-MultiProjExpandVsTemplateFilesDependsOn>
  </PropertyGroup>
  <!--
    This target is called once per value in @(ls-MultiProjTemplateFilesToExpand.Identity)
  -->
  <Target Name="ls-CoreMultiProjExpandVsTemplateFile" 
          DependsOnTargets="ls-MultiProjDiscoverTemplateFilesToExpand"
          Outputs="%(ls-MultiProjTemplateFilesToExpand.Identity)"
          Condition=" '$(ls-EnableMultiProjExpandVsTemplateFiles)'=='true' and '@(ls-MultiProjTemplateFilesToExpand)'!='' ">
    <!-- 
    Now we will call the CreateTemplateTask on the mytemplate.vstemplate files. 
    Source and dest will both point to the mystemplate.vstemplate file in the templates temp folder.
    -->
    <CreateTemplateTask
      VsTemplateShell="%(ls-MultiProjTemplateFilesToExpand.FullPath)"
      DestinationTemplateLocation="%(ls-MultiProjTemplateFilesToExpand.FullPath)"
      FilesExclude="@(ls-ProjectTemplateFilesToRemoveOnCopy)"
      FilesExcludeRegex="@(ls-ProjectTemplateFilesToRemoveOnCopyRegex)"
      NonFileTypes="@(ls-NonFileTypes)"
      UpdateProjectElement="false"
      />
  </Target>
  <Target Name="ls-MultiProjDiscoverTemplateFilesToExpand">
    <Message Text="Expanding mytemplate.vstemplate files for multi-project templates" Importance="high"/>
    
    <ItemGroup>
      <ls-MultiProjTemplateFilesToExpand Include="$(ls-ProjectTemplateOutputRoot)**\MyTemplate.vstemplate"/>
    </ItemGroup>

    <Message Text="ls-MultiProjTemplateFilesToExpand: @(ls-MultiProjTemplateFilesToExpand)" 
             Importance="low"/>
  </Target>
  
  <PropertyGroup>
    <ls-AddCreatedItemTemplateZipFilesToProjectDependsOn>
      $(ls-AddCreatedItemTemplateZipFilesToProjectDependsOn);
      ls-CreateZipForEachItemTemplate;
    </ls-AddCreatedItemTemplateZipFilesToProjectDependsOn>
  </PropertyGroup>
  
  <Target Name="ls-AddCreatedItemTemplateZipFilesToProject" DependsOnTargets="$(ls-AddCreatedItemTemplateZipFilesToProjectDependsOn)" >
    <Message Text="Adding the following files to Content: [@(ls-ItemTempZipIntermediateFiles)]" />
    
    <!-- Add the produced .zip files to Content so that they are included in the package -->
    <ItemGroup>
      <VSIXSourceItem Include="%(_ls-ItemTemplatesOutputs.Identity)">
        <VSIXSubPath>%(_ls-ItemTemplatesOutputs.OutputPathFolder)</VSIXSubPath>
      </VSIXSourceItem>
    </ItemGroup>

    <Message Text="VSIXSubPath: [%(ls-ItemTempZipIntermediateFiles.OutputPathFolder)]" />    
  </Target>

  <!--
    Preprocessing elements below
  -->
  <PropertyGroup>
    <ls-PreprocessTemplatesDependsOn>
      $(ls-PreprocessTemplatesDependsOn);
      ls-PreprocessDiscoverTempInfoFiles;
      ls-PreprocessEachTemplateInfoFile;
      ls-MultiProjExpandVsTemplateFiles;
      ls-PreprocessProjectFiles;
    </ls-PreprocessTemplatesDependsOn>
  </PropertyGroup>
  <!-- TODO: this target should be renamed to ls-Preprocess and make ls-PreprocessTemplates a step -->
  <Target Name="ls-PreprocessTemplates" DependsOnTargets="$(ls-PreprocessTemplatesDependsOn)"/>

  <!-- This target will find all the templateinfo.xml files -->
  <Target Name="ls-PreprocessDiscoverTempInfoFiles">
    <Message Text="Looking for templateinfo.xml files under [$(ls-ItemTemplateOutputRoot)]" Importance="low"/>
        <ItemGroup>
          <ls-TemplateInfoFiles Include="$(ls-ItemTemplateOutputRoot)**\_preprocess.xml" />
        </ItemGroup>

        <Message Text="ls-TemplateInfoFiles: @(ls-TemplateInfoFiles)"/>        
  </Target>

  <PropertyGroup>
    <ls-PreprocessEachTemplateInfoFileDependsOn>
      $(ls-PreprocessEachTemplateInfoFileDependsOn);
      ls-PreprocessDiscoverTempInfoFiles;
    </ls-PreprocessEachTemplateInfoFileDependsOn>
  </PropertyGroup>
  <!-- This will run once per file in @(ls-TemplateInfoFiles) -->
  <Target Name="ls-PreprocessEachTemplateInfoFile"
          Outputs="%(ls-TemplateInfoFiles.Identity)"
          DependsOnTargets="$(ls-PreprocessEachTemplateInfoFileDependsOn)">
          
    <Message Text="ls-TemplateInfoFiles.Identity: %(ls-TemplateInfoFiles.Identity)" Importance="low"/>
    <Message Text="ls-TemplateInfoFiles.Directory: %(ls-TemplateInfoFiles.Directory)" Importance="low"/>

    <PropertyGroup>
      <_TemplateInfoPath>%(ls-TemplateInfoFiles.FullPath)</_TemplateInfoPath>
      <_TemplateDir>%(ls-TemplateInfoFiles.RootDir)%(ls-TemplateInfoFiles.Directory)</_TemplateDir>
    </PropertyGroup>
    
    <Message Text="_TemplateInfoPath: [$(_TemplateInfoPath)]" Importance="low"/>
    <Message Text="_TemplateDir: [$(_TemplateDir)]" Importance="low"/>

    <ReplaceInFiles
      RootDirectory="$(_TemplateDir)"
      TemplateInfoFile="$(_TemplateInfoPath)"
      Condition="Exists('$(_TemplateInfoPath)')" />
    
    <Message Text="Skipping ReplaceInFiles because no _preprocess.xml files were found" 
             Condition="!Exists('$(_TemplateInfoPath)')"/>
  </Target>

  <!--
  This target will:
    1. Discover all the .*proj files in the obj\Debug\ls-Templates\ProjectTemplate folder
    2. Remove the ProjectExtensions element from the file
  -->
  <Target Name="ls-PreprocessProjectFiles">
    <ItemGroup>
      <_proj-files-to-preprocess Include="$(ls-ProjectTemplateOutputRoot)**\*.??proj"/>
    </ItemGroup>

    <PropertyGroup>
      <_transform-text>$(ls-XdtRemoveProjectExtension.Replace('[<![CDATA[','').Replace(']]>',''))</_transform-text>
    </PropertyGroup>

    <Message Text="ls-ProjectTemplateOutputRoot: [$(ls-ProjectTemplateOutputRoot)]" Importance="low"/>
    <Message Text="ls-SlowCheetahXdtTaskRoot: [$(ls-SlowCheetahXdtTaskRoot)]"  Importance="low"/>
    <Message Text="Preprocessing the following project files [@(_proj-files-to-preprocess)]" Importance="low"/>
    <TransformXml Source="%(_proj-files-to-preprocess.FullPath)"
                  TransformText="$(_transform-text)" 
                  Destination="%(_proj-files-to-preprocess.FullPath)"
                  Condition=" '%(_proj-files-to-preprocess.FullPath)' != '' and '$(ls-enable-remove-proj-extensions)' == 'true' " />
  </Target>

  <PropertyGroup>
    <ls-XdtRemoveProjectExtension Condition=" '$(ls-XdtRemoveProjectExtension)'=='' ">
      [<![CDATA[
<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns:xdt="http://schemas.microsoft.com/XML-Document-Transform" 
         xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  
  <ProjectExtensions xdt:Transform="Remove" />
  
</Project>      
      ]]>
    </ls-XdtRemoveProjectExtension>
  </PropertyGroup>
  
  <PropertyGroup>
    <CleanDependsOn>
      $(CleanDependsOn);
      CleanTemplateBuilderFiles
    </CleanDependsOn>
    
    <CleanTemplateBuilderFilesDependsOn>
      $(CleanTemplateBuilderFilesDependsOn);      
    </CleanTemplateBuilderFilesDependsOn>
  </PropertyGroup>
  <Target Name="CleanTemplateBuilderFiles" 
          DependsOnTargets="$(CleanTemplateBuilderFilesDependsOn)">
    
    <Message Text="Deleting template-builder files under [$(ls-ItemTemplateOutputRoot)]"/>
    <ItemGroup Condition=" '$(ls-ItemTemplateOutputRoot)'!='' ">
      <_TemplateBuilderFiles Remove="@(_TemplateBuilderFiles)"/>
      <_TemplateBuilderFiles Include="$(ls-ItemTemplateOutputRoot)**\*"/>
    </ItemGroup>
    <Delete Files="@(_TemplateBuilderFiles)" Condition=" '$(ls-ItemTemplateOutputRoot)'!='' "/>
    <RemoveDir Directories="$(ls-ItemTemplateOutputRoot)"/>
    
  </Target>
  <!--************************************************************************************
      Snippet support
  ************************************************************************************-->
  <Target Name="IncludeSnippetFilesInVsix">
    <Message Text="Ensuring .snippet files are marked as content and included in the .vsix"/>
    <!-- 
    We need to remove .snippet files from Content/None/Resource/EmbeddedResource
    Then add the files to Content with the following metadata set:
      <IncludeInVSIX>true</IncludeInVSIX>
    -->

    <FindUnderPath Files="@(Content);@(None);@(Resource);@(EmbeddedResource)" Path="$(ls-SnippetFolderRoot)">
      <Output TaskParameter="InPath" ItemName="_ls-Snippet-Files"/>
    </FindUnderPath>
    
    <ItemGroup>
      <Content Remove="@(_ls-Snippet-Files)"/>
      <None Remove="@(_ls-Snippet-Files)"/>
      <Resource Remove="@(_ls-Snippet-Files)"/>
      <EmbeddedResource Remove="@(_ls-Snippet-Files)"/>
    </ItemGroup>

    <Message Text="Adding the following .snippet files: [@(_ls-Snippet-Files)]" />
    
    <ItemGroup>
      <Content Include="@(_ls-Snippet-Files)">
        <IncludeInVSIX>true</IncludeInVSIX>
      </Content>
    </ItemGroup>    
  </Target>
  <PropertyGroup>
    <ls-GenerateTemplateReportDependsOn>
      $(ls-GenerateTemplateReportDependsOn);
      ls-CalculateItemGroupOutputsForItemTemplates;
      ls-CopyTemplateFilesToIntermediateFolder;
      IncludeSnippetFilesInVsix
    </ls-GenerateTemplateReportDependsOn>
  </PropertyGroup>
  <Target Name="ls-GenerateTemplateReport" 
          DependsOnTargets="$(ls-GenerateTemplateReportDependsOn)"
          Inputs="@(ls-VsTemplateFiles);@(_ls-Snippet-Files);@(ls-VsNewProjTemplateFiles)"
          Outputs="$(ls-TemplateReportPath)"
          Condition=" '$(ls-GenerateTemplateReport)'=='true' ">
    <Message Text="Creating template pack report at: [$(ls-TemplateReportPath)]" />

    <ItemGroup>
      <_ls-SnippetFilesOnly Include="@(_ls-Snippet-Files)"
                            Condition=" '%(_ls-Snippet-Files.Extension)'=='.snippet' " />
    </ItemGroup>
    
    <GenerateTemplatePackReport TemplateFiles="@(ls-VsTemplateFiles);@(ls-VsNewProjTemplateFiles)"
                                SnippetFiles="@(_ls-SnippetFilesOnly)"
                                OutputFile="$(ls-TemplateReportPath)"                                
                                ReportType="Xml"/>
  </Target>

  <!--************************************************************************************
      Items to support including the templatebuilder nupkg in the generated vsix
  ************************************************************************************-->
  
  <!-- 
  IncludeTemplateBuilderNuGetPkgInVsix is false by default. It can be set in the template-builder.props
  file by consumers if they want to include the TemplateBuilder .nupkg in the vsix.
  -->
  <PropertyGroup>
    <IncludeTemplateBuilderNuGetPkgInVsix Condition=" '$(IncludeTemplateBuilderNuGetPkgInVsix)'=='' ">false</IncludeTemplateBuilderNuGetPkgInVsix>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(IncludeTemplateBuilderNuGetPkgInVsix)'=='true' ">
    <TemplateBuilderNuPkgFolder Condition=" '$(TemplateBuilderNuPkg)'=='' ">$([System.IO.Path]::GetFullPath($([System.IO.Path]::GetDirectoryName($(TemplateBuilderTargets)))\..\))</TemplateBuilderNuPkgFolder>
  </PropertyGroup>

  <Target Name="IncludeTemplateBuilderVsix" BeforeTargets="CoreCompile" Condition=" '$(IncludeTemplateBuilderNuGetPkgInVsix)'=='true' ">
    <ItemGroup>
      <_templatebuildernupkg Include="$(TemplateBuilderNuPkgFolder)TemplateBuilder*.nupkg"/>
    </ItemGroup>
    <Message Text="Including templatebuilder nupkg [$(_templatebuildernupkg)] into vsix output." Importance="low" />
    <ItemGroup>
      <VSIXSourceItem Include="%(_templatebuildernupkg.Identity)">
      </VSIXSourceItem>
    </ItemGroup>
  </Target>
  
  <!--
    Note: the following targets should only be called when the build is being driven by a standalone build.proj
    and not a VSIX project or a Visual Studio package project
  -->
  <PropertyGroup>
    <BuildStandAloneDependsOn>
      $(BuildStandAloneDependsOn);
      Build;
      CopyTemplatesToOutputPath;
    </BuildStandAloneDependsOn>
  </PropertyGroup>
  <Target Name="BuildStandAlone" DependsOnTargets="$(BuildStandAloneDependsOn)"/>
  <Target Name="CopyTemplatesToOutputPath" DependsOnTargets="ls-AddCreatedItemTemplateZipFilesToProject">
    <Message Text="VSIXSourceItem|VSIXSubPath: %(VSIXSourceItem.Identity)|%(VSIXSourceItem.VSIXSubPath)" Importance="high" />
    <Message Text="Destfiles: @(VSIXSourceItem->'$(OutputPath)%(VSIXSubPath)\%(Filename)%(Extension)')" Importance="high"/>
    
    <Copy SourceFiles="@(VSIXSourceItem)"
          DestinationFiles="@(VSIXSourceItem->'$(OutputPath)%(VSIXSubPath)\%(Filename)%(Extension)')"
          Condition=" '$(OutputPath)'!='' " />
  </Target>
  
  <!--************************************************************************************
      Tasks defined below
  ************************************************************************************-->
  <UsingTask TaskName="GenerateTemplatePackReport" AssemblyFile="$(ls-TasksRoot)LigerShark.TemplateBuilder.Tasks.dll"/>
  <UsingTask TaskName="GetItemTemplateNameFromVSTemplatePath" AssemblyFile="$(ls-TasksRoot)LigerShark.TemplateBuilder.Tasks.dll"/>  
  <UsingTask TaskName="ReplaceInFiles" AssemblyFile="$(ls-TasksRoot)LigerShark.TemplateBuilder.Tasks.dll"/>
  <UsingTask TaskName="CreateTemplateTask" AssemblyFile="$(ls-TasksRoot)LigerShark.TemplateBuilder.Tasks.dll"/>
  <UsingTask TaskName="ModifyProject" AssemblyFile="$(ls-TasksRoot)LigerShark.TemplateBuilder.Tasks.dll"/>
  <UsingTask TaskName="TransformXml" AssemblyFile="$(ls-SlowCheetahXdtTaskRoot)SlowCheetah.Xdt.dll"/>

  <PropertyGroup Condition=" '$(ls-msbuildtasks-path)'=='' ">
    <ls-msbuildtasks-path>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll</ls-msbuildtasks-path>
    <ls-msbuildtasks-path Condition=" !Exists('$(ls-msbuildtasks-path)')">$(MSBuildFrameworkToolsPath)\Microsoft.Build.Tasks.v4.0.dll</ls-msbuildtasks-path>
    <ls-msbuildtasks-path Condition=" !Exists('$(ls-msbuildtasks-path)')">$(windir)\Microsoft.NET\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll</ls-msbuildtasks-path>
  </PropertyGroup>
</Project>
