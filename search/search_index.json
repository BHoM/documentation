{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#what-is-bhom","title":"What is BHoM?","text":"<p>The BHoM (Buildings and Habitats object Model) is a framework for AEC, a collection of schemas, functions and schema conversions. </p> <p>The BHoM schema -- called BHoM Object Model -- contains definitions for any kind of AEC concept:  from physical concepts (e.g. columns, floors, etc.) to theoretical concepts (structural forces, light, etc.).</p> <p>Further, BHoM offers several functions that can operate on the BHoM objects. For example, you can derive calculations or quantities from given objects, like the total weight of a set of BHoM columns.</p> <p>The objects and functions are software-agnostic, and you can access it from command line, or from specific software, like Grasshopper, Excel, Revit, etc.</p> <p>To export/import from the BHoM format to other software, BHoM offers several adapters that can convert to/from BHoM, so you can export/import from e.g. Autodesk Robot, Revit, Grasshopper, etc.</p> <p>In short, BHoM aims to standardise the data and the functionality that operates on data, in an open-source way.</p>"},{"location":"#bhom-vs-other-aec-frameworks","title":"BHoM VS other AEC frameworks","text":"<p>BHoM focuses on defining concepts without a focus on a particular software or graphical interface. BHoM is transdisciplinary, software-agnostic and office/region/country-invariant.</p> <p></p>"},{"location":"#embracing-open-source","title":"Embracing open-source","text":"<p>The whole BHoM project uses an open-source model for project architecture, co-creation and planning. </p> <p>So explore, experiment and contribute to both the source code and the wiki. </p> <p>Sharing and building our code together in this open-source type approach means we can feed off and pool our disparate knowledge, experience and expertise towards a common goal \u2013 better design.</p>"},{"location":"BHoM_Adapter/","title":"Introduction to the BHoM_Adapter","text":"<p>In this page you will find a first overview about what is the BHoM Adapter.</p> <p>Note</p> <p>\u25b6\ufe0f Part of a series of pages. Next read: The Adapter Actions.</p> <p>Before reading this page, have a look at the following pages:</p> <ul> <li>Structure of the BHoM framework</li> <li>Getting started for developers</li> </ul> <p>and make sure you have a general understanding of:</p> <ul> <li>The oM</li> <li>The Engine</li> </ul>"},{"location":"BHoM_Adapter/#what-is-a-bhom-adapter","title":"What is a BHoM Adapter?","text":"<p>As shown in the Structure of the BHoM framework, an adapter is the part of BHoM responsible to convert and send-receive data (import/export) with external software (e.g. Robot, Revit, etc.).</p> <p>In brief:</p> <ul> <li>An Adapter connects the BHoM to an external software.</li> <li>Every Adapter offers different functionality, which we call Adapter Actions (for example, <code>Push</code>, which means exporting from BHoM, and <code>Pull</code>, which means importing to BHoM).</li> <li>Different Adapters exist, one per each Software (e.g. Robot), or format (e.g. XML), to which BHoM can be converted. </li> </ul>"},{"location":"BHoM_Adapter/#create-an-adapter-component-or-formula","title":"Create an Adapter component or formula","text":"<p>Depending on the UI Software you are using, you can create an Adapter component (in Grasshopper, or formula if you are in Excel) like this:</p> <p>Adapter component</p> GrasshopperExcel <ol> <li>Select the Adapter component: </li> <li>Right click on centre of the component, then select an an Adapter from the menu (or use the text box to search): </li> <li>A component gets created. See the inputs and follow the instructions of your chosen adapter to use it. </li> </ol> <ol> <li>Select an adapter from the menu: </li> <li>A formula gets created in the active cell. See the inputs and follow the instructions of your chosen adapter to use it. </li> </ol>"},{"location":"BHoM_Adapter/#adapter-actions","title":"Adapter actions","text":"<p>The Adapter Actions are the way to communicate with an external software via an Adapter. </p> <p>Adapter Actions are BHoM components that you connect to a specific Adapter (e.g. Robot Adapter). Like any other BHoM component, are always look the same no matter what User Interface program you are using (Grasshopper, Excel, ...). In Grasshopper, there will be a component representing each action; in Excel, a formula will let you use them. You can find the Adapter Actions in the Adapter subcategory:</p> <p>Adapter Actions</p> GrasshopperExcel <ol> <li> <p>Select an Actions from the \"Adapter\" category, e.g. <code>Push</code>: </p> </li> <li> <p>The selected action is instantiated as a component to which an adapter can be connected. You will need to specify also the objects and possibly other inputs; keep reading. </p> </li> </ol> <ol> <li> <p>Select an Actions from the \"Adapter\" category, e.g. <code>Push</code>: </p> </li> <li> <p>The selected action is instantiated as a formula to which an adapter can be connected. You will need to specify also the objects and possibly other inputs; keep reading. </p> </li> </ol>"},{"location":"BHoM_Adapter/#example-usage-use-robot-adapter-to-push-export-a-bhom-model-to-robot","title":"Example usage: use Robot Adapter to <code>Push</code> (export) a BHoM model to Robot","text":"<p>Before looking at the Adapter Actions in more detail, see the following illustrative example of a Push to Robot.  </p> <p>Note</p> <p>Although the Adapter actions always look the same, remember that each adapter may behave differently. Some adapters expect that you will use the Push with specific BHoM objects. For example, you can not push Architectural Rooms objects (<code>BH.oM.Architecture.Room</code>) to a Structural Adapter like RobotAdapter.</p> <p>Illustrative example of Push</p> GrasshopperExcel <p>Example file download: Example push GH.zip</p> <p></p> <p>Example file download: Example push Excel.zip</p> <p></p>"},{"location":"BHoM_Adapter/#adapter-actions-overview","title":"Adapter actions overview","text":"<p>The following is a brief overview, more than enough for any user. A more in-detail explanation, for developers and/or curious users, is left in the next page of this wiki.</p> <p>The first thing to understand is that the Adapter Actions do different things depending on the software they are targeting. In fact, the first input to any Adapter Action is always an <code>Adapter</code>, which targets a specific external software or platform. The first input <code>Adapter</code> is common to all Actions.</p> <p>The last input to any Adapter action is an <code>active</code> Boolean, that can be True or False. If you insert the value True, the Action will be activated and it will do its thing. False, and it will sit comfortably not doing anything.</p>"},{"location":"BHoM_Adapter/#push-and-pull","title":"Push and Pull","text":"<p>The most commonly used actions are the Push and the Pull. You can think of Push and Pull as Export and Import: they are your \"portal\" towards external software. Again, taking Grasshopper UI as an example, they look like this (but they always have the same inputs and outputs, even if you are using Excel):  </p>"},{"location":"BHoM_Adapter/#push","title":"Push","text":"<p>The Push takes the input <code>objects</code> and:     - if they don't exist in the external model yet, they are created brand new;    - if they exist in the external model, they will be updated (edited);    - under some particular circumstances and for specific software, if some objects in the external software are deemed to be \"old\", the Push will delete those. </p> <p>This method functionality varies widely depending on the software we are targeting. For example, it could do a thing as simple as simply writing a text representation of the input objects (like in the case of the File_Adapter) to taking care of object deletion and update (GSA_Adapter).</p> <p>In the most complete case, the Push takes care of many different things when activated: ID assignment, avoiding object duplication, distinguishing which object needs updating versus to be exported brand new, etc.</p>"},{"location":"BHoM_Adapter/#pull","title":"Pull","text":"<p>The Pull simply grabs all the objects in the external model that satisfy the specified <code>request</code> (which simply is a query). </p> <p>If no request is specified, depending on the attached <code>adapter</code>, it might be that all the objects of the connected model will be input, or simply nothing will be pulled. You can read more about the requests in the Adapter Actions - advanced parameters section.</p> <p>Now, let's see the remaining \"more advanced\" Adapter Actions.</p>"},{"location":"BHoM_Adapter/#move-remove-and-execute","title":"Move, Remove and Execute","text":"<p>Slightly more advanced Actions. Again taking Grasshopper as our UI of choice, they look like this: </p> <p>Let's see what they do:</p> <ul> <li> <p>Move: This will copy objects over from a <code>source</code> connected software to another <code>target</code> software. It basically does a Pull and then a Push, without flooding the UI memory with the model you are transferring (which would happen if you were to manually Pull the objects, and then input them into a Push \u2013 between the two actions, they would have to be stored in the UI).</p> </li> <li> <p>Remove: This will delete all the objects that match a specific request (essentially, a query). You can read more about the requests in the Adapter Actions - advanced parameters section.</p> </li> <li> <p>Execute: This is used to ask the external software to execute a specific command such as Run analysis, for example. Different adapters have different compatible commands: try searching the CTRL+SHIFT+B menu for \"[yourSoftwareName] Command\" to see if there is any available one.</p> </li> </ul>"},{"location":"BHoM_Adapter/#adapter-actions-advanced-parameters","title":"Adapter Actions advanced parameters","text":"<p>You might have noticed that the Adapter Actions take some other particular input parameters that need to be explained: the Requests, the ActionConfig, and the Tags. </p> <p>Their understanding is not essential to grasp the overall mechanics; however you can find their explanation in the Adapter Actions - Advanced parameters section of the wiki.</p>"},{"location":"BHoM_Adapter/#wrap-up","title":"Wrap-up","text":"<p>The Adapter Actions have been designed using particular criteria that are explained in the next Wiki pages. </p> <p>Most users might be satisfied with knowing that they have been developed like this so they can cover all possible use cases, while retaining ease of use. </p> <p>Try some of the Samples and you should be good to go! \ud83d\ude80 </p>"},{"location":"BHoM_Adapter/#if-you-are-a-developer","title":"If you are a developer \ud83e\udd16","text":"<p>The BHoM_Adapter is one of the base repositories, with one main Project called <code>BHoM_Adapter</code>. That one is the base BHoM_Adapter. The base BHoM_Adapter includes a series of methods that are common to all software connections. Specific Adapter implementations are included in what we call the Toolkits. The base BHoM_Adapter is an <code>abstract</code> class that is implemented in each Toolkit's Adapter implementation. A Toolkit's Adapter extends the base BHoM_Adapter.</p> <p>We will see how to create a Toolkit later; however consider that, in general, a Toolkit is simply a Visual Studio solution that can contain one or more of the following: - A BHoM_Adapter project, that allows to implement the connection with an external software. - A BHoM_Engine project, that should contain the Engine methods specific to your Toolkit. - A BHoM_oM project, that should contain any oM class (types) specific to your Toolkit.</p> <p>When you want to contribute to the BHoM and create a new software connection, you will not need to implement the Adapter Actions, at least in most of the cases. If you need to, however, you can override them (more details on that in last page of this Wiki, where we explain how to implement an Adapter in a new BHoM Toolkit).</p> <p>So what is it that you need to implement?</p> <p>The answer is: the so called <code>CRUD</code> Methods. We will see them in the next page.</p>"},{"location":"BHoM_Adapter/Adapter-Actions---advanced-parameters/","title":"Adapter Actions: advanced parameters","text":"<p>The Adapter Actions have some optional inputs that allow to refine their behaviour.</p> <p>Note</p> <p>This page can be seen as an optional Appendix to the pages Introduction to BHoM_Adapter and Adapter Actions.</p> <p>These optional inputs are:</p> <ul> <li>the ActionConfig (used by all Actions: Push, Pull, Move, Remove, Execute);</li> <li>the Requests (used by the Pull)</li> <li>the Data Tags  (if implemented for the specific Adapter, they are used by: Push, Pull, Move, Remove)</li> </ul>"},{"location":"BHoM_Adapter/Adapter-Actions---advanced-parameters/#actionconfig","title":"ActionConfig","text":"<p>The ActionConfig is an object type used to specify any kind of Configuration that might be used by the Adapter Actions. </p> <p>This means that it can contain configurations that are specific to certain Actions (e.g. only to the Push, only to the Pull), and that a certain Push might be activated with a different Push ActionConfig than another one. This makes the ActionConfig different from the Adapter Settings (which are <code>static</code> global settings).</p> <p>The base ActionConfig provides some configurations that are available to all Toolkits (you can find more info about those in the code itself).</p> <p>You can inherit from the base ActionConfig to specify your own in your Toolkit. For example, if you are in the SpeckleToolkit, you will be able to find: - SpecklePushConfig: inherits from ActionConfig - SpecklePullConfig: inherits from ActionConfig</p> <p>this allows some data to be specified when Pushing/Pulling. </p> <p>ActionConfig is an input to all Adapter methods, so you can reference configurations in any method you might want to override.</p> <p></p>"},{"location":"BHoM_Adapter/Adapter-Actions---advanced-parameters/#requests","title":"Requests","text":"<p>Requests are an input to the Pull adapter Action. </p> <p>They were formerly called Queries and are exactly that: Queries. You can specify a Request to do a variety of things that always involve Pulling data in from an external application or platform. For example: - you can Request the results of an FE analysis from a connected FEM software, - specify a GetRequest when using the HTTP_Toolkit to download some data from an online RESTFul Endpoint - query a connected Database, for example when using Mongo_Toolkit.</p> <p>Requests can be defined in Toolkits to be working specifically with it.</p> <p>You can find some requests that are compatible with all Toolkits in the base BHoM object model. An example of those is the FilterRequest.</p> <p>The FilterRequest is a common type of request that basically requests objects by some specified type. See <code>FilterRequest</code>.</p> <p>In general, however, Requests can range from simple filters to define the object you want to be sent, to elaborated ones where you are asking the external tool to run a series of complex data manipulation and calculation before sending you the result. </p> <p>Additional note: batch requests</p> <p>For the case of complex queries that need to be executed batched together without returning intermediate results, you can use a <code>BatchRequest</code>. </p> <p>Additional note: Mongo requests</p> <p>For those that use Mongo already, you might have noticed how much faster and convenient it is to let the database do the work for you instead doing that in Grasshopper. It also speeds up the data transfer in cases where the result is small in bytes but involves a lot of data to be calculated.</p> <p></p>"},{"location":"BHoM_Adapter/Adapter-Actions---advanced-parameters/#data-tags","title":"Data Tags","text":"<p>When objects are pushed, it is important to have a way to know which objects needs to be <code>Update</code>d, the new ones to be <code>Create</code>d, and the old ones to be <code>Delete</code>d. </p> <p>If the number of objects changes between pushes, you cannot rely on unique identifiers to match the objects one-to-one. The problem is especially clear when you are pushing less objects than the last push.  </p> <p>Attaching a unique tag to all the objects being pushed as a group is a lightweight and flexible way to find those objects later. </p> <p>For those using D3.js, this is similar to attaching a class to html elements. For those using Mongo or Flux, this is similar to the concept of key. </p>"},{"location":"BHoM_Adapter/Adapter-Actions---advanced-parameters/#tags-in-practice","title":"Tags in practice","text":"<p>At the moment, each external software will likely require a different solution to attach the tags to the objects. </p> <p>If the software doesn't provide any solution to store the tag attached to the objects (e.g., like Groups), we could make use of another appropriate field to store the tag, for example the Name field that is quite commonly found.</p> <p>In case you need to use the Name field of the external object model, the format we are using for that is (example for an object with three tags): <pre><code>Name __Tags__:tag1_/_tag2_/_tag3\n</code></pre></p> <p>For an in depth explanation on how tags are used and what you should be implementing for them to work, read the Push section of our Adapter Actions page; in particular, look at the practical example.  </p>"},{"location":"BHoM_Adapter/Adapter-Actions/","title":"Adapter actions","text":"<p>After covering the basics in Introduction to BHoM_Adapter, this page explains the Adapter Actions more in detail, including their underlying mechanism.</p> <p>After reading this you should be all set to develop your own BHoM Toolkit! \ud83d\ude80 </p> <p>Note</p> <p>Before reading this page, make sure you have read the Introduction to BHoM_Adapter.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#how-the-adapter-actions-work","title":"How the Adapter Actions work","text":"<p>As we saw before, the Adapter Actions are backed by what we call CRUD methods. Let's see what that means.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#the-crud-paradigm","title":"The CRUD paradigm","text":"<p>A very common paradigm that describes all the possible action types is CRUD. This paradigm says that, regardless of the connection being made, the connector actions can be always categorised as: * Create = add new entries * Read = retrieve, search, or view existing entries * Update = edit existing entries * Delete = deactivate, or remove existing entries</p> <p>Some initial considerations:</p> <ul> <li> <p>Read and Delete are quite self-explanatory; regardless of the context, they are usually quite straightforward to implement.  </p> </li> <li> <p>Create and Update, on the other hand, can sometimes overlap, depending on the interface we have at our disposal (generally, the external software API can be limiting in that regard).</p> </li> <li> <p>Exposing directly these methods would make the User Experience quite complicated. Imagine having to split the various objects composing your model into the objects that need to be <code>Create</code>d, the ones that needs to be <code>Update</code>d, and so on. Not nice. </p> </li> </ul> <p>We need something simpler from an UI perspective, while retaining the advantages of CRUD - namely, their limited scope makes them simple to implement.</p> <p>The answer is the Adapter Actions: they take care of calling the <code>CRUD</code> methods in the most appropriate way for both the user and the developer.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#an-example-the-push-action","title":"An example: the Push Action","text":"<p>Let's consider for example the case where we are pushing BHoM objects from Grasshopper to an external software. The first time those objects are <code>Push</code>ed, we expect them to be <code>Create</code>d in the external software. The following times, we expect the existing objects to be <code>Update</code>d with the parameters specified in the new ones. </p>"},{"location":"BHoM_Adapter/Adapter-Actions/#in-detail-why-the-actions-crud-paradigm","title":"In detail: Why the \"Actions-CRUD\" paradigm?","text":"<p>This paradigm allows us to extend the capabilities of the CRUD methods alone, while keeping the User Experience as simple as possible; it does so mainly through the Push. The Push, in fact, can take care for the user of doing <code>Create</code> or <code>Update</code> or <code>Delete</code> when most appropriate \u2013 based on the objects that have been <code>Read</code> from the external model.</p> <p>The rest of the Adapter Actions mostly have a 1:1 correspondence with the backing CRUD methods; for example, Pull calls <code>Read</code>, but its scope can be expanded to do something in addition to only Reading. This way, <code>Read</code> is \"action-agnostic\", and can be used from other Adapter Actions (most notably, the Push). You write <code>Read</code> once, and you can use it in two different actions!</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#side-note-why-using-five-different-actions-push-pull-move-remove-execute","title":"Side note: Why using five different Actions (Push, Pull, Move, Remove, Execute)...","text":"<p>... and not something simpler, like \"Export\" and \"Import\"? ... or just exposing the CRUD methods? The reason is that the methods available to the user need to cover all possible use cases, while being simple to use. We could have limited the Adapter Actions to only Push and Pull \u2013 that does in fact correspond to Export and Import, and are the most commonly used \u2013 but that would have left out some of the functionality that you can obtain with the CRUD methods (for example, the Deletion).</p> <p>On the other hand, exposing directly the CRUD methods would not satisfy the criteria of simplicity of use for the User. Imagine having to Read an external model, then having manually to divide the objects in the ones to be <code>Update</code>d, the ones to be <code>Delete</code>d, then separately calling <code>Create</code> for the new ones you just added... Not really simple! The Push takes care of that instead.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#side-note-other-advantages-of-the-actions-crud-paradigm","title":"Side note: Other advantages of the \"Actions-CRUD\" paradigm","text":"<p>We've explained how this paradigm allows us to cover all possible use cases while being simple from an User perspective. In addition, it allows us to: 1) ensure consistency across the many, different implementations of the BHoM_Adapter in different Toolkits and contexts, therefore: 2) ensuring consistency from the User perspective (all UIs have the same Adapter Actions, backed by different CRUD methods) 3) maximise code scalability 4) Ease of development \u2013 learn once, implement everywhere</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#crud-methods-details-and-implementation","title":"CRUD methods: details and implementation","text":"<p>The paragraphs that follow down below are dedicated to explaining the relationship between the CRUD methods and the Adapter Actions. </p> <p>For first time developers, this is not essential \u2013 you just need to assume that the CRUD methods are called by the Adapter Actions when appropriate. You may now want to jump to our guide to build a BHoM Toolkit.</p> <p>You will read more about the CRUD methods and how you should implement them in their dedicated page that you should read after the BHoM_Toolkit page.</p> <p>Otherwise, keep reading.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#advanced-topic-optional-adapter-actions-complete-description","title":"Advanced topic (optional) - Adapter actions: complete description","text":"<p>We can now fully understand the Adapter Actions, complete of their relationships with their backing CRUD methods.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#push","title":"Push","text":"<p>The Push action is defined as follows: <pre><code> public virtual List&lt;object&gt; Push(IEnumerable&lt;object&gt; objects, string tag = \"\", PushType pushType = PushType.AdapterDefault, ActionConfig actionConfig = null)\n</code></pre></p> <p>This method exports the objects using different combinations of the CRUD methods as appropriate, depending on the <code>PushType</code> input. </p> <p></p> <p>Let's see again how we described the Push mechanism in the previous page:</p> <p>The Push takes the input <code>objects</code> and:    - if they don't exist in the external model yet, they are created brand new;   - if they exist in the external model, they will be updated (edited);   - under some particular circumstances and for specific software, if some objects in the external software are deemed to be \"old\", the Push will delete those. </p> <p>The determination of the object status (new, old or edited) is done through a \"Venn Diagram\" mechanism: </p> <p>The Venn Diagram is a BHoM object class that can be created with any <code>Comparer</code> that you might have for the objects. It compares the objects with the given rule (the <code>Comparer</code>) and returns the objects belonging to one of two groups, and the intersection (objects belonging to both groups).</p> <p>During the Push, the two sets of objects being compared are the objects currently being pushed, or <code>objectsToPush</code>, and the ones that have been read from the external model, or <code>existingObjects</code>.</p> <p>This is the reason why the first <code>CRUD</code> method that the Push will attempt to invoke is <code>Read</code>. The Push is an export, but you need to check what objects exist in the external model first if you want do decide what and how to export.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#additional-note-custom-comparers","title":"Additional note: custom Comparers","text":"<p>Once the <code>existingObjects</code> are at hand, it's easy to compare them with the <code>objectsToPush</code> through the Venn Diagram. Even if no specific comparer for the object has been written, the base C# IEqualityComparer will suffice to tell the two apart. If you want to have some specific way of comparing two objects (for example, if you think that two overlapping columns should be deemed the same no matter what their <code>Name</code> property is), then you should define specific comparer for that type. You can see how to do that in the next page dedicated to the BHoM_Toolkit.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#a-practical-example","title":"A practical example","text":"<p>Now, let's think that we are pushing two columns: column <code>A_new</code> and column <code>B_new</code>; and that the external model has already two columns somewhere, column <code>B_old</code> and column <code>C_old</code>. <code>B_new</code> and <code>B_old</code> are located in the same position in the model space, they have all the same properties except the Name property.</p> <p>We activate the Push.</p> <p>First, the external model is read. The existingObjects list now includes the two existing columns <code>B_old</code> and <code>C_old</code>.</p> <p>Then a VennDiagram is invoked to compare the existingObjects with the objectsToPush (which are the two pushed columns <code>A_new</code> and <code>B_new</code>).</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#1-the-object-being-pushed-is-new","title":"1) The object being pushed is new.","text":"<p>There is no existing object in the external model that corresponds to one of the columns being pushed. Easy peasy: Push will call <code>Create</code> this column for this category of objects. <code>A_new</code> is <code>Create</code>d.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#2-the-object-being-pushed-is-deemed-the-same-of-one-in-the-external-model","title":"2) The object being pushed is deemed the same of one in the external model.","text":"<p>What does \"deemed the same\" means?</p> <p>It means that the <code>Comparer</code> has evaluated them to be the same. This does not exclude that there might be some property of the objects that the Comparer is deliberately skipping to compare. </p> <p>For example, we might have a Comparer that says:</p> <p>two overlapping columns should be deemed the same no matter what their <code>Name</code> property is.</p> <p>If so, columns <code>B_new</code> and <code>B_old</code> are deemed the same.</p> <p>But then, we need to update the Name property of the column in the external model, with the most up-to-date Name from the object being pushed.</p> <p>Hence, we call <code>Update</code> for this category of objects. <code>B_new</code> is passed to the <code>Update</code> method.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#3-remaining-existing-objects-that-are-not-among-the-objects-being-pushed","title":"3) Remaining existing objects that are not among the objects being pushed.","text":"<p>What to do with this category of objects? What to do with <code>C_old</code>? </p> <p>An easy answer would be \"let's <code>Delete</code> 'em!\", probably. However, if we simply did that, then we would force the user to always input, in the objectsToPush, also all the objects that do not need to be Deleted. </p> <p>Which is what we ask the user to do anyway, but to a lesser scale.  Our approach is not to do anything to these objects, unless tags have been used.</p> <p>We assume that if the User wants the <code>Delete</code> method to be called for this category of objects, then the existing objects must have been pushed with a tag attached. If the tag of the objects being Pushed is the same of the existing objects, we deem those objects to be effectively old, calling <code>Delete</code> for them.</p> <p>Let's imagine that our column <code>C_old</code> was originally pushed with the attached tag \"basementColumns\". If I'm currently pushing columns with the same tag \"basementColumns\", it means that I'm pushing the whole set of columns that should exist in the basement. Therefore, <code>C_old</code> is <code>Delete</code>d.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#overlapping-objects-with-multiple-tags","title":"Overlapping objects with multiple tags","text":"<p>Let's say that I push a set of columns with the tag \"basementColumns\". Everything that those bars need to be fully defined \u2013 what we call the Dependant Objects, e.g. the bar end nodes (points), the bar section property, the bar material, etc. \u2013 will be pushed together with it, and with the same tag attached. </p> <p>Let's then say I then push another set of bars corresponding to an adjacent part of the building with the tag \"groundFloorColumns\". </p> <p>It could be that a column with the tag \"basementColumns\" has an endpoint that overlaps with the endpoint of another column tagged \"groundFloorColumns\". That endpoint is going to have two tags: <code>basementColumns groundFloorColumns</code>.</p> <p>The overlapping elements will end up with two tags on them: \"basementColumns\" and \"groundFloorColumns\". </p> <p>Later, I do another push of columns tagged with the tag <code>groundFloorColumns</code>. Some objects come up as existing only in the external model and not among those being pushed. Since a tag is being used and checks out, I should be deleting all these objects. However, the overlapping endpoint should not be deleted; simply, <code>groundFloorColumns</code> should be removed from its tags.</p> <p>We then call the <code>IUpdateTags</code> method for these objects (no call to <code>Delete</code>).  That is a method that should be implemented in the Toolkit and whose only scope is to update the tags. Its implementation is left to the developer, but some examples can be seen in some of the existing adapters (GSA_Adapter).</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#a-full-diagram-for-1-2-and-3","title":"A full diagram for 1), 2) and 3)","text":"<p>This diagram summarises what we've been saying so far for the Push.</p> <p></p>"},{"location":"BHoM_Adapter/Adapter-Actions/#complete-flow-diagram-of-the-push-advanced","title":"Complete flow diagram of the Push (advanced)","text":"<p>Since an image is worth a thousand words, we provide a complete flow diagram of the Push below. If you click on the image you can download it.</p> <p>This is really an advanced read that you might need only if you want to get into the nitty-gritty of the Push mechanism.</p> <p> </p>"},{"location":"BHoM_Adapter/Adapter-Actions/#pull","title":"Pull","text":"<p>The Pull action is defined as follows: <pre><code>public virtual IEnumerable&lt;object&gt; Pull(IRequest request, PullType pullType = PullType.AdapterDefault, ActionConfig actionConfig = null)\n</code></pre></p> <p>This Action has a more 1:1 correspondence with the backing CRUD method: it is essentially a simple call to Read that grabs all the objects corresponding to the specified <code>IRequest</code> (which is, essentially, simply a query). There is some additional logic related to technicalities, for instance how we deal with different IRequests and different object types (IBHoMObject vs IObjects vs IResults, etc).</p> <p></p> <p>You can find more info on Requests in their related section of the Adapter Actions - Advanced parameters wiki page.</p> <p>Note that the method returns a list of <code>object</code>, because the pulled objects must not necessarily be limited to BHoM objects (you can import any other class/type, also from different Object Models).</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#move","title":"Move","text":"<p>Move performs a Pull and then a Push. </p> <p></p> <p>It's greatly helpful in converting a model from a software to another without having to load all the data in the UI (i.e., doing separately a Pull and then a Push), which would prove too computationally heavy for larger models.</p> <p></p>"},{"location":"BHoM_Adapter/Adapter-Actions/#remove","title":"Remove","text":"<p>The Remove action is defined as follows: <pre><code>int Remove(IRequest request, ActionConfig config = null);\n</code></pre></p> <p>This method simply calls Delete. </p> <p></p> <p>You might find some Toolkits that, prior to calling Delete, add some logic to the Action, for example to deal with a particular input Request. </p> <p>The method returns the number of elements that have been removed from the external model.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#execute","title":"Execute","text":"<p>The Execute is defined as follows:</p> <pre><code>public virtual Output&lt;List&lt;object&gt;, bool&gt; Execute(IExecuteCommand command, ActionConfig actionConfig = null)\n</code></pre> <p>The Execute method provides a way to ask your software to do things that are not covered by the other methods. A few possible cases are asking the tool to run some calculations, print a report, save,... A dictionary of parameters is also provided if needed. In the case of print for example, it might be the folder where the file needs to be saved and the name given to the file. </p> <p>The method returns true if the command was executed successfully.</p>"},{"location":"BHoM_Adapter/Adapter-Actions/#next-steps-create-your-own-adapter","title":"Next steps: Create Your Own Adapter","text":"<p>Read on our guide to build a BHoM Toolkit.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/","title":"Implement an Adapter","text":"<p>An adapter can be implemented in order to add conversion features from BHoM to another software, and vice versa.</p> <p>An adapter should be added to a dedicated Toolkit repository. See the page dedicated to the The BHoM Toolkits to learn how to set up a Toolkit, which can then contain an Adapter.</p> <p>Warning</p> <p>Before reading this page, please check out:</p> <ul> <li>Getting started for developers</li> <li>Introduction to BHoM_Adapter</li> <li>Adapter Actions</li> <li>The BHoM Toolkit</li> </ul>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#main-adapter-file-and-constructor","title":"Main Adapter file and constructor","text":"<p>The main Adapter file sits in the root of the Adapter project and must have a name in the format <code>SoftwareNameAdapter.cs</code>.</p> <p>The content of this file should be limited to the following items: - The constructor of the Adapter. You should always have only one constructor for your Adapter.  You may add input parameters to the constructor: these will appear in any UI when an user tries to create it. The constructor should define some or all of the Adapter properties:    - the Adapter Settings;    - the Adapter Dependency Types;    - the Adapter Comparers;    - the AdapterIdName;    - any other protected/private property as needed. - A few protected/private fields (methods or variables) that you might need share between all the Adapter files (given that the Adapter is a <code>partial</code> class, so you may share variables across different files). Please limit this to the essential.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#the-adapter-actions","title":"The Adapter Actions","text":""},{"location":"BHoM_Adapter/Implement-an-Adapter/#overriding-the-adapter-actions","title":"Overriding the Adapter Actions","text":"<p>If you want, you can override one or more of the Adapter Actions. This can be useful for quick development.</p> <p>All Action methods are defined as <code>virtual</code>, so you can <code>override</code> them. </p> <p>In order to reuse the existing logic embedded in the Adapter Actions, you should not override them. This requires the implementation of CRUD methods which will be called by the Actions. Continue reading to learn more.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#the-adapter-settings","title":"The Adapter Settings","text":"<p>The Adapter settings are general settings that can be used by the Adapter Actions and/or the CRUD methods. </p> <p>You can define them as you want; just consider that the settings are supposed to stay the same across any instance of the same adapter, i.e. the Adapter Settings are global <code>static</code> settings valid for all instances of your Toolkit Adapter. In other words, these settings are independent of what Action your Toolkit is doing (unlike the ActionConfig). If you want to create settings that affect a specific action, implement an ActionConfig instead.</p> <p>The base BHoM_Adapter code gives you extensive explanation/descriptions/comments about the Adapter Settings. </p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#implement-the-crud-methods","title":"Implement the CRUD methods","text":"<p>The CRUD folder should contain all the needed CRUD methods. </p> <p>You can see the CRUD methods implementation details in their dedicated page.</p> <p>Here we will cover a convention that we use in the code organisation: the CRUD \"interface methods\".</p> <p>In the template, you can see how for all CRUD method there is an interface method called <code>ICreate</code>, <code>IRead</code>, etc.</p> <p>These interface methods are the ones called by the adapter. You can then create as many CRUD methods as you want, even one per each object type that you need to create. The interface method is the one that will be called as appropriate by the Adapter Actions. From there, you can dispatch to the other CRUD methods of the same type that you might have created.</p> <p>For example, in GSA_Toolkit you can find something similar to this: <pre><code>        protected override bool ICreate&lt;T&gt;(IEnumerable&lt;T&gt; objects, ActionConfig actionConfig = null)\n        {\n           return CreateObject((obj as dynamic));\n        }\n</code></pre></p> <p>The the statement <code>CreateObject((obj as dynamic))</code> does what is called dynamic dispatching. It calls automatically other Create methods (called <code>CreateObject</code> - all overloading each other) that take different object types as input.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#additional-methods-and-properties","title":"Additional methods and properties","text":"<p>The mapping from the Adapter Actions to the CRUD methods does need some help from the developer of the Toolkit. </p> <p>This is generally done through additional methods and properties that need to be implemented or populated by the developer.</p> <ul> <li>Pushing of dependant objects</li> <li>Merging objects deemed to be the same</li> <li>Merging incoming objects with objects already existing in the model</li> <li>Applying an software specific 'id' to the objects being pushed</li> </ul>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#dependency-types","title":"Dependency types","text":"<p>This is an important concept:</p> <p>BHoM does not define a relationship chain between most Object Types.</p> <p>This is because our Object Model aims to be as abstract and context-free as possible, so it can be applied to all possible cases.</p> <p>If we were to define a relationship between all types, things would be more complicated than they already are. A typical scenario is the following. Some FE analysis software define Loads (e.g. weight) as independent properties, that can be Created first and then applied to some objects (for example, to a beam). Others require you to first define the object owning the Load (e.g. a beam), and then define the Load to be applied to it (the weight).</p> <p>We can't have a generalised relationship between the beams and the loads, because not all external software packages agree on that. We should pick one. So instead, we pick none.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#note-optional-feature","title":"Note: optional feature","text":"<p>You can also avoid creating a relationship chain at all - if you are fine with exporting a flat collection of objects.   You can activate/deactivate this Adapter feature by configure the Setting: <code>m_AdapterSettings.HandleDependencies</code> to true or false. If you enable this, you must implement <code>DependencyTypes</code> as explained below.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#dependency-types-in-practice","title":"Dependency types in practice","text":"<p>We solve this situation by defining the <code>DependencyTypes</code> property: <pre><code>Dictionary&lt;Type, List&lt;Type&gt;&gt; DependencyTypes { get; }\n</code></pre> This is a property of the single Adapter \u2013 that is, it can be different for different software connections.</p> <p>The Toolkit developer should populate this accordingly to the inter-relationships that the BHoMObject hold in the perspective of the external software.</p> <p>The Dictionary key is the Type for which you want to define the Dependencies; the value is a List of Types that are the dependencies.</p> <p>An example from GSA_Toolkit: <pre><code>DependencyTypes = new Dictionary&lt;Type, List&lt;Type&gt;&gt;\n{\n    {typeof(BH.oM.Structure.Loads.Load&lt;Node&gt;), new List&lt;Type&gt; { typeof(Node) } },\n    ...\n}\n</code></pre></p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#comparers","title":"Comparers","text":"<p>The comparison between objects is needed in many scenarios, most notably in the Push, when you need to tell an old object from a new one.</p> <p>In the same way that the BHoM Object model cannot define all possible relationships between the object types, it is also not possible to collect all possible ways of comparing the object with each other. Some software might want to compare two objects in a way, some in another.</p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#note-optional-feature_1","title":"Note: optional feature","text":"<p>You can also avoid creating a default comparers - if you are fine for the BHoM to use the default C# IEqualityComparer.  </p>"},{"location":"BHoM_Adapter/Implement-an-Adapter/#adapter-comparers-in-practice","title":"Adapter Comparers in practice","text":"<p>By default, if no specific Comparer is defined in the Toolkit, the Adapter uses the IEqualityComparers to compare the objects. </p> <p>There are also some specific comparers for a few object types, most notably: * Node comparer - by proximity * BHoMObject name comparer</p> <p>However you may choose to specify different comparers for your Toolkit. You must specify them in the Adapter Constructor.</p> <p>An example from GSA_Toolkit: <pre><code>            AdapterComparers = new Dictionary&lt;Type, object&gt;\n            {\n                {typeof(Bar), new BH.Engine.Structure.BarEndNodesDistanceComparer(3) },\n                ...\n            };\n</code></pre></p>"},{"location":"BHoM_Adapter/Structural-Adapters/","title":"Structural Engineering adapters","text":"<p>This page gives examples and outlines the general common behaviour of the adapters communicating with structural engineering software. </p> <p>To get an general introduction to how the adapters are working, and how to implement a new one please see the set of wiki pages starting from Introduction to the BHoM Adapter.</p>"},{"location":"BHoM_Adapter/Structural-Adapters/#specific-structural-engineering-adapters","title":"Specific Structural Engineering adapters","text":"<p>For information regarding software specific adapter features, known issues and object relation tables, please see their toolkit wikis:</p> <ul> <li>Robot_Toolkit wiki</li> <li>GSA_Toolkit wiki</li> <li>Etabs_Toolkit wiki</li> <li>Lusas_Toolkit wiki</li> </ul>"},{"location":"BHoM_Adapter/Structural-Adapters/#pushing-and-pulling-elements","title":"Pushing and pulling elements","text":"<p>Please see the samples for examples of how to push elements to a software using the adapters.</p>"},{"location":"BHoM_Adapter/Structural-Adapters/#pushing-and-pulling-loads","title":"Pushing and pulling loads","text":"<p>The objects assigned to the loads need to have been in the software. The reason for this is that the objects need to have been tagged with a CustomData representing their identifier in the software. To achieve this you can</p> <ol> <li>First push all the elements, then in a separate step pull them out again and sort out which elements that are applicable to be loaded. (Recomended workflow)</li> <li>Use the objects output of the PushComponent. That adapter will have made sure that all objects coming out from the adapter will have been assigned with the correct tags.</li> </ol> <p>Please see the samples for examples of how to push elements to a software using the adapters.</p>"},{"location":"BHoM_Adapter/Structural-Adapters/#pulling-results","title":"Pulling results","text":"<p>Examples to be inserted</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/","title":"The CRUD methods","text":"<p>\u25c0\ufe0f Previous read: The BHoM Toolkit and Adapter Actions</p> <p></p> <p>Note</p> <p>This page can be seen as an Appendix to the pages Adapter Actions and The BHoM Toolkit.</p> <p>As we have seen, the CRUD methods are the support methods for the Adapter Actions. They are the methods that have to be implemented in the specific Toolkits and that differentiate one Toolkit from another.</p> <p>Their scope has to be well defined, as explained below.</p> <p>Note that the Base Adapter is constellated with comments (example) that can greatly help you out.</p> <p>Also the BHoM_Toolkit Visual Studio template contains lots of comments that can help you.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#create","title":"Create","text":"<p>Create must take care only of Creating, or exporting, the objects. Anything else is out of its scope. </p> <p>For example, a logic that takes care of checking whether some object already exists in the External model \u2013 and, based on that, decides whether to export or not \u2013 cannot sit in the Create method, but has rather to be included in the Push.  This very case (checking existing object) is already covered by the Push logic.</p> <p>The main point is: keep the Create simple. It will be called when appropriate by the Push.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#the-create-method-in-practice","title":"The Create method in practice","text":"<p>The Create method scope should in general be limited to this: - calling some conversion from BHoM to the object model of the specific software and a  - Use the external software API to export the objects.</p> <p>If no API calls are necessary to convert the objects, the best practice is to do this conversion in a <code>ToSoftwareName</code> file that extends the public static class <code>Convert</code>. See the GSA_Toolkit for an example of this.</p> <p>If API calls are required for the conversion, it's best to include the conversion process directly in the Create method. See Robot_Toolkit for an example of this.</p> <p>In the Toolkit template, you will find some methods to get you started for creating <code>BH.oM.Structure.Element.Bar</code> objects.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#assignnextfreeid","title":"AssignNextFreeId","text":"<p>This is a method for returning a free index that can be used in the creation process. </p> <p>Important method to implement to get pushing of dependant properties working correctly. Some more info given in the Toolkit template. </p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#read","title":"Read","text":"<p>The read method is responsible for reading the external model and returning all objects that respect some rule (or, simply, all of them).</p> <p>There are many available overloads for the Read. You should assume that any of them can be called \"when appropriate\" by the Push and Pull adapter actions.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#the-read-method-in-practice","title":"The Read method in practice","text":"<p>The Read method scope should in general be specular to the Create: - Use the external software API to import the objects. - Call some conversion from the object model of the specific software to the BHoM object model.</p> <p>Like for the Create, if no API calls are necessary to convert the objects, the best practice is to do this conversion in a <code>FromSoftwareName</code> file that extends the public static class <code>Convert</code>. See the GSA_Toolkit for an example of this.</p> <p>Otherwise, if API calls are required for the conversion, it's best to include the conversion process directly in the Read method. See Robot_Toolkit for an example of this.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#update","title":"Update","text":"<p>The Update has to take care of copying properties from from a new version of an object (typically, the one currently being Pushed) to an old version of an object (typically, the one that has been Read from the external model). </p> <p>The update will be called when appropriate by the Push.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#the-update-method-in-practice","title":"The Update method in practice","text":"<p>If you have implemented your custom object Comparers and Dependency objects, then the CRUD method <code>Update</code> will be called for any objects deemed to already exist in the model. </p> <p>Unlike the Create, Delete and Read, this method already exposes a simple implementation in the base Adapter, which may be enough for your purposes: it calls Delete and then Create.</p> <p>This is not exactly what <code>Update</code> should be \u2013 it should really be an \"edit\" without deletion, actually \u2013 but this base implementation can be useful in the first stages of a Toolkit development.</p> <p>This base implementation can always be overridden at the Toolkit level for a more appropriate one instead.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#delete","title":"Delete","text":"<p>The Update has to take care of deleting an object from an external model. The Delete is called by these Adapter Actions: the Remove and the Push. See the Adapter Actions page for more info.</p>"},{"location":"BHoM_Adapter/The-CRUD-methods/#the-delete-method-in-practice","title":"The Delete method in practice","text":""},{"location":"BHoM_Adapter/The-CRUD-methods/#deletion-of-objects-with-tag","title":"Deletion of objects with tag","text":"<p>By default, an object with multiple tags on it will not be deleted; it only will get that tag removed from itself.</p> <p>This guaranties that elements created by other people/teams will not be damaged by your delete.</p>"},{"location":"BHoM_Engine/","title":"What is the BHoM Engine?","text":"<p>The BHoM Engine repository contains all the functions and algorithms that process BHoM objects. </p> <p>As we saw in the introduction to the Object Model, this structure gives us a few advantages, in particular:</p> <ul> <li>we can see the BHoM object as a list of properties and their default values;</li> <li>in the same way, the BHoM Engine can be seen as a big collection of functions.</li> </ul>"},{"location":"BHoM_Engine/#repo-structure","title":"Repo Structure","text":"<p>The BH.Engine repository is structured to reflect this strategy. The Visual Studio Solution contains several different Projects: </p> <p></p> <p></p> <p>Each of those projects takes care of a different type of functionality. The \"main\" project however is the BHoM_Engine project: this contains everything that allows for basic direct processing of BHoM objects. The other projects are designed around a set of algorithms focused on a specific area such as geometry, form finding, model laundry or even a given discipline such as structure. </p> <p>Why so many projects? </p> <p>The main reason why the BHoM Engine is split in so many projects is to allow for a large number of people to be able to work simultaneously on different parts of the code. Keep in mind that every time a file is added, deleted or even moved, this changes the project file itself. Consequentially, submitting code to GitHub can become really painful when multiple people have modified the same files. Splitting code per project therefore limits the need to coordinate changes to the level of each focus group.</p> <p>Another benefit will be visible when we get to the \"Toolkit\" level: having different project makes it easier to manage Namespaces and make certain functionalities \"extendable\" in other parts of the code, such as in Toolkits.</p>"},{"location":"BHoM_Engine/#folder-structure","title":"Folder structure","text":"<p>If we look inside each Engine project, we can see that there are some folders. Those folders help categorize the code into specific actions. </p> <p>There are five possible action types that correspond to five different folder names: Compute, Convert, Create, Modify, and  Query. </p> <p>Let's consider the Geometry_Engine project; we can see that it contains all of those folders:</p> <p> </p> <p>Those five action names should be the same in all projects; however it's not mandatory that an Engine project should have all of them. </p> <p>Each folder contains C# files; those files must be named as the target of this action. </p>"},{"location":"BHoM_Engine/#engine-method-types","title":"Engine method types","text":"<p>In order to sort methods and organise them, 5 different categories of Engine methods exist. All methods will fall into one of these categories.</p> <ul> <li>Create: methods that instantiate a new object. Remember that the Objects are simple classes defined with no constructor (unless they must be <code>IImmutable</code> -- the only exception where constructors are allowed). You can define any number of methods that create the same objects via any combination of input parameters.</li> <li>Modify: methods that modify an object. Generally, the modify method should have a return type that is of the same type of its first argument. This is to state that the method effectively returns a modified copy of the input object.</li> <li>Query: methods that return some derived value from the input object. A derived value is something that is not found among the defining properties of the object, but that can be inferred from them. For example, the length of a Line object, if the Line itself is defined only by its start and end point.</li> <li>Convert: methods that transform the input object into another type that has similar, or equivalent, meaning. For example, converting a BHoM Structural Bar into a Robot Bar.</li> <li>Compute: methods that perform some computational or I/O heavy functionality, or which do not fall into any other of the previous categories.</li> </ul> <p>If you are in doubt, try finding another file that does a similar thing in another project, and see where that is placed.</p> <p>For example, in the Geometry_Engine project there is a <code>Query</code> folder that contains, among others, a <code>Length.cs</code> file. This file contains methods that take care of Querying the Length for geometric objects. Consider that another equally named <code>Length.cs</code> file might be present in the <code>Query</code> folder of other Engine projects; this is the case, for example, of the Structure_Engine project, where the file contains method to compute the link of <code>Bars</code> (structural objects).</p>"},{"location":"BHoM_Engine/#file-structure","title":"File Structure","text":"<p>The file is structured in a slightly unusual way for people used to classic object-oriented programming, so let's look at an example. The following is an extract from the <code>ClosestPoint.cs</code> file of the <code>Geometry_Engine</code> project.</p> <pre><code>namespace BH.Engine.Geometry\n{\n    public static partial class Query\n    {\n        /***************************************************/\n        /**** Public Methods - Vectors                  ****/\n        /***************************************************/\n\n        public static Point ClosestPoint(this Point pt, Point point) {...}\n\n        /***************************************************/\n\n        public static Point ClosestPoint(this Vector vector, Point point) {...}\n\n        /***************************************************/\n\n        public static Point ClosestPoint(this Plane plane, Point point) {...}\n\n\n        /***************************************************/\n        /**** Public Methods - Curves                   ****/\n        /***************************************************/\n\n        public static Point ClosestPoint(this Arc arc, Point point) {...}\n\n        /***************************************************/\n\n        public static Point ClosestPoint(this Circle circle, Point point) {...}\n\n        /***************************************************/\n\n        ...\n    }\n}\n</code></pre> <p>A few things should be noted:</p> <ul> <li> <p>The Namespace always starts with <code>BH.Engine</code> followed by the project name (without the suffix \"__Engine_\", obviously). </p> </li> <li> <p>The file should contain one and only one class, named like the containing folder. For example, any C# file contained in the \"Query\" folder will contain only one class called <code>Query</code>.</p> </li> <li> <p>Consequently, the name of the file itself will not correspond to the name of the class, as it is usually recommended in Object Oriented Programming. The file name will generally only reflect the name of the methods defined in it. </p> </li> <li> <p>Note that the class is declared as a partial class. Also note that the class is declared as static. </p> </li> </ul> <p>Static and partial </p> <p>The last point might be a bit cryptic for those that are not fluent in C#. Here is a brief explanation that should be enough to move on the next topics.</p> <p>static means that the content of the class is available without the need to create (instantiate) an object of that class. However, that requires that all the functions contained in the class are declared static as well. </p> <p>On the other hand, partial means that the full content of that class can be spread between multiple files. </p> <p>Having the engine action classes declared as static and partial helps us simplifying the structure of the code and expose only the relevant bits to the average contributors.</p>"},{"location":"BHoM_Engine/#class-structure","title":"Class Structure","text":"<p>Fluent C# users should have no problem understanding the structure of Engine classes. </p> <p>For those that want to get stuck without too many technical details, here are a few instructions on how to edit the action classes.</p> <ul> <li>Inside the class, create a function for each type of object you want to be able to handle. Notice that all the methods have the same name and possibly additional parameters, the only difference is the type of the first argument and possibly the return type. </li> <li>Write this in front of the first argument of each function. This will for example allow to call the methods shown above using the dot <code>.</code> notation. For example, if you have an instance of an <code>Arc</code> type called <code>myArc</code>, you will be able to do <code>myArc.ClosestPoint(refPoint)</code>. This way of defining functions is called Extension Methods and will be better explained below.</li> <li>If you find yourself typing the same code for multiple functions (or even inside the same function), you can still create private static methods. Just make sure you place them in a separate private section (use same 3 line comment) after the public methods. In rare cases, you might also want to have your own private data structure for convenience. If that data structure will never be used elsewhere, just define it at the end of the class.</li> </ul> <pre><code>namespace BH.Engine.Geometry\n{\n    public static partial class Modify\n    {\n        /***************************************************/\n        /**** Public Methods                            ****/\n        /***************************************************/\n\n        public static Mesh MergeVertices(this Mesh mesh, double tolerance = 0.001) //TODO: use the point matrix {...}\n\n\n        /***************************************************/\n        /**** Private Methods                           ****/\n        /***************************************************/\n\n        private static void SetFaceIndex(List&lt;Face&gt; faces, int from, int to) {...}\n\n\n        /***************************************************/\n        /**** Private Definitions                       ****/\n        /***************************************************/\n\n        private struct VertexIndex {...}\n    }\n}\n</code></pre> <p>Advanced topics</p> <p>While you might be able to write code in the BHoM Engine for a time without needing more than what has been explained so far, you should try to read the rest of the page. The concepts presented below are a bit more advanced; if you follow them, however, you will be able to provide a better experience to those using your code. Knowing what Polymorphism is and what the C# <code>dynamic</code> type is will also likely get you out of problematic situations, especially when you are using code from people that have not read the rest of this page.</p>"},{"location":"BHoM_Engine/#extension-methods","title":"Extension Methods","text":"<p>A concept that is very useful in order to improve the use of your methods is the concept of extension methods. You can see on the example code below that we get the bounding box of a set of mesh vertices (i.e. a List of Points) by calling mesh.Vertices.Bounds(). Obviously, the List class doesn't have a Bounds method defined in it. The same goes for the BHoM objects; they even don't contain any method at all. The definition of the Bound method is actually in the BHoM Engine. In order for any BHoM objects (and even a List) to be able to call self.Bounds(), we use extension methods. Those are basically injecting functionality into an object from the outside. Let's look into how they work:</p> <pre><code>namespace BH.Engine.Geometry\n{\n    public static partial class Query\n    {\n        ...\n\n        /***************************************************/\n        /**** public Methods - Others                  ****/\n        /***************************************************/\n\n        public static BoundingBox Bounds(this List&lt;Point&gt; pts) {...}\n\n        /***************************************************/\n\n        public static BoundingBox Bounds(this Mesh mesh)\n        {\n            return mesh.Vertices.Bounds();\n        }\n\n        /***************************************************/\n\n        ...\n\n    }\n}\n</code></pre> <p>Here is the properties of the Mesh object for reference:</p> <pre><code>namespace BH.oM.Geometry\n{\n    public class Mesh : IBHoMGeometry\n    {\n        /***************************************************/\n        /**** Properties                                ****/\n        /***************************************************/\n\n        public List&lt;Point&gt; Vertices { get; set; } = new List&lt;Point&gt;();\n\n        public List&lt;Face&gt; Faces { get; set; } = new List&lt;Face&gt;();\n\n\n        /***************************************************/\n        /**** Constructors                              ****/\n        /***************************************************/\n\n        ...\n    }\n}\n</code></pre> <p>Notice how each method has a this in front of their first parameter. This is all that is needed for a static method to become an extension method. Note that we can still calculate the bounding box of a geometry by calling BH.Engine.Geometry.Query.Bounds(geom) instead of geom.Bounds() but this is far more cumbersome.</p> <p>To be complete, we should also mention that we could simply call Query.Bounds(geom) as long as using BH.Engine.Geometry is defined at the top of the file.</p>"},{"location":"BHoM_Engine/#polymorphism","title":"Polymorphism","text":"<p>While not completely necessary to be able to write methods for the BHoM Engine, Polymorphism is still a very important concept to understand. Consider the case where we have a list of objects and we want to calculate the bounding box of each of them. We want to be able to call Bounds() on each of those object without having to know what they are. More concretely, let's consider we want to calculate the bounding box of a polycurve. In order to do so, we need to first calculate the bounding box of each of its sub-curve but we don't know their type other that it is a form of curve (i.e. line, arc, nurbs curve,...). Note that ICurve is the interface common to all the curves.</p> <pre><code>namespace BH.Engine.Geometry\n{\n    public static partial class Query\n    {\n        ...\n\n        /***************************************************/\n\n        public static BoundingBox Bounds(this PolyCurve curve)\n        {\n            List&lt;ICurve&gt; curves = curve.Curves;\n\n            if (curves.Count == 0)\n                return null;\n\n            BoundingBox box = Bounds(curves[0] as dynamic);\n            for (int i = 1; i &lt; curves.Count; i++)\n                box += Bounds(curves[i] as dynamic);\n\n            return box;\n        }\n\n        /***************************************************/\n\n        ...\n\n    }\n}\n</code></pre> <p>Polymorphism, as defined by Wikipedia, is the provision of a single interface to entities of different types. This means that if we had a method Bounds(ICurve curve) defined somewhere, thanks to polymorphism, we could pass it any type of curve that inherits from the interface ICurve.</p> <p>The other way around doesn't work though. If you have a series of methods implementing Bounds() for every possible ICurve, you cannot call Bounds(ICurve curve) and expect it to work since C# has no way of making sure that all the objects inheriting from ICurve will have the corresponding method. In order to ask C# to trust you on this one, you use the keyword dynamic as shown on the example above. This tells C# to figure out the real type of the ICurve during execution and call the corresponding method.</p>"},{"location":"BHoM_Engine/#polymorphic-extension-methods","title":"Polymorphic Extension Methods","text":"<p>Alright. Let's summarize what we have learnt from the last two sections:</p> <ul> <li> <p>Using method overloading (all methods of the same name taking different input types), we don't need a different name for each argument type. So for example, calling Bounds(obj) will always work as long as there is a Bounds methods accepting the type of obj as first argument.</p> </li> <li> <p>Thanks to extension methods, we can choose to call a method like Bound by either calling Query.Bounds(obj) or obj.Bounds(). </p> </li> <li> <p>Thanks to the <code>dynamic</code> type, we can call a method providing an interface type that has not been explicitly covered by a method definition. For example, We can call Bounds on an ICurve even if Bounds(ICurve) is not defined. </p> </li> </ul> <p>Great! We are still missing one case though: what if we want to call obj.Bounds() when obj is an ICurve? So on the example of the PolyCurve provided above, what if we wanted to replace </p> <p><pre><code>box += Bounds(curves[i] as dynamic); \n</code></pre> with  <pre><code>box += curves[i].Bounds();\n</code></pre></p> <p>But why? We have a perfectly valid way to call Bounds on an ICurve already with the first solution. Why the need for another way? Same thing as for the extention methods: it is more compact and being able to have auto-completion after the dot is very convenient when you don't know/remember the methods available. </p> <p>So if you want to be really nice to the people using your methods, there is a solution for you:</p> <pre><code>namespace BH.Engine.Geometry\n{\n    public static partial class Query\n    {\n        ...\n\n        /***************************************************/\n        /**** Public Methods - Interfaces               ****/\n        /***************************************************/\n\n        public static BoundingBox IBounds(this IBHoMGeometry geometry)\n        {\n            return Bounds(geometry as dynamic);\n        }\n    }\n}\n</code></pre> <p>If you add this code at the end of your class, this code will now work:</p> <pre><code>ICurve curve = ...;\ncurve.IBounds();\n</code></pre> <p>Two comments on that: - We used IBHoMGeometry here because every geometry implements Bounds, not just the ICurves. ICurve being a IBHoMGeometry, it will get access to IBounds(). (Read the section on polymorphism again if that is not clear to you why). In the case of a method X only supporting curves such as StartPoint for example, our interface method will simply be StartPoint(ICurve). - The \"I\" in front of IBounds() is VERY IMPORTANT. If you simply call that method Bounds, it will have same name as the other methods with specific type. Say you call this method with a geometry that doesn't have a corresponding Bounds method implemented so the only one match is Bounds(IBHoMGeometry). In that case, Bounds(IBHoMGeometry) will call itself after the conversion to dynamic. You therefore end up with an infinite loop of the method calling itself.</p> <p>PS: before anyone asks, using ((dynamic)curve).Bounds(); is not an option. Not only it crashes at run-time (dynamic and extension methods are not supported together in C#), it will not provides you with the auto completion you are looking for since the real type cannot be know statically.</p>"},{"location":"BHoM_Engine/#fallback-methods","title":"Fallback Methods","text":"<p>But what if we do not have a method implemented for every type that that can be dynamically called by IBounds? That is what private fallback methods are for. In general fallback methods are used for handling unexpected behaviours of main method. In this case it should log an error with a proper message (see Handling Exceptional Events for more information) and return null or NaN.</p> <pre><code>namespace BH.Engine.Geometry\n{\n    public static partial class Query\n    {\n        ...\n\n        /***************************************************/\n        /**** Private Methods - Fallback                ****/\n        /***************************************************/\n\n        private static BoundingBox Bounds(IGeometry geometry)\n        {\n            Reflection.Compute.RecordError($\"Bounds is not implemented for IGeometry of type: {geometry.GetType().Name}.\");\n            return null;\n        }\n\n        /***************************************************/\n\n        ...\n    }\n}\n</code></pre> <p>Being private and having an interface as the input prevents it from being accidentally called. It will be triggerd only if IBounds() couldn't find a proper method for the input type.</p> <p>Additional comment: - At this moment BHoM does not handle nullable booleans. This means it is impossible to return null from a bool method. In such cases fallback methods can throw <code>[NotImplementedException]</code>.</p>"},{"location":"BHoM_Engine/#what-about-execution-speed","title":"What About Execution Speed ?","text":"<p>For the most experienced developers among you, some might worried about execution speed of this solution. Indeed, we are not only using extension methods but also the conversion to a dynamic object. This approach means that every method call of objects represented by an interface is actually translated into two (call to the public polymorphic methods and then to the private specific one). </p> <p>Thankfully, tests have shown that efficiency lost is minimal even for the smallest functions. Even a method that calculates the length of a vector (1 square root, 3 multiplications and 2 additions) is running at about 75% of the speed, which is perfectly acceptable. As soon as the method become bigger, the difference becomes negligible. Even a method as light as calculating the length of a short polyline doesn't show more than a few % in speed difference.</p> <p> </p>"},{"location":"BHoM_Engine/#runextensionmethod-pattern","title":"RunExtensionMethod Pattern","text":"<p>The concept of polymorphic extension methods explained above has one serious limitation: it works only if all methods aimed to be called by the dynamically cast object are contained within one class. That is not the case e.g. for <code>Geometry</code> method, which is divided into a series of <code>Query</code> classes spread across discipline-specific namespaces: <code>BH.Engine.Structure</code>, <code>BH.Engine.Geometry</code> etc. To enable <code>IGeometry</code> method, a special pattern based on <code>RunExtensionMethod</code> needs to be applied:</p> <pre><code>namespace BH.Engine.Spatial\n{\n    public static partial class Query\n    {\n        /******************************************/\n        /****            IElement0D            ****/\n        /******************************************/\n\n        [Description(\"Queries the defining geometrical object which all spatial operations will act on.\")]\n        [Input(\"element0D\", \"The IElement0D to get the defining geometry from.\")]\n        [Output(\"point\", \"The IElement0Ds base geometrical point object.\")]\n        public static Point IGeometry(this IElement0D element0D)\n        {\n            return Reflection.Compute.RunExtensionMethod(element0D, \"Geometry\") as Point;\n        }\n\n        /******************************************/\n    }\n}\n</code></pre> <p><code>RunExtensionMethod</code> method is a Reflection-based mechanism that runs the extension method relevant to type of the argument, regardless the class in which that actual method is implemented. In the case above, <code>IGeometry</code> method belongs to <code>BH.Engine.Spatial.Query</code> class, while e.g. the method for <code>BH.oM.Geometry.Point</code> (which implements <code>IElement0D</code> interface) would be in <code>BH.Engine.Geometry.Query</code> - thanks to calling <code>RunExtensionMethod</code> instead of dynamic casting it can be called successfully. The next code snippet shows the same mechanism for methods with more than one input argument (in this case being an <code>IElement0D</code> to be modified and a <code>Point</code> to overwrite the geometry of the former).</p> <pre><code>namespace BH.Engine.Spatial\n{\n    public static partial class Modify\n    {\n        /******************************************/\n        /****            IElement0D            ****/\n        /******************************************/\n\n        [Description(\"Modifies the geometry of a IElement0D to be the provided point's. The IElement0Ds other properties are unaffected.\")]\n        [Input(\"element0D\", \"The IElement0D to modify the geometry of.\")]\n        [Input(\"point\", \"The new point geometry for the IElement0D.\")]\n        [Output(\"element0D\", \"A IElement0D with the properties of 'element0D' and the location of 'point'.\")]\n        public static IElement0D ISetGeometry(this IElement0D element0D, Point point)\n        {\n            return Reflection.Compute.RunExtensionMethod(element0D, \"SetGeometry\", new object[] { point }) as IElement0D;\n        }\n\n        /******************************************/\n    }\n}\n</code></pre> <p>Naturally, in order to enable the use of <code>RunExtensionMethod</code> pattern by a given type, a correctly named extension method taking argument of such type needs to be implemented.</p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/","title":"BHoM Engine Classes","text":"<ul> <li>Class titles and notation<ul> <li>Create</li> <li>Modify</li> <li>Query</li> <li>Compute</li> <li>Convert</li> <li>External</li> </ul> </li> <li>Exceptions</li> </ul>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#class-titles-and-notation","title":"Class titles and notation","text":"<p>BHoM_Engine methods are always included into a <code>static</code> class. </p> <p>Different static classes define specific scopes for the methods they contain. There are 5 different static classes: - Create - instantiate new objects - Modify - modify existing objects - Query - get properties from existing objects - Compute - perform calculation given an existing object and/or some parameters - Convert - transform an existing object into a different type - External - reflects methods from external libraries </p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#create","title":"Create","text":"<ul> <li>Returns a new object of the given class.</li> <li>Method is the name of the class being created.</li> </ul> <p><code>Bar bar = Create.Bar(line);</code></p> <p>Therefore the definition of the BHoMObject in the BHoM.dll should not contain any constructors (not even an empty default).  With the exception of objects that implement <code>IImmutable</code>. See explanation of explicitly immutable BHoM Objects somewhere else. Later.</p> <p>Object Initialiser syntax can be used with BHoM.dll only e.g.</p> <p><code>Circle circ = new Circle { Centre = new Point { X = 10 } };</code></p> <p><code>Grid grd = new Grid { Curves = new List&lt;ICurve&gt; { circ } };</code></p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#modify","title":"Modify","text":"<ul> <li>Returns a new version of the same object type as modified.</li> <li>Although immutability is enforced throughout - this namespace is for any method that would be destructive for the object being operated on.</li> <li>Simply use the Verb or SetNoun</li> </ul> <p><code>.Rotate</code> <code>.Translate</code> <code>.MergeVertices</code> <code>.SetPropertyValue</code> <code>.Explode</code> <code>.SplitAt</code> </p> <p>Modify is not actually the correct term/tense now as we are immutable! But immutability is intrinsic in the strategy for the whole BHoM now so in the interest of clarity at both code and UI level Modify as a term is being used. Answers on a postcard for a better word! </p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#query","title":"Query","text":"<ul> <li>Returns a derived property or objects or a simple boolean query (without modifying the information)</li> <li>Although immutability is enforced throughout - this namespace is for any method that would NOT be destructive for the object being operated on.</li> <li>Simply use the Noun, or Verb or prefix with Is</li> </ul> <p><code>.Area</code> <code>.Mass</code> <code>.Distance</code> <code>.DotProduct</code></p> <p><code>.Clone</code> Could be interpreted as noun or verb, so works.  </p> <p><code>.Intersect</code></p> <p><code>.IsPlanar</code> <code>.IsEqual</code> <code>.IsValid</code> <code>.IsClosed</code></p> <p>In the case of explicitly immutable BHoM objects (see <code>IImmutable</code>), using this notation for derived properties will match notation of Readonly Properties also, which is neat.</p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#compute","title":"Compute","text":"<ul> <li>For computationally more intensive methods, iterative processes and/or solvers etc.</li> </ul> <p><code>.EquilibriumPosition</code> <code>.TextFromSpeech</code> <code>.Integrate</code></p> <ul> <li>Or for modifying methods that would be destructive for the object being operated on but returns a different return type, or count of objects in a List.</li> </ul> <p><code>.Split</code></p> <p>There will potentially be grey areas between methods being classed as Query or Compute, however in general it should be clear using the above guidelines and the distinction is important to ensure code is easily discoverable from both as an end user.</p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#convert","title":"Convert","text":"<ul> <li>Returns a new type of object. </li> <li>Method has the prefix of To or From</li> </ul> <p><code>.ToJson()</code> <code>.ToSVGString()</code></p> <p>All convert methods should therefore be in a Convert Namespace within an _Engine project, thus separating this simple functionally from the _Adapter project, in any software toolkits also. However, if the objects and conversions are only related to supporting Adapter functionality, and provide no benefit to the users by being available in a UI, then <code>Convert</code> methods may exist within the Adapter project.</p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#external","title":"External","text":"<ul> <li>Contains a <code>Constructors</code> method, which returns a <code>List&lt;ConstructorInfo&gt;</code> that will be automatically reflected </li> <li>Contains a <code>Methods</code> method, which returns a <code>List&lt;MethodInfo&gt;</code> that will be automatically reflected</li> <li>Can contain any other method within the constraints presented below.</li> </ul> <p>For methods whose signature or return type includes one or more schemas that are not sourced from either the <code>BH.oM</code> or the <code>System</code> namespaces.</p>"},{"location":"BHoM_Engine/BHoM_Engine-Classes/#exceptions","title":"Exceptions","text":"<p>Keep GetGeometry and SetGeometery as method names - these perhaps to be still treated slightly differently through new IGeometrical interface? Discuss. </p> <p>Also allow an additional Objects Namespace where Engine code requires local class definitions for which there are good reasons to not promote to an _oM </p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/","title":"View Quality Conventions","text":"<p>This page describes the view quality conventions that are used within the BHoM.  The description is intended to be a non-technical guide and provide universal access to understanding the methods of calculation of different view quality metrics. Links to the relevant methods are provided for those who wish to view the C# implementation.</p> <p>Jump to the section of interest: * Measure Cvalues   * Find focal points * Measure Avalues   * Measure Occlusion * Measure Evalues * Background Information</p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#measure-cvalues","title":"Measure Cvalues","text":"<p>Method in Humans_Engine </p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#find-focal-points","title":"Find focal points","text":"<p>Method in Humans_Engine </p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#measure-avalues","title":"Measure Avalues","text":"<p>Method in Humans_Engine</p> <p>Avalue is the percentage of the spectator's view cone filled with the playing area. </p> <p></p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#measure-occlusion","title":"Measure Occlusion","text":"<p>Occlusion is the percentage of the spectator's view occluded by the heads of spectators in front.  </p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#measure-evalues","title":"Measure Evalues","text":"<p>Method in Humans_Engine</p> <p>Description coming soon...</p>"},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#background-information","title":"Background Information","text":""},{"location":"BHoM_Engine/Humans_Engine/ViewQuality/#references","title":"References","text":"<p>Hudson and Westlake. Simulating human visual experience in stadiums. Proceedings of the Symposium on Simulation for Architecture &amp; Urban Design. Society for Computer Simulation International, (2015).</p>"},{"location":"BHoM_UI/","title":"BH.UI: Expose your code to User Interfaces","text":"<p>For an user perspective on the UIs, you might be looking for Getting started for visual programmers.</p>"},{"location":"BHoM_UI/#supported-uis","title":"Supported UIs","text":"<p>The UI layer has been designed so that it will automatically pick everything implemented in the BHoM, the Engines and the Adapters without the need to change anything on the code of the UI.</p> <p>Here's what the menu looks like in Grasshopper. The number of component there doesn't have to change when more functionality is added to the rest of the code:</p> <p></p> <p>When dropped on the cavas, most of those components will have no input and no output. They will be converted to their final form once you have selected what they need to be in their menu:</p> <p></p> <p>You can get more information on how to use one of the BHoM UI on this page.</p>"},{"location":"BHoM_UI/#automatic-rendering-of-a-bhomobject","title":"Automatic rendering of a <code>BHoMObject</code>","text":"<p><code>BHoMObject</code>s are rich objects, which may or may not contain a geometry representation. If a geometry representation can be extracted, either from one of its properties, or as a result of their manipulation, it can be used to automatically render the object in the GUIs. The only action to enable that, is to create a <code>Query.Geometry</code> method, whose only parameter is the object you want to display, and place it in the <code>Engine</code> namespace that corresponds to the <code>oM</code> of the object. The method has to return an <code>IGeometry</code> or one of its assignable types.</p> <p>For example, let's assume I want to automatically display a <code>BH.oM.Structure.Elements.Bar</code>. I'd do as follows:</p> <ol> <li>Go into the correspondent Engine - i.e. <code>BH.Engine.Structure</code></li> <li>Go into the <code>Query</code> folder - i.e. <code>BH.Engine.Structure.Query</code></li> <li>If it does not exist yet, create a <code>Geometry.cs</code> file</li> <li>Add an extension method name <code>Geometry</code>, whose only parameter is the object you want to display:   <pre><code>public static Line Geometry(this BH.oM.Structure.Elements.Bar bar)\n{\n  // Extract your geometry\n  return calculatedGeoemtry\n}\n</code></pre></li> </ol>"},{"location":"BHoM_UI/#creating-a-new-ui","title":"Creating a new UI","text":"<p>Most of the functionality required by every UI has already been ported to the BHoM_UI repository or to the Engine (when used in more than the UIs). This makes the creation of a new UI a lot less cumbersome but this is still by no mean a small task. I would recommend to reach out to those that have already worked on UI (check the contributors of those repos) before you start writing a new UI from scratch.</p>"},{"location":"BHoM_oM/","title":"The Object Model (oM): define new objects","text":"<p>This section introduces the <code>BHoMObject</code>, which is the foundational class for most of the Objects found in BHoM.</p> <p>We also introduce the <code>IObject</code>, the base interface for everything in BHoM.</p>"},{"location":"BHoM_oM/#bhomobject-code-structure-and-content","title":"BHoMObject Code Structure and Content","text":"<p>A typical BHoM object definition is given simply by defining a class with some public properties. That's it! No constructors or anything needed here.</p> <p>Here is an example of what a BHoM object definition looks like:</p> <pre><code>using BH.oM.Base;\nusing BH.oM.Geometry;\n\nnamespace BH.oM.Acoustic\n{\n    public class Speaker : BHoMObject\n    {\n        /***************************************************/\n        /**** Properties                                ****/\n        /***************************************************/\n\n        public Point Position { get; set; } = new Point();\n\n        public Vector Direction { get; set; } = new Vector();\n\n        public string Category { get; set; } = \"\";\n\n        /***************************************************/\n    }\n}\n</code></pre> <p>In general, most classes defined in BHoM are a BHoM object, except particular cases.  Among these exceptions, you can find Geometry and Result types. The reason for this is both conceptual and to aid performance. Geometries and Results are not \"objects\" in the strict sense of the term. In addition, separating those types from actual <code>BHoMObject</code> objects greatly helps with performance down the line.</p>"},{"location":"BHoM_oM/#inheritance-from-bhomobject","title":"Inheritance from BHoMObject","text":"<p>Note that the name of a class in a new object definition is followed by <code>: BHoMObject</code>. This is to say that this object inherits from <code>BHoMObject</code>. This is important if you want your new class to benefit from the properties and functionalities a BHoM object provides. </p> <p>Here is a part of the BHoMObject class definition:</p> <pre><code>namespace BH.oM.Base\n{\n    public class BHoMObject : IObject\n    {\n        /***************************************************/\n        /**** Properties                                ****/\n        /***************************************************/\n\n        public Guid BHoM_Guid { get; set; } = Guid.NewGuid();\n\n        public string Name { get; set; } = \"\";\n\n        public HashSet&lt;string&gt; Tags { get; set; } = new HashSet&lt;string&gt;();\n\n        public Dictionary&lt;string, object&gt; CustomData { get; set; } = new Dictionary&lt;string, object&gt;();\n\n   }\n}\n</code></pre> <p>As you can see, the <code>BHoMObject</code> only contains a set of properties. </p> <p>As for any other class in the BHoM framework, we try to keep behaviour (functions, methods) and properties separated. Minor exceptions to this separation are seldom made for for practical efficiency and technical reasons.  The functionalities of the <code>BHoMObject</code>, as well as of the other BHoM framework types, are defined in the BHoM_Engine.</p>"},{"location":"BHoM_oM/#everything-is-an-iobject","title":"Everything is an IObject","text":"<p>As we said before, not everything is an <code>BHoMObject</code>: exceptions are Geometry and Results objects.</p> <p>However, in order to easily identify all the types coming from the BHoM framework, a basic type, or <code>interface</code>, is needed. </p> <p>That's why everything is defined to be an <code>IObject</code> at its root. All BHoM objects will always be an <code>IObject</code>, as  <code>BHoMObject</code> is itself inheriting from <code>IObject</code>. Everything else will be too through the chain of interfaces.</p> <p>Let's have a look at one of the Geometry objects, <code>Pipe</code>. As you can see, it inherits from ISurface, one of the base <code>Geometry</code> types.</p> <pre><code>namespace BH.oM.Geometry\n{\n    public class Pipe : ISurface\n    {\n        /***************************************************/\n        /**** Properties                                ****/\n        /***************************************************/\n\n        public ICurve Centreline { get; set; } = new Line();\n\n        public double Radius { get; set; } = 0;\n\n        public bool Capped { get; set; } = true;\n\n        /***************************************************/\n    }\n}\n</code></pre> <p>The interface <code>ISurface</code> inherits from another interface, <code>IGeometry</code>:</p> <p><pre><code>namespace BH.oM.Geometry\n{\n    public interface ISurface : IGeometry {}\n}\n</code></pre> And finally, <code>IGeometry</code> inherits from <code>IObject</code>, which as we said will always be the top-level of any type defined in the BHoM framework:</p> <pre><code>namespace BH.oM.Geometry\n{\n    public interface IGeometry : IObject {}\n}\n</code></pre>"},{"location":"BHoM_oM/#defining-properties","title":"Defining Properties","text":"<p>Properties correspond to the information you need to define your object (to the exception of the properties the BHoMObject class already provides). A few things to keep in mind when you create those:</p> <ul> <li>All properties must be public and have a public get and set methods, written <code>{get; set;}</code>. (This means that <code>readonly</code> properties are not directly allowed - see paragraph below \"Immutable Objects\" if you want to know more).</li> <li>Make sure you provide a default value X for your properties by using <code>= X;</code> at the end of their definition; If a properties is too complex to be defined that way, simply set it to null (write <code>= null;</code> at the end).</li> <li>Property names should not contain redundant information, for example, repeating the type of the property in its name. A property of type <code>Node</code> for example should not have <code>Node</code> in the property name unless it is the only name of the property. E.G. a property set up as <code>Node StartNode</code> should only be called <code>Start</code>, as the <code>Node</code> element comes from the property type - the better implementation of this is <code>Node Start</code>. This prevents duplication of information in the properties.</li> </ul> <p>As objects grow in complexity, it is useful to think in terms of splitting an object's properties into categories:</p> <ol> <li> <p>Object Defining properties. The minimal required information you need to construct the full object.  These should generally be the properties of the objects defined in the BHoM</p> </li> <li> <p>Derived properties.  Any property that could be calculated from the other properties. These should generally be handled by the BHoM_Engine using extension methods. This choice allows to  calculate and obtain those properties only when needed; however, it also mean that you will have to write an explicit \"get\" method that users will be able to access through the dot <code>.</code> accessor.</p> </li> <li> <p>Software specific properties such as Software IDs, etc. To ensure that the BHoM is software agnostic, we resorted to store this information in a dynamic (not statically typed) way. That's why we're using a <code>Dictionary</code> (list of key-value pairs) property of the BHoMObject called <code>CustomData</code>. For example, the ID assigned to an object for a certain software will be stored as a value of the Key <code>softwareName_id</code>. </p> </li> <li> <p>Results from analysis. These are to be generally stored as a completely different set of classes, as you can have thousands of results per object.</p> </li> </ol> <p>As an example between Defining and Derived properties for geometry:  A line is defined by two points. These two points are properties of the line (category 1). A line can also have a length, but as that can be derived from the points, this instead sits in the BHoM_Engine as a method called \"Length()\" (category 2). This structure makes sure that on update of the points, the length will also be updated ensuring compatibility of properties at all times.</p>"},{"location":"BHoM_oM/#defining-constructors-and-local-methods","title":"Defining Constructors and Local Methods","text":"<p>Important: To the exception of Immutable Objects, BHoM objects should never have a constructor. In general, there should be no method defined in the class either (see Casting methods). So, ultimately, a BHoM object is really nothing more than a list of properties and their default values. Objects will be created either by using an Object Initialiser or via a <code>Create</code> method from the Engine. </p> <p>Anything that manipulates data should generally be in the BHoM Engine. That being said, there are rare occasions where you will see a local method written directly in the object definition. Those methods are generally created there for optimisation reasons or because of the constraints of C# and are therefore the exception, not the rule.</p> <p>For those of you coming from object oriented programming, it might seems quite unnatural to take functionality outside a class as much as possible. There is a few reasons why we have gone that direction:</p> <ul> <li>Properties of an object are unlikely to change frequently and it is reasonable to expect a list of properties to converge quickly to a final solution, never to be touched again. The methods, on the other hand are always growing, improving or being debugged. Keeping them in more isolated packages will reduce the impact of their change.</li> <li>We want as many people to be able to contribute as possible. While not everyone will be able to write complex algorithms, we expect every engineer to be able to define what properties should be found in an object he/she is using regularly. By separating the complexity levels in different repos, people are enabled to participate by focusing on the part they are comfortable with.</li> <li>Some of the contributors to the BHoM might wish to keep a few methods and algorithms related to a BHoM object private. By limiting the BHoM to object definitions, we are making it easier to share the object models without being forced to share anything else. Do not worry though, the Engine already contains plenty of useful methods and is constantly growing.</li> </ul> <p>The main disadvantage is that the hierarchical structure of the repositories makes mandatory to update/rebuild any other repository that comes down. For example, any change to the BHoM repository means there is large ripple effect on nearly every other repository.</p>"},{"location":"BHoM_oM/#namespace-and-folder-structure","title":"Namespace and Folder Structure","text":"<ul> <li>BHoM objects are organised as shown in the image below. All analytical objects are stored in their respective discipline project (e.g. Structure, Environment,...).  </li> <li>A Common project is user for objects shared between disciplines. </li> <li>The inter-disciplinary representation is expressed through physical objects (stored in the Physical folder).</li> <li>Finally, the BHoM and Geometry folders contain core objects and geometry definitions respectively. </li> </ul> Example view of the BHoM solution <p>Namespaces have to match the folder structure. </p> <p>In the rare case where folders are more than 3 levels deep, the namespaces are allowed to stop there. For example, the BH.oM.Structure.Results folder contains subfolders. Objects defined in those subfolders are allowed to use the namespace BH.oM.Structure.Results instead of BH.oM.Structure.Results.SubFolder.</p> <p></p>"},{"location":"BHoM_oM/#immutable-objects","title":"Immutable Objects","text":"<p>Warning: This is more advanced feature and not necessary in 99% of the case so you can safely skip this.</p> <p>For some rare objects, it would be problematic to keep only the Defining properties. That is generally the case if the Derived properties are very expensive to compute. In that case, those objects should inherit from the <code>IImutable</code> interface. This is explicitly stating that the properties of those objects should not be modified as it would create inconsistencies within the object. In that case, the properties that are overlapping would only have a <code>{ get; }</code> accessor instead of the usual <code>{ get; set; }</code>. Here's an example of such a class (with some skipped section highlighted as <code>...</code>)</p> <pre><code>public class CableSection : BHoMObject, ISectionProperty, IImmutable\n{\n    /***************************************************/\n    /**** Properties                                ****/\n    /***************************************************/\n\n    public Material Material { get; set; } = null;\n\n    /***************************************************/\n    /**** Properties - Section dimensions           ****/\n    /***************************************************/\n\n    public int NumberOfCables { get; } = 0;\n\n    public double CableDiameter { get; } = 0;\n\n    public CableType CableType { get; } = CableType.FullLockedCoil;\n\n    public double BreakingLoad { get; }\n\n    ...\n\n    /***************************************************/\n    /**** Constructors                              ****/\n    /***************************************************/\n\n    public CableSection(...)\n    {\n        ...\n    }\n\n    /***************************************************/\n}\n</code></pre> <p>Apart from the use of <code>{ get; }</code> instead of <code>{ get; set; }</code>, you will notice that <code>IImmutable</code> objects will have to define their own constructors inside the class. This is because Object Initialiser do not work on properties without a <code>set</code> so we cannot simply define the constructors in the Engine as we usually do.</p>"},{"location":"BHoM_oM/#casting-methods","title":"Casting Methods","text":"<p>Warning: This is more advanced feature and not necessary in 99% of the case so you can safely skip this.</p> <p>It is convenient for some objects to be able to be casted from something else. For Example, a geometrical Point could be casted from a Vector or a structural Node could be casted from a Point. This is especially useful inside a user interface. Here's an example where this case is relevant:</p> <p></p> <p><pre><code>public class Node : BHoMObject\n{\n    /***************************************************/\n    /**** Properties                                ****/\n    /***************************************************/\n\n    public Point Position { get; set; } = new Point();\n\n    public Constraint6DOF Constraint { get; set; } = null;\n\n\n    /***************************************************/\n    /**** Explicit Casting                          ****/\n    /***************************************************/\n\n    public static explicit operator Node(Point point)\n    {\n        return new Node { Position = point };\n    }\n\n    /***************************************************/\n}\n</code></pre> As you can see, we can skip the step of creating a Node since it would only need the Point anyway.</p> <p>Unfortunately, C# doesn't allow to define this outside the class so we have no choice but to do it in the BHoM. Be mindful that this is only relevant when an object could be created from a single other element so this only apply in unique cases and shouldn't be defined in every class.</p>"},{"location":"BHoM_oM/BHoM-Units-conventions/","title":"BHoM Unit conventions","text":"<p>This page describes the Units conventions for the BHoM.</p>"},{"location":"BHoM_oM/BHoM-Units-conventions/#general-philosophy-use-si","title":"General philosophy: use SI!","text":"<p>The BHoM framework adheres as much as possible to the conventions of the SI system.</p> <p>Any Engine method must operate in SI to avoid complexity of Unit Conversions inside calculations. Conversion to and from SI is the responsibility of the Converts inside the Adapters. </p> <p>When some units (derived or not) are not explicitly covered by this Wiki page, it is generally safe to assume that measures expressed in SI units will not be converted by the BHoM.</p> <ul> <li>Mass: kilograms [kg]</li> <li>Length: meters [m]</li> <li>Force: Newtons [N]</li> <li>Moments: [N*m]</li> <li>Stress/Pressure: [N/m\u00b2]</li> <li>Spring constraints: [N/m]</li> <li>Rotational constraints: [N*m/rad]</li> <li>Temperature: [K]</li> </ul>"},{"location":"BHoM_oM/BHoM-Units-conventions/#localisation-toolkit","title":"Localisation toolkit","text":"<p>The Localisation_Toolkit provides support for conversion between SI and other units systems.</p>"},{"location":"BHoM_oM/BHoM-Units-conventions/#quantity-attributes","title":"Quantity attributes","text":"<p>BHoM object properties can be decorated with a Quantity Attribute to define (in SI) what unity the property should be considered in.  This is to be applied only to properties that are of a primitive numerical type, e.g. <code>int</code>, <code>double</code>, etc. </p> <p>See Quantities_oM for the available attributes.</p>"},{"location":"BHoM_oM/JSONSchema/","title":"BHoM JSON Schema","text":""},{"location":"BHoM_oM/JSONSchema/#general","title":"General","text":"<p>The object model (oM) of the BHoM and a majority BHoM Toolkits exists as Json-Schemas stored in the BHoM_JSONSChema repository. All schemas are currently being automatically generated based on the C# types in selected repositories in the BHoM organisation.</p>"},{"location":"BHoM_oM/JSONSchema/#id","title":"Id","text":"<p>All schemas are assigned an $id. This id is a uri linking to the exact storage location of the particular file on github, in its raw format. Using this principle means that the schemas can be validated using online validators including handling of references. The exact link will be containing the name of the current branch on which the file is currently stored, see examples in the section below, all on taken from schemas on the develop branch. This has an implication in how releases are handled, as the exact link to the schema, and hence its id will vary based on its current release.  For more information, see the release section.</p>"},{"location":"BHoM_oM/JSONSchema/#references","title":"References","text":"<p>The BHoM JSON schemas make use of references ($ref) for handling dependencies between types, in particular for handling properties as well as interfaces. The reference across to another type is used using the id of the type that is being referenced.</p> <p>A major benfit of using this type of structure is that in reduces the size and complexity of the schemas, especially for cases when a property is targeting an interface.</p>"},{"location":"BHoM_oM/JSONSchema/#properties","title":"Properties","text":"<p>For properties that target another IObject, the property is linked across via $ref. This allows for greater flexibility as well as simpler composition, especially for more complex schemas. As an example, the Line class has two properties, start and end, that are of type Point. These properties are referenced in via the ref keyword:</p> <p>Example</p> Line.json<pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Line.json\",\n\"title\" : \"Line\",\n\"type\" : [\"object\", \"null\"],\n\"description\" : \"Line: A straight segment in space defining the shortest distance between two points in three-dimensional Euclidean geometry.\\nThe Vector from Start to End defines the Line direction, which can be important for some applications.\",\n\"properties\" : {\n    \"Start\" : {\n    \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Point.json\"\n    },\n    \"End\" : {\n    \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Point.json\"\n    },\n    \"Infinite\" : {\n    \"type\" : \"boolean\",\n    \"description\" : \"Defines the Line as a ray of infinite extents in both directions\"\n    },\n    \"_t\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional type disciminator.\",\n    \"const\" : \"BH.oM.Geometry.Line\"\n    },\n    \"_bhomVersion\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional version of BHoM used as part of automatic versioning and schema upgrades.\"\n    }\n},\n\"required\" : [\"Start\", \"End\", \"Infinite\"]\n}\n</code></pre> Point.json<pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Point.json\",\n\"title\" : \"Point\",\n\"type\" : [\"object\", \"null\"],\n\"description\" : \"Point: Defines a dimensionless location in three-dimensional space.\",\n\"properties\" : {\n    \"X\" : {\n    \"type\" : \"number\",\n    \"description\" : \"Position along global X coordinate axis.\"\n    },\n    \"Y\" : {\n    \"type\" : \"number\",\n    \"description\" : \"Position along global Y coordinate axis.\"\n    },\n    \"Z\" : {\n    \"type\" : \"number\",\n    \"description\" : \"Position along global Z coordinate axis.\"\n    },\n    \"_t\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional type disciminator.\",\n    \"const\" : \"BH.oM.Geometry.Point\"\n    },\n    \"_bhomVersion\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional version of BHoM used as part of automatic versioning and schema upgrades.\"\n    }\n},\n\"required\" : [\"X\", \"Y\", \"Z\"]\n}\n</code></pre> <p>In the example above, you can see that the Point class is referenced across using the $ref keyword, and that the $id of the point is exactly matching the ref used.</p>"},{"location":"BHoM_oM/JSONSchema/#interfaces","title":"Interfaces","text":"<p>Interface schemas has been set up to help validate a schema as a particular interface. To acheive this, the interface schemas are set up to be aware of all subtypes available as schemas. </p> <p>For a json object to validate against a interface schema it requires the type discriminator \"_t\" to be set on the object. This is then being used to first check that the type is of a type that is known to be a subtype of the interface via the enum keyword.</p> <p>Note</p> <p>The type discriminator \"_t\" is not generally set as required across the BHoM JSON schemas for validation against a known class schema. When validating against a interface schema, at base level or as a property, however it is required to determine the schema to validate against.</p> <p>Warning</p> <p>To successfully evaluate a type that is implementing an interface agaist the schema of that interface, the subtype needs to known at the point of creation of the interface schema. This means a class in a repo not set to be part of the generation wont be able to be validated against its base interface, even if it is implementing that inferface in C#.</p> <p>It then uses the if then + all of pattern to validate the object against the appropriate type.</p> <p>Note</p> <p>The benefit of this approach over using the one of or any of pattern is that it makes the validation and messaging a lot clearer. When the chosen aproach is failing to validate the type againt the know type _t, it will showcase the exact reason that particular validation is failing. In contrast, using the oneOf or anyOf pattern will instead showcase the failures against all listed schemas.</p> <p>As an example, a Line with a start point missing the required property Z validated as an ICurve with the allof-if then pattern show the missing Z and just that as the reason for the validation failure. In contrast, a oneOf/anyOf aproach would instead show that failure, but also show why it was failing to validate as all other ICurve types, such as Arc, Circle, NurbsCurve etc.</p> <p>An example JSON Schema for the IPolyline can be seen below. Here it can be noted that the <code>\"_t\"</code> property is required (line 3), and need to be set to exactly match one of the two classes that implement this interface, the Polyline and Polygon (line 6).</p> <p>Then the all-of + if-the pattern follows, which can be read as: If the value <code>\"_t\"</code> is equal to <code>\"BH.oM.Geometry.Polyline\"</code> (line 14), then the schema should evaluate against the schema of the Polyline (line 20), and similarly for the Polygon (line 27 and 33).</p> <p>The initial part of requiring <code>\"_t\"</code> to exist and match one of the types guarantiues that only valid types are validated as correct. The allOf if, then ensures that this subtime is valid against the matching schema.</p> <p>Example</p> IPolyline<pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/IPolyline.json\",\n\"required\" : [\"_t\"],\n\"properties\" : {\n    \"_t\" : {\n    \"enum\" : [\"BH.oM.Geometry.Polyline\", \"BH.oM.Geometry.Polygon\"]\n    }\n},\n\"allOf\" : [{\n    \"if\" : {\n        \"properties\" : {\n        \"_t\" : {\n            \"type\" : [\"string\", \"null\"],\n            \"const\" : \"BH.oM.Geometry.Polyline\"\n        }\n        },\n        \"required\" : [\"_t\"]\n    },\n    \"then\" : {\n        \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Polyline.json\"\n    }\n    }, {\n    \"if\" : {\n        \"properties\" : {\n        \"_t\" : {\n            \"type\" : [\"string\", \"null\"],\n            \"const\" : \"BH.oM.Geometry.Polygon\"\n        }\n        },\n        \"required\" : [\"_t\"]\n    },\n    \"then\" : {\n        \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Polygon.json\"\n    }\n    }]\n}\n</code></pre>"},{"location":"BHoM_oM/JSONSchema/#enums","title":"Enums","text":"<p>C# enums are generally serialised into strings using the BHoM Serialiser_Engine. This means they can be validated using the JSON schema enum keyword.</p> <p>The exception to this rule is when either the enum is serialised as a top level object, or when it is stored in json under a property of a different type, for example System.Object. For this case, the enum is serialised as an object aware of the type, and with the value stored as a property.</p> <p>To handle both these cases BHoM enums are turned into JSON schemas wrapped in an anyOf keyword.</p> <p>Example</p> <p>Example below shows the JSON schema for the Offset enum. The highlighted portions in the tabs below correspond to the two different options for the handling of the enums. The anyOf pattern on line 3 makes it so that any of the two options will validate as correct.</p> Simple - as known propertyAs top level object <pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Physical_oM/Elements/Offset.json\",\n\"anyOf\" : [{\n    \"type\" : [\"string\", \"null\"],\n    \"enum\" : [\"Undefined\", \"Centre\", \"InnerEdge\", \"OuterEdge\"]\n    }, {\n    \"type\" : [\"object\", \"null\"],\n    \"properties\" : {\n        \"_t\" : {\n        \"type\" : [\"string\", \"null\"],\n        \"const\" : \"System.Enum\"\n        },\n        \"TypeName\" : {\n        \"type\" : [\"object\", \"null\"],\n        \"properties\" : {\n            \"_t\" : {\n            \"type\" : [\"string\", \"null\"],\n            \"const\" : \"System.Type\"\n            },\n            \"Name\" : {\n            \"type\" : [\"string\", \"null\"],\n            \"const\" : \"BH.oM.Physical.Elements.Offset\"\n            }\n        }\n        },\n        \"Value\" : {\n        \"type\" : [\"string\", \"null\"],\n        \"enum\" : [\"Undefined\", \"Centre\", \"InnerEdge\", \"OuterEdge\"]\n        }\n    }\n    }]\n}\n</code></pre> <pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Physical_oM/Elements/Offset.json\",\n\"anyOf\" : [{\n    \"type\" : [\"string\", \"null\"],\n    \"enum\" : [\"Undefined\", \"Centre\", \"InnerEdge\", \"OuterEdge\"]\n    }, {\n    \"type\" : [\"object\", \"null\"],\n    \"properties\" : {\n        \"_t\" : {\n        \"type\" : [\"string\", \"null\"],\n        \"const\" : \"System.Enum\"\n        },\n        \"TypeName\" : {\n        \"type\" : [\"object\", \"null\"],\n        \"properties\" : {\n            \"_t\" : {\n            \"type\" : [\"string\", \"null\"],\n            \"const\" : \"System.Type\"\n            },\n            \"Name\" : {\n            \"type\" : [\"string\", \"null\"],\n            \"const\" : \"BH.oM.Physical.Elements.Offset\"\n            }\n        }\n        },\n        \"Value\" : {\n        \"type\" : [\"string\", \"null\"],\n        \"enum\" : [\"Undefined\", \"Centre\", \"InnerEdge\", \"OuterEdge\"]\n        }\n    }\n    }]\n}\n</code></pre>"},{"location":"BHoM_oM/JSONSchema/#releases","title":"Releases","text":"<p>The BHoMJsonSchemas are released in a similar fashion as general BHoM releases, with some caveats and additions.</p>"},{"location":"BHoM_oM/JSONSchema/#develop-state","title":"Develop state","text":"<p>Throughout a BHoM Milestone the JSON schemas are updated each week by the use of github actions that trigger each weekend and re-generates all BHoM JSON schemas according to the current state of the C# classes throughout the BHoM organisation. </p> <p>This means that targeting a schema on the develop branch is guarantiued to be validating against the up to date schema and definition of that particular object. It however also means that you are validating against something that has the potential to change - be it the particular object itself or one of its sub properties.</p>"},{"location":"BHoM_oM/JSONSchema/#beta-releases","title":"Beta releases","text":"<p>At the end of each Milestone a  BHoM beta is released, and with it a set of JSON schemas matching that particular release.</p> <p>The JSON schemas for this release will be frozen, and generally not change. To acheive this it means that their $id property as well as storage link needs to be updated, which in turn has the implication that all of the references need to be updated.</p> <p>To achieve this a new branch is created at the end of each milestone, with name as <code>v.MajorNumber.MinorNumber</code> matching the current release, see example here.</p> <p>On this branch, all schemas are then re-generated with the branch set to the name of the current branch being released. This will update all <code>$id</code> as well as <code>$ref</code> keywords to be pointing to the version at this particular branch.</p> <p>Once this is done, the branch is then tagged, and a release created the same way as it is done for the rest of the BHoM.</p> <p>The release branches will then be left unchanged, making it possible to retreive the frozen versions of the schemas as the develop versions progress.</p> <p>Example</p> <p>This showcases the Json schema for the Line object. Pay attention to the highlighted lines to see the difference between the develop and 8.2 version of the line, where the $id as well as the $ref is changed with the context.</p> developv8.2 <pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Line.json\",\n\"title\" : \"Line\",\n\"type\" : [\"object\", \"null\"],\n\"description\" : \"Line: A straight segment in space defining the shortest distance between two points in three-dimensional Euclidean geometry.\\nThe Vector from Start to End defines the Line direction, which can be important for some applications.\",\n\"properties\" : {\n    \"Start\" : {\n    \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Point.json\"\n    },\n    \"End\" : {\n    \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Point.json\"\n    },\n    \"Infinite\" : {\n    \"type\" : \"boolean\",\n    \"description\" : \"Defines the Line as a ray of infinite extents in both directions\"\n    },\n    \"_t\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional type disciminator.\",\n    \"const\" : \"BH.oM.Geometry.Line\"\n    },\n    \"_bhomVersion\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional version of BHoM used as part of automatic versioning and schema upgrades.\"\n    }\n},\n\"required\" : [\"Start\", \"End\", \"Infinite\"]\n}\n</code></pre> <pre><code>{\n\"$id\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/v8.2/Geometry_oM/Line.json\",\n\"title\" : \"Line\",\n\"type\" : [\"object\", \"null\"],\n\"description\" : \"Line: A straight segment in space defining the shortest distance between two points in three-dimensional Euclidean geometry.\\nThe Vector from Start to End defines the Line direction, which can be important for some applications.\",\n\"properties\" : {\n    \"Start\" : {\n    \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/v8.2/Geometry_oM/Point.json\"\n    },\n    \"End\" : {\n    \"$ref\" : \"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/v8.2/Geometry_oM/Point.json\"\n    },\n    \"Infinite\" : {\n    \"type\" : \"boolean\",\n    \"description\" : \"Defines the Line as a ray of infinite extents in both directions\"\n    },\n    \"_t\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional type disciminator.\",\n    \"const\" : \"BH.oM.Geometry.Line\"\n    },\n    \"_bhomVersion\" : {\n    \"type\" : [\"string\", \"null\"],\n    \"description\" : \"Optional version of BHoM used as part of automatic versioning and schema upgrades.\"\n    }\n},\n\"required\" : [\"Start\", \"End\", \"Infinite\"]\n}\n</code></pre>"},{"location":"BHoM_oM/JSONSchema/#validation","title":"Validation","text":"<p>THe BHoM ecosystem currently does not contain any internal tools for validation of a json object against a schema, but relies of external packages for this task.</p> <p>There are plenty of tools available online to help with this, please see https://json-schema.org/tools for a long list of available tools and packages in multiple languages.</p> <p>Some tools have however been tested internally with success:</p>"},{"location":"BHoM_oM/JSONSchema/#online-validators","title":"Online validators","text":""},{"location":"BHoM_oM/JSONSchema/#httpswwwjsonschemavalidatornet","title":"https://www.jsonschemavalidator.net/","text":"<p>To use this tool, simply put the Id of the schema you want to evalusate against as a <code>$ref</code> in the left hand pane, and the Json of the object you want to validate in the right hand pane. For example, to evaluate against a Line, put the following in the left hand side pane:</p> <pre><code>{\n \"$ref\":\"https://raw.githubusercontent.com/BHoM/BHoM_JSONSchema/develop/Geometry_oM/Line.json\"\n}\n</code></pre> <p>To find the Id of the object you want to validate, please locate the schema in the folders of this repo and look at the <code>$id</code> property. Alternatively, you can navigate to the file in the browser and hit the \"raw\" button, and copy the link as the <code>$ref</code>.</p>"},{"location":"BHoM_oM/JSONSchema/#httpsnebulapacketcodersiojson-schema-validator","title":"https://nebula.packetcoders.io/json-schema-validator/","text":"<p>Use a similar process as with the jsonschemavalidator outlined above.</p>"},{"location":"BHoM_oM/JSONSchema/#dotnet-validators","title":"DotNet validators","text":""},{"location":"BHoM_oM/JSONSchema/#jsoneverything","title":"JsonEverything","text":"<p>Has been tested and working for validation within the C# environment, building your custom evaluator. An example of this can be found here</p>"},{"location":"BHoM_oM/JSONSchema/#generation","title":"Generation","text":"<p>The JsonSchema_Toolkit has been set up to help facilitate generation of BHoM JSON schemas. This toolkit contains schemas and methods to help turning a C# type into a JSON Schema as well as to write the schema out to text.</p>"},{"location":"BHoM_oM/JSONSchema/#schema-generator","title":"Schema generator","text":"<p>A simple console app has been set up in the .ci folder of the BHoM_JSONSchema repository. This console app can be run to (re)generate all schemas for BHoM objects.</p> <p>Before running locally, please do ensure that you have all repositories stated in the Included-repositories.txt cloned and built on your machine.</p> <p>The app loads all available BHoM oM (object model) assemblies available. For each assembly, it then cleans the corresponding schema folder and then generates a up to date version schema for each type in the assembly.</p> <p>Warning</p> <p>The schemas should always be generated as a full package across all assemblies listed, never just partwise generated. Reason for this is that base level interfaces need to be made aware of all sub-types that implement it. Please see the section on interfaces for more information.</p> <p>When generating the schemas for the develop branch the code can be run as is, after the above prerequisite of making sure all repos available has been met.</p> <p>When generating schemas for release, the app should be run either with providing the approriate branch name as an input arg to the app, or by temporarily changing the default value of the branch config to the appropriate value.</p> <p>After all schemas have been generated, they should be tested to ensure the (re)generated schemas are correct. Once testing has passed, the schemas can be updated and pushed up to the remote using standard github procedures.</p>"},{"location":"BHoM_oM/JSONSchema/#testing","title":"Testing","text":"<p>Unit tests have been set up in the .ci folder of the BHoM_JSONSchema repository.</p> <p>This contains tests that:</p> <ul> <li>Valid objects validate as valid</li> <li>Invalid objects validates as invalid (added to give confidence that the validation is correct)</li> <li>Tests to ensure all assemblies are available on the machine executing the tests.</li> </ul>"},{"location":"BHoM_oM/JSONSchema/#config","title":"Config","text":"<p>The Convert config given control for how the JSON Schemas should be generated. It currently primarlily hadles settings relating to how ids and references should be handled.</p> <p>The convert config is passed along with the C# type in the type to JSONSchema method.</p>"},{"location":"BHoM_oM/JSONSchema/#includeid","title":"IncludeId","text":"<p>Controls wether the id keyword should be added to the top level document or not. This is by default set to true, and true for the schemas stored on BHoM_JSONSchema.</p>"},{"location":"BHoM_oM/JSONSchema/#typesasref","title":"TypesAsRef","text":"<p>Bool indicating if types used by the parent type should be linked to as ref, or fully expanded. Generally strongly recomended to set this boolean to true for the general case, which is also the default value as well as what is used for the schemas stored on BHoM_JSONSchema. Ssetting this to false will expand content of all inner types, as well as their subtype, into the main schema file. For types with abstract or interface properties, this will get even more extreme as all option will be populated. Generally only consider setting this to false for types with few levels of nested property types, and no interface types as properties.</p>"},{"location":"BHoM_oM/JSONSchema/#includeinnerids","title":"IncludeInnerIds","text":"<p>Control for if the id keyword should be added for inner schemas. Only applicable if TypeAsRef is false, hence never used for the schemas stored on BHoM_JSONSchema. Defaults to false.</p>"},{"location":"BHoM_oM/JSONSchema/#branch","title":"Branch","text":"<p>String controling the branch to be used for the id as well as ref keywords. This defaults to <code>\"develop\"</code> which is the value that should be used when generating the live updates. When a new release is made, this should be changed to the name of that release, i.e., vMajorVersion.MinorVersion, for example <code>v8.2</code></p>"},{"location":"BHoM_oM/JSONSchema/#organisationstoinclude","title":"OrganisationsToInclude","text":"<p>List of organisations to include when generating schema. Only types in these organisations will be included. This is checked by inspection of the AssemblyDescriptionAttribute, which requires the assembly to link the the github organisation matching one of the organisations in this list. This defaults to only include the BHoM organisation, which also is what is being used for the schemas stored on BHoM_JSONSchema.</p>"},{"location":"BHoM_oM/JSONSchema/#github-actions","title":"Github actions","text":"<p>To help keep the schemas up to date with current state of develop branch, github actions has been set up to run every weekend, at the night between friday and saturday.</p> <p>This action automatically runs clones all repos from the Included-repositories.txt, then runs the generation, runs the test and finally raises a pull request with changes. This Pullrequest will then need to be reviewed and merged in to develop.</p>"},{"location":"BHoM_oM/Base_oM/Attributes/","title":"BHoM Attributes","text":"<p>The BHoM framework makes use of C# Attributes to annotate and explain classes, methods and properties. Attributes used is a combination custom attributes created in the BHoM and the one provided by the core C# libraries.</p> <p>The information provided in the attributes will be used by the UI and help control what is exposed as well as give the end user a better understanding of what your method is supposed to do.</p> <p>To make use of the custom attributes you will need to make sure that your project has a reference to the <code>Base_oM</code>. You will also need to to make sure that the following usings exists in the .cs file you want to use the attributes in:</p> <pre><code>using BH.oM.Base.Attributes;\nusing System.ComponentModel;\n</code></pre> <p>The attributes are described below.</p>"},{"location":"BHoM_oM/Base_oM/Attributes/#description","title":"Description","text":"<p>Only consists of a single string and can be used on a class, method or a property. Used to give a general explanation of what the class/ method or property is doing. You can only add one description to each entity. Example:</p> <pre><code>        [Description(\"Calculates the counterclockwise angle between two vectors in a plane\")]\n        public static double Angle(this Vector v1, Vector v2, Plane p)\n        {\n            //....code\n        }\n</code></pre>"},{"location":"BHoM_oM/Base_oM/Attributes/#description-authoring-guidelines","title":"Description authoring guidelines \u270f\ufe0f","text":"<p>We should be aiming for all properties, objects and methods to have a description. With only the very simplest of self explanatory properties to not require a description by exception - and indeed only where the below guidelines can not be reasonably satisfied. </p> <p>So what makes a good description?</p> <ol> <li>A description must impart additional useful information beyond the property name, object and namespace. </li> <li>Further to a definition, the description is an opportunity to include usage guidance, tips or additional context.</li> <li>The description is a place you can include synonyms etc. to help clarify for others in different regions/domains, being inclusive as possible.</li> <li>Also don't forget the addition of a Quantity Attribute can be used now, appropriate for Doubles and Vectors.</li> </ol>"},{"location":"BHoM_oM/Base_oM/Attributes/#displaytext","title":"DisplayText","text":"<p>Only consists of a single string and can be used on enums. Used to provide a human-friendly text version of the enum in the UI. Example:</p> <pre><code>    public enum Market\n    {\n        Undefined,\n        [DisplayText(\"Europe ex UK &amp; Ireland\")]\n        Europe_ex_UKAndIreland,\n        India,\n        [DisplayText(\"Middle East\")]\n        MiddleEast,\n        [DisplayText(\"Other UK &amp; Ireland\")]\n        Other_UKAndIreland,\n        ...\n    }\n</code></pre>"},{"location":"BHoM_oM/Base_oM/Attributes/#input","title":"Input","text":"<p>Used on methods to describe the input parameters. Consists of two strings, name and description. The name need to correspond to the name of the parameter used in the method and the description is used the explain the methods purpose. Multiple input tags can be used for the same method. Examples:</p> <pre><code>        [Input(\"obj\", \"Object to be converted\")]\n        public static string ToJson(this object obj)\n        {\n            //....code\n        }\n</code></pre> <pre><code>        [Input(\"externalBoundary\", \"The outer boundary curve of the surface. Needs to be closed and planar\")]\n        [Input(\"internalBoundaries\", \"Optional internal boundary curves descibing any openings inside the external. All internal edges need to be closed and co-planar with the external edge\")]\n        public static PlanarSurface PlanarSurface(ICurve externalBoundary, List&lt;ICurve&gt; internalBoundaries = null)\n        {\n            //....code\n        }\n</code></pre>"},{"location":"BHoM_oM/Base_oM/Attributes/#output","title":"Output","text":"<p>Used on methods to describe the resulting return object. Consists of two strings, name and description. The name will be used by the UIs to name the result of the method and the description will help explain the returned object. You can only add one output to each method. Example:</p> <pre><code>        [Output(\"List\", \"Filtered list containing only objects assignable from the provided type\")]\n        public static List&lt;object&gt; FilterByType(this IEnumerable&lt;object&gt; list, Type type)\n        {\n            //....code\n        }\n</code></pre>"},{"location":"BHoM_oM/Base_oM/Attributes/#notimplemented","title":"NotImplemented","text":"<p>Used on methods that are not yet implemented. Method with this tag will not be exposed in the UIs. Example:</p> <pre><code>        [NotImplemented]\n        public static double Length(this NurbsCurve curve)\n        {\n            throw new NotImplementedException();\n        }\n</code></pre>"},{"location":"BHoM_oM/Base_oM/Attributes/#previousversion","title":"PreviousVersion","text":"<p>The previous version attribute helps with code versioning of methods when a method has been changed in terms of name, namespace or input parameters. Example of how to use it see Method versioning</p>"},{"location":"BHoM_oM/Base_oM/Attributes/#replaced","title":"Replaced","text":"<p>Used on a method that is being replaced by another method and is to be deleted in coming versions while no automatic versioning is possible. This attribute should only be used when Versioning is impossible! This attribute will hide the method from the method tree in the UIs as long as the <code>FromVersion</code> property is lower or equal to the assembly file version and thereby make it impossible to create any new instances of the method. Any existing scripts will still work and reference the method. To read more about method deprecation strategy please see here.</p> <p>The deprecated attribute has four properties:</p> <ul> <li><code>string</code> Description - Description as to why the method is being replaced.</li> <li><code>Version</code> FromVersion - Which version was this method replaced. Here you generally only have to specify the first two digits, for example <code>2.3</code>.</li> <li><code>Type</code> ReplaceingType - Where can you find any replacing method (if it exists)</li> <li><code>string</code> ReplacingMethod - What is the name of the replacing method (if it exists)</li> </ul> <p>Example:</p> <pre><code>        [Replaced(new Version(2,3), \"Replaced with CurveIntersections.\", null, \"CurveIntersections\")]\n        public static List&lt;Point&gt; CurvePlanarIntersections(this Arc curve1, Circle curve2, double tolerance = Tolerance.Distance)\n        {\n            //....code\n        }\n</code></pre>"},{"location":"BHoM_oM/Base_oM/Attributes/#toberemoved","title":"ToBeRemoved","text":"<p>Attribute only to tag a class or method that is to be removed. This attribute should only be used when Versioning is impossible! This attribute will hide the method from the method tree in the UIs as long as the <code>FromVersion</code> property is lower or equal to the assembly file version and thereby make it impossible to create any new instances of the method.</p>"},{"location":"BHoM_oM/Base_oM/Interfaces/IImmutable/","title":"IImmutable","text":"<p>The IImmutable interface makes an object unmodifiable after it was instantiated. In order to modify an IImmutable object, a new object with the desired properties needs to be instantiated, where all the properties that are required to stay the same should be copied from the old object. </p> <p>IImmutable should be implemented:</p> <p>a) if objects instantiated from a class should not be modifiable, by design, in some or all of its properties; b) if objects contain properties that are non-orthogonal.</p> <p>Whilst reason (a) is self-explanatory, (b) is due to a specific problem that non-orthogonal properties expose.</p> <p>As a reminder, a class with ortogonal properties is a class whose properties all contain information that cannot be derived from other properties. Orthogonality is a software design principle for writing components in a way that changing one component doesn\u2019t affect other components. For example, an orthogonal \"Column\" class may define a Start Point and an End Point as separate properties, but then it cannot define a third property called \u201cLine\u201d which goes between a start point and an end point, as it would be redundant: modifying the start or end point would require to modify the Line property too. For this reason, class with non-orthogonal properties should implement the <code>IImmutable</code> interface, because the consistency of its properties can be guaranteed only when the class is instantiated.</p>"},{"location":"BHoM_oM/Base_oM/Interfaces/IImmutable/#how-to-implement-it","title":"How to implement it","text":"<p>To implement the <code>IImmutable</code> interface, you need to make two actions:</p> <ol> <li>Inherit from it: i.e. <code>public class YourObject : IImmutable</code></li> <li>The properties you want to be immutable must be <code>public</code>, <code>get</code> only, and contain a default value. i.e. <code>public string Title { get; } = \"\"</code></li> <li>All the properties that are not immutable, can follow the usual BHoM conventions, <code>public</code>, <code>get</code> and <code>set</code>, and have a default value</li> <li>It must implement only one constructor, whose parameters are types of all the immutable properties of the object.</li> </ol> <p>For an example, you can check the <code>BH.oM.Structure.SectionProperties.SteelSection</code> from the <code>Structure_oM</code>: Steel Section example</p>"},{"location":"BHoM_oM/Dimensional_oM/IElement-required-extension-methods/","title":"Extension methods required for the IElement interface","text":"<p>The following points outlines the use of the dimensional interfaces as well as extension methods required to be implemented by them for them to function correctly in the Spatial_Engine methods.</p> <p>Please note that for classes that implement any of the following analytical interfaces, an default implementation already exists in the Analytical_Engine and for those classes an implementation is only needed if any extra action needs to be taken for that particular case. The analytical interfaces with default support are:</p> Analytical Interface Dimensional interface implemented <code>INode</code> <code>IElement0D</code> <code>ILink&lt;TNode&gt;</code> <code>IElement1D</code> <code>IEdge</code> <code>IElement1D</code> <code>IOpening&lt;TEdge&gt;</code> <code>IElement2D</code> <code>IPanel&lt;TEdge, TOpening&gt;</code> <code>IElement2D</code> <p>Please note that the default implementations do not cover the mass interface <code>IElementM</code>.</p> <ol> <li> <p>If the BHoM class implements an <code>IElement</code> interface corresponding with its geometrical representation:</p> Interface Implementing classes <code>IElement0D</code> Classes which can be represented by <code>Point</code> (e.g. nodes) <code>IElement1D</code> Classes which can be represented by <code>ICurve</code> (e.g. bars) <code>IElement2D</code> Classes which can be represented by a planar set of  closed <code>ICurves</code> (e.g. planar building panels) <code>IElementM</code> Classes which is containing matter in the form of a material and a volume </li> <li> <p>It needs to have the following methods implemented in it's oM-specific Engine:</p> Interface Required methods Optional methods When <code>IElement0D</code> <ul><li><code>Geometry()</code></li> <li><code>SetGeometry(Point point)</code></li><li><code>HasMergeablePropertiesWith(IElement0D)</code></li></ul> <code>IElement1D</code> <ul><li><code>Geometry()</code></li> <li><code>SetGeometry(ICurve curve)</code></li><li><code>HasMergeablePropertiesWith(IElement1D)</code></li></ul> <ul><li><code>Elements0D()</code></li> <li><code>SetElements0D(</code><code>List&lt;IElement0D&gt; newElements0D)</code></li> <li><code>NewElement0D(Point point)</code></li></ul> <code>IElement1D</code> which endpoints are defined by <code>IElement0D</code> <code>IElement2D</code> <ul><li><code>OutlineElements1D()</code></li> <li><code>SetOutlineElements1D(</code><code>List&lt;IElement1D&gt; outlineElements1D)</code></li> <li><code>HasMergeablePropertiesWith(IElement2D)</code></li> </ul> <ul><li><code>InternalElements2D()</code></li> <li><code>NewInternalElement2D()</code></li> <li><code>SetInternalElements2D(</code><code>List&lt;IElement2D&gt; internalElements2D)</code></li></ul> If the <code>IElement2D</code> has internal elements <code>IElementM</code> <ul><li><code>MaterialComposition()</code></li> <li><code>SolidVolume()</code></li></ul> or  <ul><li><code>VolumetricMaterialTakeoff()</code></li></ul> </li> <li> <p><code>Spatial_Engine</code> contains a default <code>Transform</code> method for all <code>IElementXD</code>s. This implementation only covers the transformation of the base geometry, and does not handle any additional parameters, such as local orientations of the element. For an object that contains this additional layer of information, a object specific <code>Transform</code> method must be implemented. </p> </li> </ol> <p>This is checked by this CI check so any changes to the requirements should be reflected in the check appropriately.</p>"},{"location":"BHoM_oM/Geometry_oM/","title":"Introduction to BHoM Geometry","text":"<p>Geometry_oM is the core library, on which all engineering BHoM objects are based. It provides a common foundation that allows to store and represent spatial information about any type of object in any scale: building elements, their properties and others, both physical and abstract.</p> <p>All objects can be found here in the Geometry_oM</p> <p>The code is divided into a few thematic domains, each stored in a separate folder:</p> <ul> <li>Coordinate System</li> <li>Curve</li> <li>Interface</li> <li>Math</li> <li>Mesh</li> <li>Misc</li> <li>SettingOut</li> <li>ShapeProfiles</li> <li>Solid</li> <li>Surface</li> <li>Vector</li> </ul> <p>All classes belong to one namespace (<code>BH.oM.Geometry</code>) with one exception of Coordinate Systems, which live under <code>BH.oM.Geometry.CoordinateSystem</code>.  All methods referring to the geometry belong to <code>BH.Engine.Geometry</code> namespace.</p>"},{"location":"BHoM_oM/Geometry_oM/#interfaces","title":"Interfaces","text":"<p>Two separate families of interfaces coexist in Geometry_oM. First of them organizes the classes within the namespace:</p> Interface Implementing classes <code>IGeometry</code> All classes within the namespace <code>ICurve</code> Curve classes <code>ISurface</code> Surface classes <p>The other extends the applicability of the geometry-related methods to all objects, which spatial characteristics are represented by a certain geometry type:</p> Interface Implementing classes <code>IElement0D</code> All classes represented by <code>Point</code> <code>IElement1D</code> All classes represented by <code>ICurve</code> <code>IElement2D</code> All classes represented by a planar set of closed <code>ICurves</code> (e.g. building panels) <code>IElement3D</code> All classes represented by a closed volume (e.g. room spaces) - not implemented yet"},{"location":"BHoM_oM/Geometry_oM/#tolerances","title":"Tolerances","text":"<p>There is a range of constants representing default tolerances depending on the tolerance type and scale of the model:</p> Scale Value Micro 1e-9 Meso 1e-6 Macro 1e-3 Angle 1e-6"},{"location":"BHoM_oM/Geometry_oM/#conversion-to-proprietary-software-packages","title":"Conversion to proprietary software packages","text":"<p>While being pulled/pushed through the Adapters, the BHoM geometry is converted to relevant geometry format used by each software package.</p> <p>BHoM Rhinoceros conversion table</p>"},{"location":"BHoM_oM/Geometry_oM/#known-issues","title":"Known issues","text":"<p>At the current stage, Geometry_oM bears a few limitations: - Nurbs are not supported (although there is a framework for them in place) - 3-dimensional objects (curved surfaces, volumes etc.) are not supported with a few exceptions - Boolean operations on regions contain a few bugs</p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/","title":"Structural and geometrical conventions","text":"<p>This page covers Structural and Geometrical conventions for the BHoM framework.</p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#1d-elements","title":"1D-elements","text":""},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#coordinate-system","title":"Coordinate system","text":"<p>The following local coordinate system is adopted for 1D-elements e.g. beams, columns etc:</p> <p></p> <ul> <li>x-axis along the centre line of the element from start to end</li> <li>z-axis as the normal direction of the element  </li> <li>y-axis transverse to the normal  </li> </ul> <p>Linear elements</p> <p>For non-vertical members the local z is aligned with the global z and rotated with the orientation angle around the local x.</p> <p>For vertical members the local y is aligned with the global y and rotated with the orientation angle around the local x.</p> <p>A bar is vertical if its projected length to the horizontal plane is less than 0.0001, i.e. a tolerance of 0.1mm on verticality.</p> <p>Curved planar elements</p> <p>For curved elements the local z is aligned with the normal of the plane that the curve fits in and rotated around the curve axis with the orientation angle.</p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#section-property-nomenclature","title":"Section property nomenclature","text":"<p>Area - Area of the section property I<sub>y</sub> - Second moment of area, major axis I<sub>z</sub> - Second moment of area, minor axis W<sub>el,y</sub> - Elastic bending capacity, major axis W<sub>el,z</sub> - Elastic bending capacity, minor axis W<sub>pl,y</sub> - Plastic bending capacity, major axis W<sub>pl,z</sub> - Plastic bending capacity, minor axis R<sub>g,y</sub> - Radius of gyration, major axis R<sub>g,z</sub> - Radius of gyration, minor axis  </p> <p>V<sub>z</sub> - Distance centre to top fibre V<sub>p,z</sub> - Distance centre to bottom fibre V<sub>y</sub> - Distance centre to rightmost fibre V<sub>p,y</sub> - Distance centre to leftmost fibre A<sub>s,z</sub> - Shear area, major axis A<sub>s,y</sub> - Shear area, minor axis  </p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#signs-of-section-forces","title":"Signs of section forces","text":"<p>The directions for the section forces in a cut of a beam can be seen in the image below:</p> <p></p> <p>This is: * Normal force positive along the local x-axis * Shear forces positive along the local y and z-axes * Bending moments positive around the local axis by using the right hand rule</p> <p>This leads to the following:</p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#axial-force-fx","title":"Axial force F<sub>x</sub>","text":"<p>Positive (+) =  Tension Negative (-) =  Compression  </p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#major-axis-bending-moment-my-and-shear-force-fz","title":"Major axis bending moment M<sub>y</sub> and shear force F<sub>z</sub>","text":"<p>As shown in the following diagram.</p> <p> </p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#minor-axis-bending-moment-mz-and-shear-force-fy","title":"Minor axis bending moment M<sub>z</sub> and shear force F<sub>y</sub>","text":"<p>Same sign convention as for major axis.  </p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#torsional-moment-mx","title":"Torsional moment M<sub>x</sub>","text":"<p>The torsional moment follows the Right-hand rule convention.</p> <p> </p>"},{"location":"BHoM_oM/Structure_oM/BHoM-Structural-Conventions/#bar-offsets","title":"Bar offsets","text":"<p>Bar offsets specify a local vector from the bars node to where the bar is calculated from, with a rigid link between the Node object and the analysis bars end point.</p> <p>Hence:</p> <ul> <li>a BHoM bars nodes are where it attaches to other nodes,</li> <li>offsets are specified in the local coordinate system and is a translation from the node,</li> <li>local x = bar.Tangent();</li> <li>local z = bar.Normal();</li> <li>node + offset is where the bar node is analytically</li> <li>the space between is a rigid link</li> </ul>"},{"location":"BHoM_oM/Structure_oM/Shear-Area-Derivation/","title":"Shear Area Derivation","text":""},{"location":"BHoM_oM/Structure_oM/Shear-Area-Derivation/#shear-area-derivation","title":"Shear Area Derivation","text":"<p>It is here outlined how BHoM calculates shear area for a section Shear Area formula used for calculation:  And A(x) is defined as all the points less than x within the region A. </p> <p>Moment of inertia is know and hence the denominator will be the focus. </p> <p>Sy for an area can be calculated for a region by its bounding curves with Greens Therom:  which for line segments is: </p> <p>And while calculating this for the entire region as line segments is easy, we want to have the regions size as a variable of x. So we make some assumptions about the region we are evaluating. * Its upper edge is always on the X-axis * No overhangs  </p> <p>i.e. its thickness at any x is defined by its lower edge,  achieved by using <code>WetBlanketIntegration()</code>  Example: </p> <p>We will then calculate the solution for each line segment from left to right.  This is important as Sy is dependent on everything to the left of it.</p> <p>We then split the solution for Sy into three parts: * S<sub>0</sub>, The partial solution for every previous line, i.e. sum until current * The current line segment with variable t * A closing line segment with variable t, connects the end of the current line segment to the X-axis  </p> <p>Closing along the X-axis is not needed as the horizontal solution is always zero. Visual representation of the area it works on: </p> <p>We will now want to define all variables in relation to t </p> <p>And then plug everything into the integral </p>"},{"location":"BHoM_oM/Structure_oM/Shear-Area-Derivation/#to-summarise-the-practical-proccess","title":"To summarise the practical proccess","text":"<ol> <li>The region will be converted to the right format by <code>WetBlanketInterpetation()</code> </li> <li>The integral is evaluated for the first line segment and added to the results sum</li> <li>The S<sub>0</sub> value for the first line segment is calculated and added to the S_0 sum</li> <li>step 2 and 3 repeats for every line except the last</li> <li>The squared Moment of inertia is then divided by the result</li> </ol>"},{"location":"Basics/","title":"What is the BHoM for?","text":""},{"location":"Basics/#linking-meanings","title":"Linking Meanings","text":"<p>The variety of AEC (Architecture, Engineering and Construction) commercial software does not always provide solutions to all needs, especially when it comes to collaborating with many people. We frequently encounter particular problems that require some special functionality not offered by any specific software, and we feel the need to implement it ourselves via, for example, custom scripts, or spreadsheets, or macros.</p> <p>BHoM proposes a central Object Model, which is a schema (in other words, a dictionary of terms) on which functionality can be built. By agreeing on common terminology, the output of a script created by one person can easily be used as the input for another script. </p> <p>So, at its core, the BHoM contains a collection of object definitions that we all agree on. The definitions are created by the same domain experts that use them everyday (e.g. Structural Engineers, Electrical Engineers, Architects...), and they are categorised per discipline (e.g. Structure, Architecture, ...). Each definition is simply a list of properties that an object should have (e.g. wall, beam, speaker, panel,...). We call this collection of definitions the object Models (oMs). </p> <p>By extension, the BHoM (Building and Habitats object Model) is the collection of these object Models and the functionality built on top of them.</p>"},{"location":"Basics/#linking-software","title":"Linking Software","text":"<p>Across the AEC industry, regardless of our discipline, we have to work with multiple softwares during the course of any given project. Since there is rarely a simple solution to transfer the data from one software to another, we usually end up either doing it manually each time or writing some bespoke script to automate the transfer. Things get even more complex when we work across disciplines and with other collaborators. When the number of software to deal with becomes more than just a few, this one-to-one translation solution quickly becomes intractable.</p> <p>This is where the BHoM comes in. Thanks to the central common language, it is possible to interoperate between many different programs. Instead of creating translators between every possible pair of applications, you just have to write one single translator between BHoM and a target software, to then connect to all the others.</p> <p>We call those translators Adapters.</p> <p></p>"},{"location":"Basics/#linking-functionality","title":"Linking functionality","text":"<p>Most often, AEC industry experts create ad-hoc functions and tools when the need arises. Common examples are large, complex spreadsheets, VBA macros for Excel, but also small and large User Interface programs written in C#, Python or other tools.</p> <p>In such a large sector, most problems you encounter are likely to have been solved before by someone in your organisation, or outside. What frequently happens is that the wheel gets reinvented. Additionally, when a script is created, it often exists in isolation, and is used only by a small group of people. </p> <p>Let's take the example of a user wanting to create some functionality in an Excel macro. This has several issues:</p> <ul> <li> <p>Maintanability issues. Frequently, only the original creator of a Macro knows how to develop or maintain it. If they are not around and a problem arises, the Macro is often just thrown away.</p> </li> <li> <p>Shareability issues. For example, if the creator of a Macro that performs some function in a spreadsheet wants to share this functionality with one of their clients, they end up sharing the spreadsheet with the Macro in it, effectively sharing the source code (the fruit of their hard work), which could end up being copied.</p> </li> <li> <p>Scalability issues. Macros are hard to scale. If you need to add more features or more complex functionality in a Macro, the code soon becomes unmanageable.</p> </li> <li> <p>Collaboration issues. Collaborating on the code written in a Macro is a mess. Only one person can work on it at the same time. In order to merge the work of different people into a same Macro spreadsheet, either a library is created, or copy-paste is required.</p> </li> </ul> <p>BHoM proposes to create a common library of functionality in Engines, which are simply tidy collections of functions. Like Adapters, Engines can be stored in Toolkits, which are simply GitHub repositories. GitHub repositories make it easy to share and collaborate on code (or not share, if privacy is chosen). BHoM makes it very easy to expose any functionality written in an Engine to Excel, Grasshopper, or other interfaces.</p> <p>Thanks to the BHoM being exposed in various UIs such as Grasshopper and Excel, you don't even need to know how to write code to use the functionality created by other people. </p> <p></p>"},{"location":"Basics/#linking-people","title":"Linking people","text":"<p>By sharing terminology, functionality, and connectivity to software, BHoM allows us to shift the attention from \"connecting data\" to \"connecting people together\"!</p> <p>BHoM also embraces Open Source as a practice: there is infinite value in opening up development efforts to the larger AEC community. Sharing effort pays big time!</p>"},{"location":"Basics/BHoM-Toolkits/","title":"BHoM Toolkits","text":"<p>The source code of BHoM is hosted under the public GitHub organisation: https://github.com/BHoM</p> <p>The organisation hosts a number of repositories. Most of them have a name finishing with \"_Toolkit\". Foundational repositories are instead called <code>BHoM</code>, <code>BHoM_Engine</code>, <code>BHoM_Adapter</code>, <code>BHoM_UI</code>, among others. The Toolkits are the things that host the actual code, with specific terminologies (object Models, oMs), functionalities (Engines) and translators (Adapters).</p> <p></p> <p>Before we discuss in more detail the individual repositories and what they contain, let's take a step back and look at the different categories of code/functionality we can find inside them.</p>"},{"location":"Basics/BHoM-Toolkits/#the-four-categories-of-code","title":"The four categories of code","text":"<p>If you ever have created your own tool or script, you must have been exposed to the two dual aspects of computation: data and functionality. In Excel, data would be the value of your cells and functionality would be the formulas or VB scripts. In Grasshopper, the functionality is made by the components, and the data is stored within parameters.</p> <p>Data is generally representing specific concepts. For example, Grasshopper provides definitions for Points, Lines, etc., which are geometrical concepts. There are however a lot of objects that we manipulate regularly as engineers that are not defined out of the box in any of those programs. So our first category of code will focus on that: providing a list of properties that fully define each type of object we use. For example, we can all agree that a point would have three properties (X,Y, and Z) each representing to position of the point along one axis. This applies similarly to agree on the definitions of elements such as walls, spaces, speakers,...</p> <p>Manipulators are the bespoke scripts, algorithms, equations, ... that we had to write ourselves to provide calculations not readily available. As engineers we have all had some of those custom made solutions lying around on our computer. Here we simply provide a central place to collect and store them in an organised way so we can all benefit from it.</p> <p>The two categories above are called respectively oM (stands for object model) and Engine. They are all we need to extend our internal computational capability. That being said, we have no intention to reinvent the wheel by replacing external software like Revit, Robot, Tas, IES,... We are also keen to keep using the user interfaces that we already know like Excel, Grasshopper. We are therefore adding two more categories to our central code. Adapters to allow the exchange of data between our internal code and external softwares. UI plugins to typical programs like Grasshopper that expose all our code directly.</p> <p></p> <p>In summary, the four categories of code, you will find among those repositories are:</p> <ul> <li> <p>oM: Definitions of the data we manipulate (e.g. Beam, Wall, Speaker,\u2026)</p> </li> <li> <p>Engine: Our own custom tools, algorithms, data exploration &amp; manipulation.</p> </li> <li> <p>Adapter: Connections between the BHoM and engineering tools such as Revit, GSA, Tas, IES,... This is where BHoM objects are translated to and from the proprietary representation used in each of those tools.</p> </li> <li> <p>UI: Expose the BHoM functionality through user interfaces such as Grasshopper and Excel.</p> </li> </ul>"},{"location":"Basics/BHoM-Toolkits/#dependency-chain","title":"Dependency chain","text":""},{"location":"Basics/BHoM-Toolkits/#the-concept-of-a-toolkit","title":"The concept of a toolkit","text":"<p>The BHoM is designed to be extendable. We want anyone to be able to create a set of tools relevant to a specific task (e.g. linking to another external software, providing a set of discipline specific functionality, ...). This is where the repository come in. They are independent units of development with their own team of developers responsible for maintaining the code in the long run. We call them toolkits. </p> <p>Internally, they will all follow the same conventions about the four categories of code defined above. To get slightly more into details regarding how that code is structure, let's talk for a second about how those different parts of the code are related to each other. </p> <ul> <li> <p>oM: You could see this as our base specialised vocabulary. It doesn't depend on anything else but everything else will rely on the definitions it contains.</p> </li> <li> <p>Engine: Depends only on the oM. Since this is an internal engine, it doesn't have to be aware of any external software or UI.</p> </li> <li> <p>Adapters: The adapter will depend on the oM for the objects definitions and on the engine for the conversion methods</p> </li> <li> <p>UI: Depends on everything else since it will expose all the functionality above to the UI.</p> </li> </ul> <p>Here's what it looks like in a diagram. To be concise, we will refer to this diagram as the diamond in the future.</p> <p></p> <p>Be aware that most of the toolkits will not implement all four categories. Let's look at a few user cases:</p> <ul> <li> <p>Adapter_Toolkit: E.g. Revit_Toolkit, TAS_Toolkit, GSA_Toolkit,\u2026 In there, you will very likely only implement the Adapter category (for the link with the external software) and the Engine category (for the conversion).</p> </li> <li> <p>UI_Toolkit: E.g. Grasshopper_UI, Excel_UI,... In all likelihood, you will only have to worry about the UI category. You might create and Engine for calculations only relevant to that UI but, most of the time, you'll find it is not needed.</p> </li> <li> <p>ProjectType_Toolkit: CableNetDesign_Toolkit, SportVenueEvent_Toolkit,\u2026 Focus on providing addition functionality specific to a project type. Provides addition object definitions in the oM and algorithms in the Engine. Nothing on the adapter or UI side is needed.</p> </li> </ul> <p>You will find more details on the specific code structure and conventions to follow for each category in the Further reading section but this is probably enough detail for now.</p>"},{"location":"Basics/BHoM-Toolkits/#core-repositories","title":"Core repositories","text":"<p>So, what about the few repositories that don't end with _Toolkit then? Understandably, there is also a large collection of code that will be useful in multiple toolkits. All the code that fits that description will be stored in one of the Core repositories. You will find there is one repository for each category of code. </p> <p>\"But, but, why do you have an exploded diamond instead of a single repo for your core?? It would make things more consistent!\" That is a valid point but the code in the Core is much larger than any toolkit. Repositories are used to distribute responsibilities between teams of people and to facilitate semi-isolated development. By splitting each category into its own repository, we enable focused sprints with a smaller risk of people stepping on each other's toes.</p> <p>Note that, while toolkits will always depend on the core, the core should never depend on a toolkit. The toolkits are also fairly independent sets of code so there should be very few dependencies between them.</p> <p></p>"},{"location":"Basics/BHoM-Toolkits/#further-reading","title":"Further Reading","text":"<p>Now that you have a global view of the way the code and the repositories are organised, you might wonder how that translate into you actually writing code either on the core or on a toolkit. Here's where you can find more details on the way each category of code is structured and the conventions you need to follow:</p> <ul> <li>BH.oM: Organise your Design Data</li> <li>BH.Engine: Create New Algorithms</li> <li>BH.UI: Expose your Code to UIs</li> <li>BH.Adapter: Linking to Commercial Software</li> </ul>"},{"location":"Basics/Installing-BHoM/","title":"Installing BHoM","text":"<p>A BHoM installer is released quarterly and is subject to thorough testing.</p>"},{"location":"Basics/Installing-BHoM/#installation-steps","title":"Installation steps","text":"<ol> <li>Download the BHoM installer from bhom.xyz.</li> <li>Make sure all instances of Rhino, Excel and Revit are closed before running the BHoM installer.</li> <li>Run the BHoM installer. The installer does not require administrative privileges. If asked for permission, just click OK and proceed.</li> <li>Check if BHoM was correctly installed:</li> </ol> <p>Check if BHoM is correctly installed</p> GrasshopperExcel <p>Open Grasshopper and verify that the BHoM tab is present. </p> <p>Click in any empty spot, then press CTRL+Shift+B. This should open up the BHoM menu. Try typing something there, like \"Point\". You should see a list of components. </p> <p>Open Excel and verify if the BHoM tab is present: </p> <p>Click on any cell, then press CTRL+Shift+B. This should open up the BHoM menu. Try typing something there, like \"Point\". You should see a list of components. </p>"},{"location":"Basics/Installing-BHoM/#installation-troubleshooting-faq","title":"Installation troubleshooting / FAQ","text":""},{"location":"Basics/Installing-BHoM/#cant-install-error-writing-to-file-xxx-verify-you-have-access","title":"Can't install \u2013 Error writing to file XXX: Verify you have access","text":"<p>If you get an error such as:</p> <p></p> <p>This can happen on Windows multi-user machines where a previous user had installed an old version of BHoM, and the current user that is trying to install it for themself does not have admin rights.</p> <p>The solution is to delete the <code>C:\\ProgramData\\BHoM</code> folder. Unfortunately, if you don't have admin rights, the only way is to ask your Administrator to delete it.</p> <p>Once the folder has been deleted, any user (also without admin rights) will be able to install BHoM correctly.</p>"},{"location":"Basics/Installing-BHoM/#developers-and-contributors","title":"Developers and contributors \ud83e\udd16","text":"<p>Developers, general contributors, as well as those who need a special version of a toolkit, may need to compile the source code themselves. Please read Getting started for developers for more info.</p> <p>Alpha installer</p> <p>We have a CI/CD pipeline that produces Daily alpha versions of the installer.</p> <p>At the moment, we don't currently publish Alpha installers due to some techincal issues. Please get in touch with us, for example opening a GitHub discussion, if you'd like us to proritize them being published again. You can also ask a member of the team to share an alpha installer, if required for some particular development exercise.</p> <p>The Alpha installer includes the most up-to-date changes present on each repository <code>develop</code> branch (or, in absence of that, the <code>main</code> branch).  Testing before merging to <code>develop</code> (or <code>main</code>) is always conducted, so a good level of stability can always be expected, although integration tests are limited on this stage.  Certain features may be subject to modifications or corrections until they become permanet features after the beta release.</p>"},{"location":"Basics/Technical-philosophy-of-the-BHoM/","title":"Technical philosophy of the BHoM","text":"<p>The Buildings and Habitats object Model [BHoM] has been designed as a hybrid model for code architecture - integrating a number of concepts from across existing languages/platforms. </p> <p>The Buildings and Habitats object Model (BHoM) is designed to be compatible with both visual flow-based programming (e.g. Grasshopper, Excel) and with text based functional and imperative programming (e.g. coding in C#). </p> <p>This is to integrate well in the workflow of any professional in the AEC industry, regardless of their level of computational proficiency: BHoM is a platform for combining the efforts of the professional programmer with those of any enthusiastic scripter/computational designer/engineer/architect, all in the same ecosystem.</p>"},{"location":"Basics/Technical-philosophy-of-the-BHoM/#the-basic-architecture","title":"The basic architecture","text":"<p>The Buildings and Habitats object Model is organised as four distinct categories of code: object Model, Engine, Adapter and User Interface.</p> <p></p> <p>1. The object model [oM] is nothing more than structured data - a collection of schemas.</p> <p>The oM is defined as naturally type strong C# classes, but comprising of only simple public Get Set Properties, with all methods excluded from the class definition including even the requirement for default constructors.<sup>1</sup> Ultimately, they are very close to C type structures with the added benefit of inheritance and polymorphism that a C# class provides.</p> <p> </p> <p>2. The Engine is nothing more than data manipulators - a structured collection of components/methods.</p> <p>All functionality is provided to the base types through extension methods in the Engine and organised as static methods within public static partial classes. Immutability is enforced on inputs of each method to enable translation to flow based programming environment.</p> <p> </p> <p>3. A common protocol for adaptors enables a single interface irrespective of the external software dealing with.</p> <p>IO and CRUD concepts are combined to enable convenient Push-Pull visual programming UI with CRUD functions interfacing with the external application. Crucially, the abstract BHoM_Adapter enables centralized handling of complex data merging so that creators of new adapters can focus on what makes their adapter different, reusing what is common and has already been solved</p> <p> </p> <p>4. The UI exposes code directly. Same terminology. Complete transparency.</p> <p>By leveraging dynamic binding \u2013 mostly leveraging C#'s Reflection \u2013 all objects, engine methods, adapters are exposed in the same way on any User Interface. BHoM functionality looks the same whether you use it from a programming script, a Grasshopper script, an Excel spreadsheet, or any other interface that can expose C#. </p> <p> </p>"},{"location":"Basics/Technical-philosophy-of-the-BHoM/#the-approach-to-coding","title":"The approach to coding","text":"<p>The above code structure therefore enables flexibility, extensibility, transparency and readability.</p> <p></p> <p>A. Open, flexible data schemas </p> <p>The base object class provides a CustomData Dictionary allowing dynamic assignment of any data type to any object. To the extent that a CustomObject is defined as an Empty Object. Default definitions for common objects can be curated and collectively agreed upon, however all are inherently flexible and extendible.</p> <p> </p> <p>B. Ease of extensibility of functionality too</p> <p>By structuring the code almost exclusively as extension methods in the Engine this enables new functionality to be added to existing objects without the requirement for derived types or indeed modification or recompilation of the base object. This naturally opens the door wide to distributed development and customisation of new functionality on top of any existing base objects.</p> <p> </p> <p>and finally, as highlighted, the above architecture and code design principles place mass participation and co-creation as central.</p> <p></p> <p>C. Transparency in code</p> <p>The source code architecture, principles and terminologies are all open, exposed and reflected as a common language across the visual and text based environments as described. This is paramount for a seamless transition from a visual UI to code and vice versa with huge benefits to the developer in debugging and the designer in prototyping and well as a teaching aid to the lower level concepts behind the UI.</p> <p> </p> <p>D. Human readable data </p> <p>All objects natively serialisable based on JSON being compatible with MongoDB and standard data format for the web.</p> <p> </p>"},{"location":"Basics/Technical-philosophy-of-the-BHoM/#a-shift-from-data-encapsulation","title":"A shift from data encapsulation","text":"<p>Despite being one of the pillars of OOP, data encapsulation has been systematically eliminated in favor of a solution more transparent and more closely related to visual programming. This translates into a few interesting side-effects:</p> <p>A. Node &lt;--&gt; Code correspondence</p> <p>Since objects have no private members and functionality is represented as a collection of individual static methods, the conversion between code and visual programming nodes becomes a straight-forward exercise.</p> <p> </p> <p>B. Shallow hierarchies</p> <p>Most objects inherit directly from the BHoMObject class and polymorphism is expressed mainly through interfaces. This is made possible without duplication of code thanks to the lack of encapsulation and an engine  designed around extension methods.</p> <p> </p> <p>C. Orthogonal properties</p> <p>With all object properties public, it is paramount for those to be independent from each other. This also means the objects are crafted with the minimal required information needed to construct them. All derived properties are exposed as methods in the engine.</p> <p> </p>"},{"location":"Basics/Technical-philosophy-of-the-BHoM/#further-reading","title":"Further Reading","text":"<ul> <li>BH.oM: Organise your Design Data</li> <li>BH.Engine: Create New Algorithms</li> <li>BH.UI: Expose your Code to UIs</li> <li>BH.Adapter: Linking to Commercial Software </li> </ul> <p><sup>1</sup> By exception IImmutable objects are allowed where calculation of derived properties in the engine requires lazy computation.  <code>Section Profile</code> is a good example</p> <p>In addition some explicit casting and operator overrides etc. are also included in the BHoM definitions of some limited base objects. <code>Node</code> is a good example</p>"},{"location":"Basics/Using-the-BHoM/","title":"Using the BHoM","text":"<p>The BHoM has been built from the ground up with the aim of enabling participation in computational design across the broadest skill sets and areas of expertise.</p> <p>This means there are a number of different entry points to get started with using the BHoM depending on what you want to acheive and what your background is.</p>"},{"location":"Basics/Using-the-BHoM/#bhom-visual-programming-plugins","title":"BHoM Visual Programming Plugins","text":"<p>BHoM Visual Programming</p> <p>BHoM encourages thinking about design as simple modular workflows and data models:</p> <p><p>inputs, processes and   outputs</p></p> <p>BHoM is therefore a perfect fit for flow based visual programming! </p> <p>We have two community developed and supported plugins giving access to BHoM functionality in our favourite and most widely used computational design environments.</p>"},{"location":"Basics/Using-the-BHoM/#bhom-for-grasshopper-and-bhom-for-excel","title":"BHoM for Grasshopper and BHoM for Excel","text":"<p>One great place to start is therefore our introductory guide: Getting started with the BHoM in visual programming</p> <p>This is also a good entry point to explore many of the basic concepts of BHoM.</p>"},{"location":"Basics/Using-the-BHoM/#bhom-as-a-framework-to-build-your-own-tools","title":"BHoM as a Framework to build your own tools","text":"<p>The BHoM has been designed as an open framework, ready to be be built on top of, extended and customisied. Being open source all the code is fully explorable on GitHub. So if you are a coder see our guide to Getting started with coding in the BHoM for developers.</p> <p>We can't wait to see what you build! </p>"},{"location":"Basics/Using-the-BHoM/#bhom-as-an-open-source-project","title":"BHoM as an Open Source project","text":"<p>If you are already experimenting with the BHoM we would love to know about it. See our Getting started with contributing page.</p>"},{"location":"Contributing/","title":"Getting started for contributors","text":"<p>Great to see you here! \ud83d\ude0a  There are a number of ways to contribute and get involved in the the BHoM. </p>"},{"location":"Contributing/#ways-to-get-involved","title":"Ways to get involved","text":""},{"location":"Contributing/#contribute-to-this-documentation","title":"Contribute to this documentation!","text":"<p>Perhaps you are already using the BHoM and have some tips to share? Or think that the documentation is lacking detail in places? Have you got an example or tutorial you would like to share? Your contributions to help make this documentaion better is very welcome! \ud83c\udf93See editing the documentation.</p> <p>Also if you've published some samples or tutorials somewhere else online, let us know! We would love to hear about it! \ud83e\udd1f Feel free to share in our BHoM discussions</p>"},{"location":"Contributing/#contribute-code","title":"Contribute code","text":"<p>Want to hack? \ud83d\udcbb See the Getting started for developers guide. </p> <p>Want to fix an open issue? See resolving an issue and then do a branch and PR targeting it.</p> <p>If unsure, raise a BHoM discussion to start a conversation and see how you can contribute.</p>"},{"location":"Contributing/#contribute-with-new-ideas-or-flagging-issues","title":"Contribute with new ideas or flagging issues","text":"<p>Found a bug? \ud83d\udc1b Have an idea for a feature? \ud83e\udde0 Feel free to raise new issues if they don't exist already, but please do a search in advance. </p> <p>Read more about submiting an issue.</p>"},{"location":"Contributing/#start-or-join-discussions","title":"Start or join discussions","text":"<p>Join the discussion on existing issues and pull requests, or open a new question issue to ask about any aspect of the BHoM code or toolkits. Also do feel free to ask questions or join the conversation on BHoM discussions \ud83d\udce3</p>"},{"location":"Contributing/#suggest-a-new-toolkit","title":"Suggest a new Toolkit","text":"<p>Use an application that does not already have a BHoM Adapter?  Reach out on https://github.com/orgs/BHoM/discussions and let us and others know what you'd like to see. \ud83d\ude4b</p>"},{"location":"Contributing/#building-a-new-bhom-toolkit-yourself","title":"Building a new BHoM Toolkit yourself?","text":"<p>We'd love to hear from you as we may wish to help you maintain it. \ud83d\udea7</p> <p>See also the BHoM GitHub Contributing page for more ways to get in touch.</p> <p>Do also take a look at our code of conduct (we also have one for bots too if that is you? \ud83d\udea7 \ud83e\udd16)</p>"},{"location":"Contributing/Editing-the-documentation/","title":"Editing the documentation","text":"<p>This documentation is simply a set of Markdown documents, stored and organised in the Documentation repository. The markdown documents are then automatically mapped to a web page every time a Push to the main branch of the Documentation repository is done. See below for technical details on how this is achieved.</p> <p>Depending on your account permissions, you should be able to commit directly to <code>main</code>, or a Pull Request will be required to perform the changes.</p>"},{"location":"Contributing/Editing-the-documentation/#minor-modifications","title":"Minor modifications","text":"<p>For small modifications, you can click the pencil \u270f\ufe0f icon on the top-right of the page. This will bring you to the Github Markdown editor. </p> <p>Avoid this for non-minor changes. Limit this approach to e.g. correcting typos, rephrasing sentences for clarity, adding short sentences, fixing URLs.</p>"},{"location":"Contributing/Editing-the-documentation/#general-modifications","title":"General modifications","text":"<p>In order to edit the documentation, you need to:</p> <ol> <li>Clone the documentation repository on your machine</li> <li>Navigate to the <code>docs</code> folder, and edit a markdown file or add new markdown files.  </li> </ol>"},{"location":"Contributing/Editing-the-documentation/#the-enhanced-markdown","title":"The enhanced markdown","text":"<p>The documentation markdown can incorporate non-markdown content. You can embed:</p> <ul> <li> <p>HTML blocks with embedded functionality, e.g. (click on <code>details</code> to see!):  </p> </li> <li> <p>Latex/Mathjax, e.g. \\(f(x) = x^2\\) (enclose the formula between single <code>$</code> for inline and double <code>$$</code> for block).</p> </li> </ul> <p>Tip</p> <p>Many more features are available to spice up the look of the documentation and help you convey information. See the available customisations of Material for Mkdocs: setup and Markdocs extra elements.</p>"},{"location":"Contributing/Editing-the-documentation/#using-a-text-editor-to-edit-the-documentation","title":"Using a text editor to edit the documentation","text":"<p>We recommend using either Visual Studio Code or Markdown Monster to edit the documentation. </p> <p>With Visual Studio Code you can preview the markdown while editing.</p>"},{"location":"Contributing/Editing-the-documentation/#adding-pages","title":"Adding pages","text":"<p>If you want to add a page, just add an new markdown document. </p> <p>The first H1 header (<code>#</code>) of the page will be taken as the title of the corresponding webpage.</p> <p>Each header will be reflected in the navigation menu on the right hand side of the page.</p>"},{"location":"Contributing/Editing-the-documentation/#linking-to-other-documentation-pages","title":"Linking to other documentation pages","text":""},{"location":"Contributing/Editing-the-documentation/#recommended-way","title":"Recommended way","text":"<p>Links to other documentation pages should be relative URLs (starting with a <code>/</code>) where the first slash must be followed with the <code>documentation</code> folder. Some examples:</p> <p>This section is work in progress -- please refer to https://github.com/BHoM/documentation/issues/84</p> <p>Note</p> <p>This way of providing URL to pages is required because MkDocs reflects the markdown files starting from the root <code>documentation</code>.</p> <p>Tip</p> <p>If using Visual Studio Code, enable Error Reporting on Markdown files and Link Validation in settings. VS Code will then check the validity of local links and cross referencing across your Markdown files, flagging warnings where links are invalid. VS Code Link Validation</p>"},{"location":"Contributing/Editing-the-documentation/#alternative-not-recommended","title":"Alternative (not recommended)","text":"<p>If you are editing a specific nested page you can also use URLs relative to the current page. Some examples: - To link to the Getting started for developers page, relative to this current page (Editing-the-documentation), you can provide: <code>../Getting-started-for-developers</code>.</p>"},{"location":"Contributing/Editing-the-documentation/#folders","title":"Folders","text":"<p>Folders behave as groups for sub-pages and are reflected into the left menu of the website.</p> <p>A folder may contain one markdown file called <code>index.md</code>; if it exists, that file is taken to be the first page of the folder when viewed from the website.</p> <p>For information on how to sort the pages, see below.</p>"},{"location":"Contributing/Editing-the-documentation/#previewing-the-website-before-pushing-to-the-repository","title":"Previewing the website before pushing to the repository","text":"<p>You may want to preview how your markdown documents will appear in the automatically-generated website. In order to do this, you can use mkdocs from command line.</p> <p>You need to:</p> <ol> <li>Have Python and PIP installed on your machine. Install <code>mkdocs</code> by running  <pre><code>pip install mkdocs\n</code></pre></li> <li>You will also need to ensure you have the MkDocs extensions and plugins that we are utilising installed. These can also be installed using <code>pip</code> by running the following:  <pre><code>pip install mkdocs-material \npip install mkdocs-awesome-pages-plugin\npip install mkdocs-git-revision-date-localized-plugin\n</code></pre></li> <li>Navigate to your locally cloned <code>documentation</code> repository folder.</li> <li>In that location, invoke from command line: <code>python -m mkdocs serve</code></li> </ol> <p>Mkdocs should spin up a local server and you should be able to connect to <code>http://localhost:8000/</code> in your browser to display the documentation website. Any change to your local file will be hot-reloaded into the webpage.</p>"},{"location":"Contributing/Editing-the-documentation/#website-configurations","title":"Website configurations","text":"<p>As mentioned, the Markdown documents are transformed into a proper web page thanks to mkdocs every time a Push to the main branch of the documentation repository is done. </p> <p>The web page can be configured by configuring mkdocs and related dependencies.</p>"},{"location":"Contributing/Editing-the-documentation/#dependencies","title":"Dependencies","text":"<p>On top of mkdocs, we also use:</p> <ul> <li>an extender theme called Material for Mkdocs, which exposes more customisation and extra functionality.</li> <li>a plugin for customising the sorting of the pages: mkdocs awesome pages plugin</li> </ul>"},{"location":"Contributing/Editing-the-documentation/#customising-the-ordering-of-the-pages-in-the-menu","title":"Customising the ordering of the pages in the menu","text":"<p>You just need to add a <code>.pages</code> text file in the specific folder where you want to sort out your pages. For an example, see the <code>.pages</code> file in the <code>docs</code> folder.</p> <p>You can edit the <code>.page</code> file according to mkdocs awesome pages plugin.</p>"},{"location":"Contributing/Editing-the-documentation/#customising-the-appearance-of-the-documentation","title":"Customising the appearance of the documentation","text":"<p>See the available customisations of Material for Mkdocs: setup and extra elements.</p>"},{"location":"Contributing/Editing-the-documentation/#github-actions-configuration","title":"Github actions configuration","text":"<p>Every time a push to this repository is done, a GitHub action kicks in and calls:</p> <ul> <li>mkdocs functionality to transform markdown to HTML</li> <li>mkdocs-material functionality, which expands the markdown translation of mkdocs with more features</li> <li>mkdocs awesome pages plugin functionality, which gives extra configs on top of mkdocs.</li> </ul> <p>The actions are configured as described in https://squidfunk.github.io/mkdocs-material/publishing-your-site/.</p>"},{"location":"Contributing/Implementing-a-new-Toolkit/","title":"Implementing a new Toolkit","text":"<p>To assist with implementing a new Toolkit, we have a Toolkit Template that prepares a Visual Studio solution with all the scaffolding done for you: create an new Toolkit using the BHoM Toolkit Template.</p>"},{"location":"Contributing/Implementing-a-new-Toolkit/#structure-of-a-toolkit","title":"Structure of a Toolkit","text":"<p>In short, a Toolkit can contain one or more of the following projects:</p> <ul> <li>A BHoM_oM project, that contains the definitions specific to your Toolkit (the types, or the schema, needed for your purposes).</li> <li>A BHoM_Engine project, that contains the functionality specific to your Toolkit.</li> <li>A BHoM_Adapter project, that contains the connectivity required to interface with an external software.</li> </ul> <p>If you are an User you might want to check out Getting started with the BHoM in Visual Programming.</p> <p>If you are interested in programming, creating your own new Toolkit, or contributing to the code of an existing one, keep reading.</p>"},{"location":"Contributing/Implementing-a-new-Toolkit/#create-a-new-software-toolkit-using-the-bhom-toolkit-template","title":"Create a new software Toolkit using the BHoM Toolkit Template","text":""},{"location":"Contributing/Implementing-a-new-Toolkit/#create-a-new-toolkit-repository","title":"Create a new Toolkit repository","text":"<p>Use the template repository to create a new repository. See the readme there.</p>"},{"location":"Contributing/Implementing-a-new-Toolkit/#implement-the-om","title":"Implement the oM","text":"<p>The oM should contain property-only classes that make the schema for your Toolkit. All functionality should be placed in the Engine. Functionality that is specific to a class should be defined in the Engine as an extension method. </p> <p>See The Object Model and The Engine for more information.</p>"},{"location":"Contributing/Implementing-a-new-Toolkit/#implement-the-engine","title":"Implement the Engine","text":"<p>The Engine should contain the functions applicable to the objects you've defined in the oM.</p> <p>See The Engine for more information.</p>"},{"location":"Contributing/Implementing-a-new-Toolkit/#implement-the-adapter","title":"Implement the Adapter","text":"<p>See the dedicated page to Implementing an Adapter.</p>"},{"location":"Contributing/Pull-Requests/","title":"Pull Requests","text":""},{"location":"Contributing/Pull-Requests/#introduction","title":"Introduction","text":"<p>Pull Requests are the primary mechanism of resolving issues and deploying new code to users. They provide us an opportunity to review and reflect on the proposed changes and ensure they meet the criteria of the issue and the broader agenda without introducing any major concerns with bugs or broken functionality.</p> <p>Pull Requests should be seen as a collaborative process during the review stage. Raising a pull request is not a guarantee that proposed changes will be deployed to the <code>main</code> branch, but changes can only be deployed via a pull request mechanism.</p>"},{"location":"Contributing/Pull-Requests/#raising-a-pull-request","title":"Raising a Pull Request","text":"<p>A pull request can be raised at any stage of the development cycle, either as draft, <code>WIP</code> (Work In Progress) or as ready for review depending on the state of the proposed changes. A pull request can be reviewed at any time by anybody, but it is good practice to request a review from key individuals working in that area (for example, a DevOps reviewer when making changes to the core, or a geometry reviewer if making changes to the Geometry oM/Engine).</p> <p>A raised pull request should have the following features within it - these are provided as headings in the pull request template to complete when raising the pull request:</p> <ul> <li>Clear identification of any dependant pull requests that this work is relying on to operate - for example, if your work in a toolkit depends on a change in BHoM_Engine, then in the toolkit pull request there should be a clear link to the BHoM_Engine at the top of your toolkit pull request</li> <li>Linked issues that are being resolved by this pull request - where there are multiple pull requests in a series, at least one of them needs to be referencing an issue that clearly outlines what needs to change in the code. The pull request should aim to solve just the issue outlined. One pull request can resolve several issues at once if needed</li> <li>Test scripts - either reference to data-driven unit-tests (which BHoMBot will then run) or links to test scripts built in a BHoM suitable UI, or reference to the issue which may contain test scripts when the issue was raised.</li> <li>Change log - see our change log guidance</li> <li>Additional comments - anything extra you feel will help the reviewers in reviewing your pull request</li> </ul>"},{"location":"Contributing/Pull-Requests/#categorising-a-pull-request","title":"Categorising a Pull Request","text":"<p>All pull requests should set a label defining the <code>type</code> of pull request, this is to categorise pull requests when producing the change log.</p>"},{"location":"Contributing/Pull-Requests/#pull-request-activity","title":"Pull Request activity","text":"<p>A pull request is a mark of coding resource that was used to try to solve a given issue (or issues). As such, it should be viewed that a pull request is aiming to deploy that code to the <code>main</code> branch (pending review) unless it is a speculative piece of work looking at possible options for a given idea. However, due to the pace of change within the BHoM ecosystem, a pull request can be difficult to deploy if it is left for too long. By rule of thumb, a pull request should aim to be deployed within one sprint of time (raised, reviewed, amended per review, and deployed), to avoid hanging work that isn't deployable.</p> <p>To keep our review requirements focused on the latest workload, each milestone will have a Pull Request closure day if deemed necessary by DevOps.</p>"},{"location":"Contributing/Pull-Requests/#stale-pull-requests","title":"Stale Pull requests","text":"<p>Pull requests which have not had any activity in 3 months are deemed to have gone stale. </p> <p>Pull requests which have not had any activity in 6 months will be closed to avoid drawing review resource if no activity has happened. Activity can be defined as committing code to the pull request, commenting on the pull request (even if just with an update stating the work is still desired but there's a lack of resource to close it out currently) or any activity which shows up on the pull request within the time period examined.</p>"},{"location":"Contributing/Resolving-an-Issue/","title":"Resolving an Issue","text":""},{"location":"Contributing/Resolving-an-Issue/#introduction","title":"Introduction","text":"<p>Open issues are reviewed weekly and the most critical ones are assigned to specific people as part of their weekly tasks. That task of resolving an issue is called a sprint. If you need more information on how those issues are being created, check this page.</p> <p>A person in charge of that issue will then create a new branch, write the code necessary to solve that issue (with potentially multiple commits on that branch) and then submit a pull request to merge that branch back to the main development branch. This pull request will be reviewed by other developers and the code on that branch will potentially be edited to match everyone's satisfaction. The pull request will then be approved and the branch will be merged with the main one. For more detailed explanations on the process, check this short guide</p> <p>If you haven't already make sure you read Using the SCRUM Board - it's easy!</p>"},{"location":"Contributing/Resolving-an-Issue/#overview-of-important-steps-to-successful-coding-in-the-bhom","title":"Overview of important steps to successful coding in the BHoM","text":""},{"location":"Contributing/Resolving-an-Issue/#a-preparatory-work","title":"A. Preparatory work","text":"<p>Preparatory work is mandatory. Before doing anything review the activity in relevant repos and speak to team    working in similar areas of the code. You can not start working on any part    of the code before you have checked that there are no Pull Requests open for the Project or for the       entire repo you want to modify. See naming       convention</p> <p>If the above steps are not fulfilled, coordinate with the person    working on that branch. Either work on the same branch if possible,    expanding the pull request to cover more issues (make sure you link all    issues in the conversation of the pull request), or work    locally    on your machine until the other branch is merged.    1. If you choose to work on the same pull request, make sure any       conversation being done is done publicly on Github to ease to process of       the reviewers.    2. If Urgent and you cannot coordinate       work locally, but do not branch yet</p>"},{"location":"Contributing/Resolving-an-Issue/#b-solving-the-issue","title":"B. Solving the issue","text":"<ol> <li> <p>Select an Issue or raise one.</p> </li> <li> <p>Create a Branch for the specific Issue - using the correct naming    convention    and considering to branch or not to    branch?</p> </li> <li> <p>As soon as you pushed your first commit, open a Draft Pull Request, and add the card to the Project SCRUM Board. This action will communicate to others that the repo is now locked and avoids conflicts. </p> </li> <li> <p>Push each individual Commit - keeping commits as specific and frequent    as possible. Always review what files you are committing. And make sure your    sprint is not drifting from the original issue.</p> </li> <li> <p>When your code is ready to be reviewed, change the stage of the pull request by marking the pull request as <code>ready for review</code>. Also remember to:</p> </li> <li>use the fixes       keyword       to reference your issue</li> <li>assign your reviewers, </li> <li>include links to any test files that have been used to assist with       swift review process,</li> <li> <p>it is also useful to add any comments and context that can be helpful in       the review process</p> </li> <li> <p>Work with your reviewer to close out</p> </li> <li> <p>On successful Merge and Rebase high five the person next to you! :tada: </p> </li> </ol>"},{"location":"Contributing/Resolving-an-Issue/#branch-naming-conventions","title":"Branch naming conventions","text":"<p>See the DevOps branching strategy.</p>"},{"location":"Contributing/Resolving-an-Issue/#breaking-changes","title":"Breaking changes","text":"<p>See our versioning strategy for more information on avoiding breaking changes.</p>"},{"location":"Contributing/Submitting-an-Issue/","title":"Submitting an Issue","text":""},{"location":"Contributing/Submitting-an-Issue/#introduction","title":"Introduction","text":"<p>Issues are used to keep track of all the requests for bug fixing, new features,... They can be created inside each repository and optionally assigned to a specific person. </p> <p>A good short guide on issues is available here</p>"},{"location":"Contributing/Submitting-an-Issue/#create-a-new-issue","title":"Create a New Issue","text":"<ul> <li> <p>On github, go the the repository that needs modifications and select the Issues tab. </p> </li> <li> <p>Click on the green New Issue button on the top right corner.</p> </li> </ul> <p></p> <ul> <li> <p>Fill in the title. The name should be Description or ProjectName - Description depending on whether the issue needs changes in the entire repo or in a specific Visual studio project. If you don't know which one it is, just use the repository name. </p> </li> <li> <p>and fill in the description. This is using markdown so you can format your message like you would a wiki page. You can also attached files simply by dropping them in the message area.</p> </li> <li> <p>Please be specific as you can with both the title description and the body text to give others as much information and context around your proposed issue.</p> </li> <li> <p>If you are not already a BHoM Collaborator or part of the Organisation, then you are good to go. Press Submit New Issue. A collaborator already with write access will pick up the issue and Label/Assign.</p> </li> </ul>"},{"location":"Contributing/Submitting-an-Issue/#collaborator-issue-flagging-and-assignment","title":"Collaborator Issue flagging and assignment","text":"<ul> <li> <p>As a collaborator or maintainer with write access - it is important to assign labels, as well as assignees if at all possible, for issues as you create them - as well as new issues created by others outside of the organisation to assist with triaging </p> </li> <li> <p>If you already know who is going to handle that issue, you can assign it to that person by using Assignees on the right side of the screen. Otherwise, just leave it blank.</p> </li> <li> <p>Make sure you select a Label to specify the type of issue you have (more about this on the next section).</p> </li> <li> <p>If you request is linked to a very specific deadline, you can also pick a Milestone from the list.</p> </li> </ul> <p></p>"},{"location":"Contributing/Submitting-an-Issue/#choose-a-label","title":"Choose a Label","text":"<p>The two main categories of labels are feature and bug. Features are for requesting functionality that doesn't exist yet. If there is similar functionality already but not matching 100% what you need (e.g. missing inputs or outputs you would need), this is also a feature request. Bug is for when that functionality exists but provides an incorrect result or crashes.</p> <p>For both of those categories, we have 3 levels of importance:</p> <ul> <li>Critical: It is simply impossible to continue without either that feature or fixing that bug. No workaround exists using alternative methods or a quick self-made script. </li> <li>Regular: This is slowing down progress. There is a workaround but it is not exactly ideal. </li> <li>Minor: You noticed a missing feature or a bug but it doesn't stop/slow you in your current work.</li> </ul> <p> </p> <p>Outside of those two main groups, 4 more labels are provided:</p> <ul> <li>Compliance: This is for people working directly within the code. You found some code that doesn't follow th rules we have in place for how the code should be structured and would like this to be fixed.</li> <li>Question: When you don't have anything specific you need to be changed but would like some clarification on a specific point or would like to start a debate.</li> <li>Test_script: You have created some new functionality and would like it to have its own set of automatic testing scripts to make sure it is regularly checked. Notice that you have to raise the issue where the test scripts will be written, NOT where the code to be tested is.</li> <li>Documentation: You find the documentation about a specific part of the code lacking. As for the test_script label, you need to raise the issue in the repository where the documentation is going to be created.</li> </ul>"},{"location":"Contributing/Updating-the-API-documentation/","title":"Updating the API documentation","text":""},{"location":"Contributing/Updating-the-API-documentation/#general","title":"General","text":"<p>The BHoM API documentation is built using mkdocs, which is the same documentation library that is used to generate the general documentation. For more information about this, please see Editing the documentation.</p> <p>The BHoM API is built up automatically generated markdown pages, one per class. The md files are stored in the api repo under the docs/oM folder. The api website is automatically updated via github actions as soon as any changes to the files are pushed to the main branch on the repository.</p>"},{"location":"Contributing/Updating-the-API-documentation/#including-a-repository-to-be-documented","title":"Including a repository to be documented","text":"<p>The repositories and projects to be documented are controlled via the categorisation csv file as well as the Repos.</p> <p>To get a project included: - Ensure the repo it belongs to is in the Repos. If not, add it, and make sure to put it after all repos it depends on for building - Add it to the list of projects in the categorisation file. Make sure you use one of the pre-existing categorisations, and make sure that the last field is set to true. If your repo contains more than one oM and you just want one of them to be documented, then please add it to the list and set the \"To be documented\" flag to false.</p>"},{"location":"Contributing/Updating-the-API-documentation/#including-example-json","title":"Including example JSON","text":"<p>For some classes, in particular for classes that are to be shared, it can be useful to show an example of how a BHoM JSON looks. To enable this for a particular class, please do the following:</p> <ul> <li>Generate a JSON file with a single object for the type you want to display, and name the file with the name of the type. Should generally be an as simple example as possible, that still highlights the potential complexity of the type.</li> <li>Add the file to the Json examples page, under the folder corresponding to the name of the dll hosting the type.</li> <li>Raise a pull request to main with the changes.</li> </ul>"},{"location":"Contributing/Updating-the-API-documentation/#api-generation","title":"API generation","text":"<p>The api docs will be automatically updated by github actions using the APIGenerator project described in more detail below.</p> <p>The github action triggers every week on the night between Saturday and Sunday UTC, and creates a pull request if any changes are detected. For the changes to affect the live website, this PR needs to be merged. To view open PRs please see Pull Requests. Once the PR is merged, the website will be automatically updated.</p>"},{"location":"Contributing/Updating-the-API-documentation/#steps-to-update-the-docs-manually","title":"Steps to update the docs manually","text":"<p>If you want to update the api docs manually, please follow the steps below</p> <ol> <li>Clone the api repo</li> <li>Ensure you have all code built and up to date in your BHoM assemblies folder.<ul> <li>This could either be done by running an up to date installer or cloning and building all the code from source</li> <li>If this is done via the means of an installer, make sure any repos listed in the categorisation file is cloned and built manually</li> </ul> </li> <li>Clone all listed repos in the categorisation file into the 'Repositories' folder in the root folder of the api solution.<ul> <li>If the folder does not exist, create it</li> <li>The reason the repos need to be cloned into the repository is for the github actions to function as it requires everything to be contained in the currently running repository</li> </ul> </li> <li>Remove all subfolders in the 'docs/oM' folders, as well as their content. Be sure to not delete index.md file.<ul> <li>The reason for removing all files is to make sure that any class no longer present is also removed from the docs. This includes renaming a class or its namespace, as that technically will mean a new file is added and the old one hence needs to be removed.</li> </ul> </li> <li>Open and build the APIGenerator solution</li> <li>Run the resulting exe<ul> <li>Could be run by just hitting f5 in the solution in visual studio</li> <li>Inspect any messaging display for any issues</li> </ul> </li> <li>Inspect the changes to the files locally, recommended to inspect in github desktop</li> <li>Raise a pull request to main with the changes</li> </ol>"},{"location":"Contributing/Updating-the-API-documentation/#apigenerator","title":"APIGenerator","text":"<p>For the app to function, it should be run in a subfolder of the solution file. If you simply build it and run it from the build location, or just hit f5 from the solution this will be the case. The reason this is required is due to the fact that the app requires access to settings files as well as the example jsons, which are linked through via finding the repo root folder, and then accessed via those paths.</p>"},{"location":"Contributing/Updating-the-API-documentation/#overview","title":"Overview","text":"<p>The APIGenerator solution is a single project console app, generating a .exe app that when run generates all the markdown files. Given the prerequisite steps have been set up, it will generate a .md file per .cs file in the oMs. To do this, it makes use of data from multiple sources:   - Compiled oM dlls to extract:     - Name and namespace of the type     - Defining properties     - Class and interface hierarchy   - Compiled Engine dlls to extract:     - Derived properties (extension methods)   - Categorisation csv file to extract     - Categorisation of the oM into the main defined categories   - Cloned files to extract:     - File hierarchy to be matched for generated .md files   - BHoM JSON Schema to extract:     - JSON schema of the objects   - Json examples     - Only available for types where it has been explicitly added. See Including example JSON</p>"},{"location":"Contributing/Updating-the-API-documentation/#program-steps","title":"Program steps","text":""},{"location":"Contributing/Updating-the-API-documentation/#load-settings","title":"Load settings","text":"<p>Parses the oM_categorisation.csv file to check for oMs to be documented</p>"},{"location":"Contributing/Updating-the-API-documentation/#load-engine-assemblies","title":"Load Engine assemblies","text":"<p>Loads up all Engine dlls from the programdata folder that are in the BHoM organisation. To check the organisation, it checks the AssemblyDescriptionAttribute for the link, and makes sure it links over to a github repository in the BHoM organisation. If your Engine methods does not show up in there, please ensure your project file has been set up properly.</p>"},{"location":"Contributing/Updating-the-API-documentation/#extract-extention-methods","title":"Extract extention methods","text":"<p>This step extracts all extension methods that could be seen as Derived properties. The methods captured by this step are methods that fulfill the following conditions:</p> <ol> <li>Are Query methods</li> <li>fulfills one of the following:<ul> <li>Have a single input parameter</li> <li>Have more than one input parameter, but all but the first have default values (optional).</li> </ul> </li> </ol> <p>All methods that match this criteria will be added as derived properties to the class matching the first input parameter.</p>"},{"location":"Contributing/Updating-the-API-documentation/#load-om-assemblies","title":"Load oM assemblies","text":"<p>Loads up all Engine dlls from the programdata folder that are in the BHoM organisation and also listed in the Categorisation csv file. To check the organisation, it checks the AssemblyDescriptionAttribute for the link, and makes sure it links over to a github repository in the BHoM organisation. If your objects does not show up, please ensure it is listed in the csv file and please ensure your project file has been set up properly.</p>"},{"location":"Contributing/Updating-the-API-documentation/#map-types","title":"Map types:","text":"<p>Maps the inheritance hierarchy between the types. Stores information both about all base types (classes as well as interfaces) for the type, and also adds itself as a subtype to all of its base types.</p>"},{"location":"Contributing/Updating-the-API-documentation/#generate-markdown","title":"Generate markdown","text":"<p>Loops through all files and generates a .md file per type in all the oM assemblies loaded in the previous step, that fulfills the following conditions: 1. Is not abstract AND sealed (filters out autogenerated types) 1. Is assignable from IObject OR an enum </p>"},{"location":"Contributing/Updating-the-API-documentation/#program-structure","title":"Program structure","text":"<p>The program has been split into multiple files, trying to categorise by similar actions. A full description of all files will not be given here, but the code can be reviewed in place.</p> <p>The entry point for the overall run can be found in the Program.cs file. The entrypoint for the markdown generation for each type can be found in the TypeToMarkdown file.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/","title":"Branching Strategy","text":"<p>The primary branch which forms our codebases single source of truth is the <code>main</code> branch across all repositories. Depending on the category of the repository, there may be protections in place for the development of code and merging to <code>main</code> branches. As a repository progresses through its lifecycle from prototype to beta, the level of protections change as appropriate.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#creating-branches","title":"Creating branches","text":"<p>No code should be committed directly to the <code>main</code> branch of any repository, all code should be produced on an independent branch and deployed to <code>main</code> via a Pull Request.</p> <p>If you are using GitHub desktop, you should make sure you are on the correct default (<code>main</code> or <code>develop</code> depending on the repository state - see below) branch and refresh it to ensure you have the latest version on your machine.</p> <p>Then create a new branch by clicking on the Current branch button and select New branch.</p> <p>Make sure to check this page for the guidelines on when to create a branch and when not to.</p> <p></p> <p>You should see that your repository history has now switched to a new branch.</p> <p></p> <p>From there you are ready to work on your code. Any commit that you will do, will be on that new branch.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#branch-naming-convention","title":"Branch naming convention","text":"<p>For all branches where code development is to take place, the following naming convention should be adopted.</p> <p>RepositoryOrProjectName-#X-Description</p> <p>where X is the issue number you are solving. </p> <p>Both the Repository or Project name and the Issue number should refer to the base issue being solved.</p> <p>For example, if you are working in IES Toolkit, aiming to resolve issue 99 (which fixes window placement), the branch name should be <code>IES_Toolkit-#99-FixingWindows</code>.</p> <p>If you're working on a repository with multiple disciplines, such as BHoM_Engine, then you can name the branch after the specific engine you are working on. For example, if you are working in the Environment Engine, aiming to resolve issue 103 (which fixes window creation), the branch name should be <code>Environment_Engine-#103-FixWindowCreation</code>.</p> <p>This branch naming convention is particularly important when producing development installers - BHoMBot will use the name of the branch to calculate where to place installer artefacts which are generated to aid in testing the Pull Request. If the branch is not named in this convention, BHoMBot will be unable to calculate this and you will lose out on CI benefits.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#branches-in-dependant-repositories-must-be-named-identically","title":"Branches in dependant repositories - MUST be named identically","text":"<p>For instance if a change in the BHoM will lead to a change needed in some sub-repositories, all of those sub-repositories **MUST get the same branch name**. This is essential for our (CI) process to correctly check changes spanning across multiple repository Pull Requests.</p> <p>For example, if you are adding an object in BHoM, and adding a Query method for that method in BHoM_Engine, both repositories should share the same branch name, such as <code>Environment_oM-#103-AddLightObject</code> - this is to ensure when we run CI checks such as Installer and Versioning, the check can find both Pull Requests and run them together within the bot ecosystem.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#prototypes","title":"Prototypes","text":"<p>Prototype repositories use only a <code>main</code> branch for their code development. The <code>main</code> branch should be protected to the level that it requires a Pull Request to merge code, however, there is no requirement on Prototype Repositories for a Pull Request to receive a review. The Pull Request can be raised and merged instantly (depending on any required CI checks) without intervention from a reviewer. Reviews are still an option for Prototype repositories should people wish to discuss changes before a merge, but they are not a requirement.</p> <p>There is no automatic deployments of Prototype repositories - the only way for code to be utilised is for it to be built from source or the DLLs shared between users.</p> <p>When creating a new branch for the addition of code to a Prototype repository, branch from an up to date version of the <code>main</code> branch.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#alpha-state","title":"Alpha State","text":"<p>Repositories deployed in an Alpha state use only a <code>main</code> branch for their code development. The <code>main</code> branch should be protected to the level that it requires a Pull Request with at least 1 approving review prior to the code being merged.</p> <p>Once code is merged to the <code>main</code> branch, the code will be deployed via alpha installers and available for more general consumption via Installers. Therefore code which is deployed to <code>main</code> must meet certain CI criteria before being able to merge the Pull Request.</p> <p>When creating a new branch for the addition of code to an Alpha repository, branch from an up to date version of the <code>main</code> branch.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#beta-state","title":"Beta State","text":"<p>Repositories deployed in a Beta state use both a <code>main</code> branch and a <code>develop</code> branch for their code development. The <code>develop</code> branch is set as the default branch.</p> <p>The <code>main</code> branch continues to serve as the repository's single source of truth and is the branch which is deployed via beta installers at the end of each milestone.</p> <p>The <code>develop</code> branch serves as a staging ground for development of features and larger pieces of work which is deployed via alpha installers.</p> <p>The difference here for Beta repositories is that the <code>main</code> branch should only be updated each milestone with code from the <code>develop</code> branch which has been suitable tested and reviewed and deemed to be fit for purpose for general deployment in the Beta installers available on BHoM.xyz and other platforms. Utilising a different branch for general development (<code>develop</code>) from the Beta deployed branch (<code>main</code>) grants us a degree of control over what is deployed at the end of each milestone and beta.</p> <p>For repositories which are undergoing large portions of work, perhaps large refactors or additional features, targeting new APIs, etc., it may not be suitable to deploy that work to a Beta where the work spans across multiple milestones of development. If this work was deployed to <code>main</code> for Alpha testing, it would then be automatically deployed to Beta at the end of the milestone when it may not be ready. Deploying to <code>develop</code> for Alpha testing then allows us to choose not to deploy that to <code>main</code> at the end of the milestone, allowing the Beta to contain only the deployable code that is up to the adequate standards without hindering development, or requiring Pull Requests to stay open for a lengthy time and take more resource to resolve when the time is right.</p> <p>Additionally, separating the <code>main</code> Beta branch from the <code>develop</code> Alpha branch allows us to patch the Beta for critical bugs during a milestone of development, enabling the release of curated, up to standard code that resolves a specific bug without also deploying code which may be under ongoing development.</p> <p>All Pull Requests for Beta repositories should aim to merge into the <code>develop</code> branch unless authorised by DevOps to merge into the <code>main</code> branch to perform a Beta Patch.</p> <p>When creating a new branch for the addition of code to a Beta repository, you should branch from the branch where the code aims to end up. For example, if you are developing a new feature which will merge into the <code>develop</code> branch, then you must branch from an up to date version of the <code>develop</code> branch. However, if you are providing a bug fix for a Beta Patch, which aims to merge directly into the <code>main</code> branch, then you must branch from an up to date version of the <code>main</code> branch.</p>"},{"location":"Contributing/Best-practices/Branching-Strategy/#branch-protections","title":"Branch Protections","text":"<p>This table gives an overview of the protections required for each individual type of repository.</p> Protection Setting Prototype Alpha Beta (<code>develop</code>) Beta (<code>main</code>) Require a Pull Request before Merging Require Approvals Minimum Number of Approvals N/A 1 1 1 Dismiss stale pull request approvals when new commits are pushed Require review from Code Owners Restrict who can dismiss pull request reviews Allow specified actors to bypass required pull requests Require approval of the most recent push Require status checks to pass before merging Require branches to be up to date before merging Status Checks that are required See here See here See here See here Require conversation resolution before merging Require signed commits Require linear history Require deployments to succeed before merging Lock branch Do not allow bypassing the above settings Restrict who can push to matching branches Restrict pushes that create matching branches People, teams, or apps with push access N/A Merge Team Merge Team DevOps Team Allow force pushes Allow deletions"},{"location":"Contributing/Best-practices/Branching-Strategy/#branching-diagrams","title":"Branching diagrams","text":""},{"location":"Contributing/Best-practices/Branching-Strategy/#main-branch-only","title":"<code>main</code> branch only","text":""},{"location":"Contributing/Best-practices/Branching-Strategy/#main-branch-with-a-develop-branch","title":"<code>main</code> branch with a <code>develop</code> branch","text":""},{"location":"Contributing/Best-practices/Branching-Strategy/#stale-branches","title":"Stale branches","text":"<p>A stale branch is defined as a branch of code which has not had any commit activity in 6 months or longer from the date of the last commit or any discussion via a pull request (regardless of state) in those 6 months. Branches that are deemed to have gone stale may be subject to deletion during repository clean ups that occur during a milestone alongside pull request closures and other spring-cleaning tasks which help keep the code base clean from too much noise.</p> <p>If a branch is required for ongoing work, but does not have a pull request associated to it and has not had commit actiivty within 6 months, may be eligible to remain available if good reason can be provided for doing so. Good reason can be provided via an issue, or reaching out to the DevOps team directly.</p>"},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/","title":"Coding together avoiding conflicts","text":"<p>Since multiple people may be working on the codebase at the same time please remain aware of other branches on the same repository and keep an eye out for potential conflicts between them, this is especially true of open Pull Requests. If there are changes on parallel branches, and especially ones you know will cause conflicts, there is no substitute to reaching out to the author(s) of those changes and discussing the intent and goals behind yours and theirs and aligning the best way to resolve them. You may find that one of you may be making a change that will actually make the other's goals easier to achieve or even unnecessary and save some work. Someone pausing development may be the best resolution in some cases, in others continuing and dealing with the conflicts later may be, and in others there could be refactoring work that could be done now to save this effort being necessary.</p> <p>Be sure to regularly fetch and check that your branch integrates cleanly with master, if it does not please rectify these conflicts on your branch.</p> <p>Core Contributors are expected to resolve conflicts on their PRs in order to have their PR accepted and merged. Maintainers should expect to assist external contributors with this process or otherwise handle them at merge time. Also see GitHub's about merge conflicts page</p>"},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/#never-work-on-the-same-files","title":"Never Work on the Same Files","text":"<p>The challenge is therefore to make sure that we never have two people modifying the same files in two separate branches. While it is easy to be aware which code file you are modifying, it is very important to understand that there are a few files maintained by Visual Studio that can also be the source of clashes:</p> <ul> <li>Solution file: This file is modified every time a project is added for example. This means we can never have two people creating a new project in two different branches. If you know you will have to do that, you have to block the entire repository for the duration of your sprint. To block a repo, make sure your issue and card on the SCRUM board follow the naming convention of a repo-level issue. </li> <li>Project file: This file is modified every time you add a file to the project. This happens a lot since you create a file every time you create a new section of code. It will also be modified if you move a file. Because of this, two people are never allowed to work on the same project at the same time. To block the project, make sure your issue and card on the SCRUM board follow the naming convention of a project-level issue.</li> </ul>"},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/#faq","title":"FAQ","text":""},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/#i-have-to-make-changes-across-multiple-projects-at-the-same-time-what-do-i-do","title":"I have to make changes across multiple projects at the same time, what do I do?","text":"<p>If it is only two projects, you can simply name your issue and branch with the two project names instead of just one. If this is more than that, you will have to block the entire repository. In that situation, it is frequent that unplanned changes will have to be made in other projects anyway so it is safer to block the whole repository.</p>"},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/#i-am-not-sure-if-my-code-will-be-limited-to-a-single-project-there-might-be-ripple-effects-what-do-i-do","title":"I am not sure if my code will be limited to a single project. There might be ripple effects. What do I do?","text":"<p>In doubt, it is safer to block the whole repository. It is very annoying for everyone else though so only do it if it is clear the side effect of your changes cannot be dealt with in a separate issue/PR. Also make sure you keep your sprint as short as possible so you limit the time you are blocking everyone. One thing to consider is to work only locally until you know for sure the effect your code has so you can create the branch accordingly.</p>"},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/#my-issue-is-super-urgent-but-someone-else-is-already-blocking-the-projectrepository","title":"My issue is super urgent but someone else is already blocking the project/repository.","text":"<p>You can always work locally. Just don't create a branch yet and solve the problem on your machine. Contact the other person blocking you to coordinate. As soon as his/her PR is merged, you can pull the latest changes on your machine and create your pull request.</p>"},{"location":"Contributing/Best-practices/Coding-together-avoiding-conflicts/#i-am-creating-a-branch-that-will-never-be-merged-is-there-a-solution-for-that","title":"I am creating a branch that will never be merged. Is there a solution for that?","text":"<p>Yes, you can use this naming convention instead: NeverMerge-IssueX-Description. As you can see, we have replaced the project or repository name with NeverMerge. This is a very rare case though since 99.9% of the code should be meant to be merged.</p>"},{"location":"Contributing/Best-practices/Development-FAQ/","title":"Development FAQ","text":"<ul> <li>What does it mean when a piece of code is locked? How do I lock code?</li> <li>I am using Windows 10. Is anything different for me ?</li> </ul>"},{"location":"Contributing/Best-practices/Development-FAQ/#what-does-it-mean-when-a-piece-of-code-is-locked-how-do-i-lock-code","title":"What does it mean when a piece of code is locked? How do I lock code?","text":"<p>A piece of code is locked when it is being developed by someone else. You can check if some code is locked if its related issue is mentioned in the \u201cIn Progress\u201d or \u201cIn Review\u201d column of the BHoM Project Board.</p> <p>You shouldn't touch code that is locked, until the current task ends or is archived. If you urgently need that some new code to be pushed into the main stream - an important bug fix for example - reach out to the person assigned to the issue that is locking the code and speak to her/him.</p> <p>Read the wiki pages on naming conventions and avoiding clashes for more information.</p>"},{"location":"Contributing/Best-practices/Development-FAQ/#i-am-using-windows-10-is-anything-different-for-me","title":"I am using Windows 10. Is anything different for me?","text":"<p>If you are using a computer which runs on windows 10, you might find that when you reference dlls in a project, the path of those will be pointing to your OneDrive folder. This will obviously lead to the issue that the code will not compile for other people. </p> <p></p> <p>If this id the case, re-referencing the dlls might not solve the issue and then you will have to manually edit that in the project folder. You do this by opening the project file (.csproj) in a text-editor and you will find some of the dlls being referenced as </p> <p></p> <p>which you will have to replace by</p> <p></p> <p>Note that the path in visual studio will still be pointing to your OneDrive, but now the referencing will not create issues for others. Do NOT FORGET TO COMMIT this changes!</p>"},{"location":"Contributing/Best-practices/Icons/","title":"Icons","text":""},{"location":"Contributing/Best-practices/Icons/#general-guidelines","title":"General Guidelines","text":"<p>As a general rule, the icons are stored in the BHoM_UI repository. All other UIs will then use those directly so there is no need for each UI to create its own icons.</p>"},{"location":"Contributing/Best-practices/Icons/#specific-toolkit-icons","title":"Specific Toolkit Icons","text":"<p>TODO</p>"},{"location":"Contributing/Best-practices/Icons/#software-specific-guidelines","title":"Software Specific Guidelines","text":"<ul> <li>Grasshopper icons are 24x24px png files and follow David Ruttens Guidelines. A recommended workflow is to export a 24x24px png from Inkscape with a 20x20px vector inside it and then use Gimp to add a dropshadow. </li> </ul>"},{"location":"Contributing/Best-practices/Icons/#useful-software","title":"Useful Software","text":"<ul> <li> <p>Gimp, a free image editor.</p> </li> <li> <p>Inkscape, a free vector graphics editor.</p> </li> </ul>"},{"location":"Contributing/Best-practices/Merge-Teams/","title":"Merge Teams","text":"<p>Merge teams are set up to deploy code to protected branches (<code>main</code> or <code>develop</code> in most cases) following a successful Pull Request review process.</p> <p>Merge teams are managed by DevOps, and inclusion or exclusion from a team may occur at any time.</p> <p>Merge teams will be reviewed at regular intervals to ensure they are up to date and reflective of the current development needs.</p>"},{"location":"Contributing/Best-practices/Merge-Teams/#creating-a-merge-team","title":"Creating a merge team","text":"<p>Creation of a merge team should be done when a repository is created, regardless of whether that repository requires Pull Request reviews or not. The merge team should be named the same as the repository they will be collaborators for. Discipline level teams may be created if approved by DevOps to handle multiple repositories, but this should be in addition to a specific merge team for that repository.</p>"},{"location":"Contributing/Best-practices/Merge-Teams/#adding-people-to-a-merge-team","title":"Adding people to a merge team","text":"<p>A request should be made to DevOps to add an individual to a merge team. Merging Pull Requests is a responsible action which results in code being potentially deployed via Alpha or Beta installers. As such, people who are merging Pull Requests need to be competent in discharging this duty. DevOps is responsible for determining whether an individual is competent in this role and can be added to a merge team. The decision of DevOps is final, however, individuals may make future requests to be added to merge teams and previous prohibition will not be a detrimental factor in a subsequent decision. DevOps will ask individuals to prove competency in a manner appropriate at the time of the request, but will include a review of procedures and policies to ensure the individual understands the broader development picture, as well as the associated risks of merging code.</p>"},{"location":"Contributing/Best-practices/Merge-Teams/#removing-people-from-a-merge-team","title":"Removing people from a merge team","text":"<p>Any individual can request to be removed from a merge team and DevOps will action this as soon as is appropriate without question.</p> <p>Discipline Code Leads may request individuals to be removed from a merge team they are responsible for.</p> <p>DevOps may remove any individual from a merge team at any time if appropriate.</p>"},{"location":"Contributing/Best-practices/Merge-Teams/#the-devops-merge-team","title":"The DevOps Merge Team","text":"<p>The DevOps merge team is a separate team to repository teams, and exists for the purpose of protecting merging to the <code>main</code> branch of repositories included in the Beta. Individuals will only be added to this merge team if they are part of the DevOps team.</p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/","title":"Using the SCRUM Board","text":""},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#introduction","title":"Introduction","text":"<p>To keep things organised and avoid stepping on each other's toes, we are relying on the GitHub Project SCRUM Board. The Project SCRUM Board is the way we communicate, the tool we use to have a bigger picture of what is happening, and the way you will keep records of your work into the BHoM. Since the the Project SCRUM Board is fully automatised, it is read-only and represents a view on what is happening across all the BHoM repositories.</p> <p>.</p> <p>Each card that you see there corresponds to an issue raised in one of the repos. From the moment it is created to the time when that issue has been completely resolved, the corresponding cards, i.e. the issue card and the associated pull-request card, will go through the different columns of this board. </p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#creating-a-card","title":"Creating a Card","text":"<p>The best way to create a card is to create an issue in the corresponding repository and add it to \"SCRUM Development Board Planning\" project. The card will automatically appear in the most appropriate column.</p> <p>Although this is not recommended, if you want to create the card from the project board itself, see the GitHub's help page Adding issues and pull requests to a project board. Be mindful that when you convert the card to issue, it should follow the guidelines described in Submitting an Issue</p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#scrum-board-columns","title":"SCRUM Board Columns","text":""},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#priority-this-sprint","title":"Priority this Sprint","text":"<p>This column contains only issue cards. Once an issue has been assigned to a person as part of his/her tasks for the week, the card can be added to the \"SCRUM Development Board Planning\" project. This action will place the card - an issue card - into the \"Priority this Sprint\" column automatically. If the card/issue was not assigned to anyone at that time, it will then be assigned to that person. You can see who has been assigned the issue by looking at the avatar at the bottom right of the card.</p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#in-progress","title":"In Progress","text":"<p>This column contains only pull request cards. A card is in this column when a person starts working on the corresponding issue. New pull requests that are added to the \"SCRUM Development Board Planning\" project will automatically appear here. Normally, only one card per person should be in that column at a time.</p> <p>Cards in that column are also locking the repository or the project it targets. This means that nobody is allowed to start editing code in that repository while a card is in the In Progress or Review in Progress column. This also means that you can only add a card in that column if there is not already a card locking the same repository. Coordinate with the card's owner if this is the case.</p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#review-in-progress","title":"Review in Progress","text":"<p>This column contains only pull request cards. Once the pull request has been reviewed, and a reviewer requested a change, the <code>automation</code> will move the card from the In Progress column into this one.</p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#reviewer-approved","title":"Reviewer approved","text":"<p>This column contains only pull request cards. Once the changes in the pull request have been accepted by the minimum number of reviewers required, it will be moved into this column. When a pull request is in this column, it is ready to be merged, unless a label <code>do-not-merge</code> is on it.</p>"},{"location":"Contributing/Best-practices/Using-the-SCRUM-Board/#completed","title":"Completed","text":"<p>Once the pull request has been merged into the master branch and the issue closed, the card is moved the the Completed column where it will be discussed in the next planning call. Notice that, once an issue is closed, the logo at the top left of the card has turn red. The Completed column is the only one that should have cards in that state.</p>"},{"location":"Contributing/Best-practices/posting-test-files/","title":"Posting test files","text":"<p>Posting test files in GitHub Issues and Pull Requests (PR) is important, because they allow to reproduce the problem you may have or the feature being implemented.</p> <p>Please remember that there are also other means of testing the code (e.g. code Unit tests; automated Data-driven equality unit tests), so some PRs may not expose any test file. However, if you only know how to reproduce your issue or wanted feature via a script (e.g. a Grasshopper script), or if you think that the PR/issue would benefit from it, then you should post it in the body of your issue (or PR, where applicable).</p>"},{"location":"Contributing/Best-practices/posting-test-files/#how-to-post-a-test-file","title":"How to post a test file","text":"<ul> <li>Create your test script (e.g. in Grasshopper).</li> <li>Save your test script in a file.</li> <li>Zip your test script file.</li> <li>Drag and drop the test script file in the body of the GitHub issue or PR.</li> </ul>"},{"location":"Contributing/Best-practices/posting-test-files/#large-test-files","title":"Large test files","text":"<p>The zipped test file must be less than 50 MB (GitHub size limit), and in general should be less than 10 MB. If your test file is larger than that, it means that you've embedded (internalised) too much testing data. You should simplify the test script to use the minimal amount of data necessary to reproduce the problem. If your test script purposedly targets a large model, then the script should only hold a reference to such model (e.g. a link to it) and the model should be uploaded via another file hosting service.</p>"},{"location":"DevOps/","title":"Introduction to DevOps","text":"<p>This is the section dedicated to DevOps. </p> <p>Within the following pages of this section, you will find more information about our DevOps practices, procedures and ways of working that facilitate cohesion and collaboration across the BHoM. </p>"},{"location":"DevOps/#what-is-devops","title":"What is DevOps?","text":"<p>The word DevOps is a combination of the terms development and operations. The vision of DevOps is to have a smooth, streamlined and sophisticated cycle for development, deployment, and to provide improvements across the BHoM Community. </p> <p>This includes:</p> <ul> <li>Providing a framework for development and deployment</li> <li>Providing safety nets for development to occur with minimal risk</li> <li>Providing continous deployment of tools</li> <li>Reduce the time needed to complete the development cycle</li> </ul>"},{"location":"DevOps/BHoM%20releases/","title":"BHoM releases","text":"<p>The BHoM is released as a complete package, with the individual BHoM libraries and its toolkits all versioned together. This is to ensure ease of tracking compatibility across the number of dependant repositories. </p> <p>BHoM versions are therefore named using the following convention: <code>major.minor.\u03b1/\u03b2.increment</code></p>"},{"location":"DevOps/BHoM%20releases/#major-version","title":"Major version","text":"<p>A major version denotes some fundamental change in the BHoM framework. Targeted approximately yearly. </p>"},{"location":"DevOps/BHoM%20releases/#minor-version","title":"Minor version","text":"<p>Minor versions denote the more frequently planned development cycles and the release of new features/issues, as per individual development road maps and SCRUM planning. Targeted every couple of months/quarterly. </p>"},{"location":"DevOps/BHoM%20releases/#alpha-releases","title":"Alpha releases","text":"<p>The live current state of all the master branches are compiled as an alpha release. This is automatically kept up to date for each successful merging of a PR or PR cluster.  Each alpha release will therefore have a major and minor version number according to the current development cycle, followed by an alpha and an incremented release number for each occurrence, i.e. <code>major.minor.\u03b1.increment</code>.</p>"},{"location":"DevOps/BHoM%20releases/#beta-releases","title":"Beta releases","text":"<p>At the end of a successful development cycle a new beta version will be released  i.e. <code>major.minor.\u03b2.0</code>.   </p> <p>A new minor development cycle will therefore then start.  </p> <p>Hotfixes to beta releases are made only in exceptional circumstances. That is if and only if a critical issue is found and it is deemed necessary to include in the previous minor version, in advance of the release of the current cycle. If this happens, the last digit of the beta release will be incremented, i.e. <code>major.minor.\u03b2.1</code> etc.  </p>"},{"location":"DevOps/BHoM%20releases/#example-development-and-release-sequence","title":"Example development and release sequence","text":"<p>Example table of a sequence of releases over a number of development cycles:</p> 2.1 2.2 2.3 2.1.\u03b1.0 2.1.\u03b1.1 2.1.\u03b1.2 2.1.\u03b1.3 ... 2.1.\u03b2.0 \u2261 2.2.\u03b1.0 2.2.\u03b1.1 2.2.\u03b1.2 ... 2.2.\u03b2.0 \u2261 2.3.\u03b1.0 2.2.\u03b2.1 2.3.\u03b1.1 2.3.\u03b1.2 ... <p>Bold denotes deployed release Italic denotes hotfix</p>"},{"location":"DevOps/Changelog/","title":"BHoM change log","text":"<p>The change log is made by aggregating the notes from Pull Requests for each repository within the organisation. They are available here</p>"},{"location":"DevOps/Changelog/#pull-requests","title":"Pull requests","text":"<p>To simplify the managing of the changelog it is best practice to note what has changed at the time of a pull request. The change log will be generated from the title and body of the pull request using the PULL_REQUEST_TEMPLATE.</p> <p>The Pull Request Title should state, in a simple sentence, what the Pull Request is changing. For toolkits, this should not include the toolkit title, however, for multi-project repositories it should. For example:</p> <p>A Pull Request raised on the XML Toolkit to update Space Type will simply have the title of:</p> <p>Update Space Type  </p> <p>Whereas a Pull Request on the BHoM_Engine to update the Environment Engine panel query will have the title of:</p> <p>Environment_Engine: Update panel query to use names</p> <p>If the changes are greater than a single sentence can describe, then in the Changelog section, describe the changes in a bulleted list.  The bullet points are required and no other information other than brief definition of changes should be made in this section. The <code>Additional Comments</code> section is then for any additional information or more verbose context.</p> <p>For example:</p> <pre><code>### Changelog\n\n- `Query.Tangent()` Query method added in the `Structure_Engine` for `Bar` class\n</code></pre> <p>The entries made here will be mined for the next release and added to the changelog in one go.</p> <p>Pull requests must also have a label defining their <code>type</code> - either feature, bug fix, test script, documentation, compliance, or other approved type of pull request. This is to aid categorisation of pull requests for the change log. Where a pull request might span multiple types (for example, a pull request adding a new feature and fixing a bug in the same work), then multiple type labels may be applied.</p>"},{"location":"DevOps/Open-Sourcing-Procedure/","title":"Open Sourcing Procedure","text":""},{"location":"DevOps/Open-Sourcing-Procedure/#preparation-of-the-code-and-repository","title":"Preparation of the code and repository","text":"<p>Tasks to be completed before migration to public organisation. To be carried out/reviewed by the Repository Owner:</p>"},{"location":"DevOps/Open-Sourcing-Procedure/#licencing-and-copyright","title":"Licencing and copyright","text":"<ul> <li>Ensure repository has valid licence file.  BHoM defaults to LGPL v3 https://github.com/BHoM/BHoM/blob/master/LICENSE.  Repositories can naturally be licenced differently, but by exception only and through coordination with BHoM Organisation Administrators. In addition this will also require modifications to the repo's copyright headers in every code file.</li> <li>All code files must have a valid BHoM copyright header compatible with licencing (see point above)    See here for the default https://github.com/BHoM/BHoM/blob/master/COPYRIGHT_HEADER.txt</li> <li>Assembly information and the included copyright must also conform to BHoM standards.  Such as <code>[assembly: AssemblyCopyright(\"Copyright \u00a9 https://github.com/BHoM\")]</code></li> </ul>"},{"location":"DevOps/Setting-up-a-new-repo/","title":"Setting up a new Repo","text":"<p>It is recommended that you use the template repository for initial set up of your new repository. It will include an appropriate <code>gitignore</code> file, a suitable Visual Studio file, and a <code>ReadMe</code> file which can be easily updated for your repository. It will also include some sample code for an oM, Engine, and Adapter to get you started.</p> <p>This page provides instructions on how to set up a repository within BHoM to meet our guidelines/standards and assist our automated processes to work with the new repository. This is for brand new repositories, which by default will start life as Prototype status. Once repositories progress to become Beta repositories, the requirements for the repository will shift slightly, including additional requirements to the branching strategy. If further assistance is required, please reach out to the DevOps team.</p> <ol> <li>Select the repository template - </li> <li>Name the Repo SoftwareNameOrFocus _Toolkit. It will likely end in Toolkit - see explaination here. It may end in _Tool if the designation of the repository is for a zero-code tool rather than an interoperability toolkit. DevOps can assist in making the distinction if required.</li> <li>Make sure the Public option is selected.</li> <li>Under Settings -&gt; Options. Ensure only the merge option is enabled and the default commit message is set to be the Pull Request title - </li> <li>Add a Team under Collaborators and teams</li> <li>Under Branches. Set the main Branch as protected with the following settings (click edit on the right-hand side of the listed main branch)</li> </ol> <p> </p> <p>If you don't have a team for that repo yet, you can create it here. Make sure the team has the same name as the repo and that you have added the repo into its list of repositories with the the \"Write\" access level. Now you should be able to link it in the branch setup page above.</p> <p>Once you've set up the repository, follow the instructions in the template repository to finish setting up the repository from the code perspective.</p>"},{"location":"DevOps/Bots/","title":"Introduction to Bots in BHoM","text":"<p>Bots are a handy way of supporting our BHoM Community in delivering outstanding work. The official DevOps strategy for BHoM says:</p> <p>Reducing cognitive overhead on developers frees us up to perform outstanding developments</p> <p>Using bots is a large part of this, reducing the need for human maintainers to perform repetitive actions, or actions which follow a strict set of rules and can be easily automated.</p> <p>We want to reduce human time spent on tasks which are repetitive, or tasks which can be easily automated. Therefore DevOps maintains this bot strategy to support, and free up our maintainers and community members to perform their best work without needing to remember the minutia involved in development.</p>"},{"location":"DevOps/Bots/#code-of-conduct","title":"Code of Conduct","text":"<p>Any bot which interacts with our BHoM Community is bound to adhere by our Code of Conduct for Bots which is reviewed periodically by the DevOps team.</p>"},{"location":"DevOps/Bots/#bot-synonyms","title":"Bot synonyms","text":"<p>Occasionally bots may be referred to by other names, such as pipelines, actions, and copilots. For the purposes of DevOps strategies, all of these are considered to be types of bots which may assist our work in their own defined fashion. Where we use the term bot in within DevOps, we are referring to any type of bot that can perform actions in the absence of all or some human involvement.</p>"},{"location":"DevOps/Bots/#adding-to-our-bot-family","title":"Adding to our bot family","text":"<p>If you have an idea for our bot family, either as an addition or our maintained bot (BHoMBot) or an externally provided bot-like action, please feel free to raise a discussion item - our DevOps team don't know of every tool on the market and always welcome new ideas from our community</p>"},{"location":"DevOps/Bots/BHoMBot/","title":"BHoMBot","text":"<p>BHoMBot is our friendly neighbourhood bot who helps us with various tasks across the BHoM Community. BHoMBot adheres to our Code of Conduct for Bots.</p>"},{"location":"DevOps/Bots/BHoMBot/#bhombot-a-history","title":"BHoMBot: A History","text":"<p>BHoMBot launched in August 2020 as a prototype codebase to initially assist in checking our compliance regulations of the time were being followed without needing human effort. This was supported by the development of Test_Toolkit, a key component in BHoMBot's infrastructure for running those compliance checks.</p> <p>BHoMBot quickly expanded and took on additional tasks to support the community, taking over the installer checks that had previously been handled by Azure, and compilation checks handled by AppVeyor. A key component of our distributed working is on the distribution of code via many repositories, and while it can take some getting used to, members of the BHoM Community will recognise the additional challenge this presents in ensuring our code is deliverable to the world beta-to-beta. Thus, BHoMBot took on this additional challenge early on, assisting our community in checking how downstream repositories would react to upstream changes.</p> <p>BHoMBot quickly became a staple of our community and grew from the initial prototype to a tool the community relied on, with the checks provided by BHoMBot to pull requests quickly becoming a required part of our workflows.</p> <p>In 2022, BHoMBot underwent their first major upgrade, being transformed from a simple bot covering simple compliance and compilation based checks, to a modular bot capable of handling additional tasks programmed for them to perform. Stability and reliability of BHoMBot also increased in this upgrade, as early BHoMBot had been developed on the initial prototype. Since this upgrade, BHoMBot has provided us with our usual array of pull request checks, our installer files for distribution, our change logs, our analytics, and most recently our Nuget packages as we expand our BHoM Community to include support for .Net6 tools.</p> <p>In 2024, BHoMBot is getting their next upgrade, changing how we interact with them to perform our work and solve our development challenges within our Community.</p>"},{"location":"DevOps/Bots/BHoMBot/#interacting-with-bhombot","title":"Interacting with BHoMBot","text":"<p>BHoMBot operates on a call-and-response model, devised from radio call communications used by various organisations in the non-digital world. This communication model works on the listener repeating back key parts of information they've heard to confirm they've heard the correct instruction.</p> <p>BHoMBot naturally has a large number of repositories to look after to support our community, and some pull requests take longer to be ready for the community than others as they go through various prototyping, discussion, and refinement stages as draft or WIP pull requests. Therefore, BHoMBot responds only to the direct request for them to perform an action triggered by any community member on a pull request. Typically this is done by calling to BHoMBot in the way you would to any other community member - <code>@BHoMBot</code> and then asking them to perform an action, typically a set of checks. BHoMBot will then respond with the list of checks they have queued up to work on for you.</p> <p>In 2024, we are changing the strategy on how we interact with BHoMBot in order to reduce noise on pull requests and allow meaningful discussion around code suggestions as opposed to polluting the pull request with these call-and-response commands. While nice to receive a friendly message back from our friend, BHoMBot, we've decided the time is right to switch to a quieter mode of working. As such, while you can request BHoMBot to perform actions on your pull request as usual, from the 7.2 milestone BHoMBot will no longer comment a response but instead provide an emoji response as depicted below. This emoji response of a thumbs-up will be given by BHoMBot to acknowledge your request has been queued in their queue system, and will be actioned as soon as they have resource to do so.</p> <p></p>"},{"location":"DevOps/Bots/BHoMBot/#bhombots-interactions-with-our-community","title":"BHoMBot's interactions with our community","text":"<p>From the 7.2 milestone, BHoMBot will change how they interact with our code. As part of our switch from the call-and-response model outlined above, BHoMBot will also start automatically queueing up certain pull request checks as commits are done. This will be limited to the small checks, focused primarily around compliance and local compilation (of the repository being changed, rather than all downstream and upstream repositories) to reduce the need for us to ask BHoMBot to perform actions. We can still ask if we want extra, however, BHoMBot will start to perform the mandatory checks automatically.</p> <p>Some of the heavier checks, such as those which require compilation of all upstream and downstream repositories, will instead occur overnight in a batch processing operation. When BHoMBot does this, they will flag any issues they find as new issues on affected repositories. Repository maintainers should take note of issues BHoMBot raises and ensure they are actioned before the next beta release ideally, as they will likely be items which could impact our beta delivery.</p> <p>Where BHoMBot raises issues for us, or otherwise interacts with our community, they will be bound to follow our Code of Conduct for Bots.</p>"},{"location":"DevOps/Bots/BHoMBot/#bhombots-scope","title":"BHoMBot's scope","text":"<p>BHoMBot is set up to listen to activity occurring on any repository within the BHoM organisation. As such, whenever a new repository is made, BHoMBot can listen to activity instantly which provides zero downtime between repository set up, and bot support to that repository. This is contrasted to other bots such as AppVeyor, or Azure Pipelines, which require individual repository set up and activation before they will operate. Naturally this is deliberate on their part to ensure only the repositories they have explicit permission to operate on receive their support, however, this does make for an increased workload on DevOps when setting up a new repository. As such, given the BHoM Community maintain BHoMBot for our specific purposes, DevOps have granted BHoMBot immediate and full access to all our BHoM repositories by default.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/","title":"Code compliance","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/#what-is-code-compliance","title":"What is code compliance?","text":"<p>Code Compliance is the phrase used to determine how much the code written within the BHoM framework is in line with the rules/regulations/guidelines of BHoM development. The compliance rules have evolved following the initial ethos of BHoM and been carefully refined as BHoM has developed.</p> <p>The core of the rules however remains the same - that the code should be architected in such a way to facilitate, and promote, adoption and collaboration by any engineer using the BHoM. The components they see on the UI, should reflect what they can see in the code, the code should be easy to navigate by those wishing to find information, and the style from toolkit to toolkit should be consistent. All of this allows new members of BHoM to quickly get to grips with the basics, and the ability for multiple people to work on multiple toolkits is enhanced as a result.</p> <p>The rules, regulations, and guidelines set out in this section of the wiki are there to give us reference for writing sustainable, maintainable, and compliant code within the framework of BHoM. They are our standards by which we should all follow.</p> <p>The compliance laid out in the following pages does undergo periodic review by the DevOps team, as styles develop, and the guidance evolves, so if you feel something isn't quite right or is unclear, please feel free to open a discussion.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/#types-of-compliance","title":"Types of compliance","text":"<p>Compliance can be broken into the following categories.</p> <ul> <li>Code Compliance - this is the compliance of code which is written within the BHoM framework</li> <li>Documentation Compliance - this is the compliance of the documentation that aids users and wraps around code</li> <li>Project Compliance - this is the compliance of the repository, its associated project files, and planning operations</li> </ul>"},{"location":"DevOps/Code%20Compliance%20and%20CI/#compliance-results","title":"Compliance results","text":"<p>Compliance results can form one of three outcomes.</p> <ul> <li>Pass - everything is good, compliant, and meets the guidance available</li> <li>Warning - a piece of code is not compliant, but it is deemed not to be so severe as to prevent a PR being merged, but it should be addressed as quick as possible</li> <li>Fail - a piece of code is not compliant, and it is critical to resolve it before the PR is merged</li> </ul> <p>Toolkit and Discipline Leads are responsible for deciding whether <code>warning</code> results are acceptable on their toolkit on a case-by-case basis.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/#current-compliance-checks","title":"Current compliance checks","text":"<p>Correct at time of writing.</p> Check Severity Compliance Type Assembly Information Fail Project AttributeHasEndingPunctuation Warning Documentation EngineClassMatchesFilePath Fail Code HasConstructor Fail Code HasDescriptionAttribute Fail Documentation HasOneConstructor Fail Code HasOutputAttribute Warning Documentation HasPublicGet Fail Code HasSingleClass Fail Code HasSingleNamespace Fail Code HasUniqueOutputAttribute Fail Documentation HasUniqueMultiOutputAttributes Fail Documentation HasValidConstructor Fail Code HasValidCopyright Fail Copyright HasValidOutputAttribute Fail Documentation HasValidMultiOutputAttributes Fail Documentation HasValidPreviousVersionAttribute Fail Documentation HiddenInputsAreLast Warning Documentation InputAttributeHasMatchingParameter Fail Documentation InputAttributeIsUnique Fail Documentation InputAttributesAreInOrder Fail Documentation InputParameterStartsLower Fail Code IsDocumentationURLValid Fail Documentation IsExtensionMethod Fail Code IsInputAttributePresent Warning Documentation IsPublicClass Fail Code IsPublicProperty Fail Code IsStaticClass Fail Code IsUsingCustomData Warning Code IsValidCreateMethod Fail Code IsValidConvertMethodName Fail Code IsValidCreateMethodName Fail Code IsValidDataset Fail Dataset IsValidEngineClassName Fail Code IsValidIImmutableObject Fail Code IsVirtualProperty Fail Code MethodNameContainsFileName Fail Code MethodNameStartsUpper Fail Code ModifyReturnsDifferentType Fail Code ObjectNameMatchesFileName Fail Code PreviousInputNamesAttributeHasMatchingParameter Fail Documentation PreviousInputNamesAttributeIsUnique Fail Documentation Project References and Build Paths Fail Project PropertyAccessorsHaveNoBody Fail Code UIExposureHasDefaultValue Fail Documentation"},{"location":"DevOps/Code%20Compliance%20and%20CI/Continuous-integration/","title":"Continuous Integration (CI)","text":"<p>Continuous Integration (CI) is the name given to the process of assisting our PR checks and resolving uncertainty in code status.</p> <p>CI checks are built and maintained by the BHoM CI/CD team, but are operated automatically by our CI systems (including, but not limited to, AppVeyor, Azure DevOps and associated bots<sup>1</sup>).</p> <p>The aim of CI checks is to increase confidence in our code, without unduly hindering our ability to prototype, develop, and extend the BHoM.</p> <p>The pages within this section detail the CI checks we currently have operating, so that everyone can see how the checks are running and help ensure their PRs pass the checks.</p> Check Provider Command Check Core BHoMBot Trigger by PR comment <code>@BHoMBot check core</code> Check Installer BHoMBot Triggered by PR comment <code>@BHoMBot check installer</code> Check Project Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check project-compliance</code> Check Code Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check code-compliance</code> Check Documentation Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check documentation-compliance</code> Check Copyright Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check copyright-compliance</code> Check Dataset Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check dataset-compliance</code> Check Branch Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check branch-compliance</code> Check Unit Tests BHoMBot Triggered by PR Comment <code>@BHoMBot check unit-tests</code> Check Null Handling BHoMBot Triggered by PR Comment <code>@BHoMBot check null-handling</code> Check Serialisation BHoMBot Triggered by PR Comment <code>@BHoMBot check serialisation</code> Check Versioning BHoMBot Triggered by PR Comment <code>@BHoMBot check versioning</code> Check Ready To Merge BHoMBot Triggered by PR Comment <code>@BHoMBot check ready-to-merge</code> Check Compliance BHoMBot Triggered by PR Comment <code>@BHoMBot check compliance</code> Check Required BHoMBot Triggered by PR Comment <code>@BHoMBot check required</code>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Continuous-integration/#optional-arguments","title":"Optional arguments","text":"<p>The following flags may be provided when requesting a check to request specific behaviour from the bot when running your requested check. One or more flags may be used at any one time - for example to trigger a full, forced, versioning check, you could use the command <code>@BHoMBot check versioning -force -full</code>. All flags are prepended by a dash (<code>-</code>). To see how an argument will affect a check, see the individual check page.</p> Flag Action Example -force Requires a check to run even if it could be bypassed. For example, if a pull request does not change any <code>CS</code> or <code>CSProj</code> files, then the Versioning check may not run as it is time intensive. However, if you want to force the check to run, append <code>-force</code> to your request and it will run even if it could be bypassed. <code>@BHoMBot check versioning -force</code> -quick Requests that the check run in a shortened format if available. For example, the Versioning check can opt to only compile the code in the pull request if no other repositories are depending on the work, allowing for a quicker versioning check compared to the default which will compile all the code used by the installers. <code>@BHoMBot check versioning -quick</code>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Continuous-integration/#use-of-ci-checks","title":"Use of CI checks","text":"<p>Not all checks are required on all repositories or on all branches, depending on the lifecycle state of the repository. The table below indicates which checks are required for a given repository state.</p> Check Prototype Alpha Beta (<code>develop</code>) Beta (<code>main</code>) Core Installer Project Compliance Code Compliance Documentation Compliance Copyright Compliance Dataset Compliance Branch Compliance Unit Tests Null Handling Serialisation Versioning Ready to Merge <p><sup>1</sup> See more notes on our approach to using and interacting with bots and automated processes as part of our Code of Conducts.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-All/","title":"Check All","text":"<p>This check will trigger all checks available to BHoMBot to be queued for the pull request. BHoMBot will confirm what checks are being triggered when the command is run.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-All/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check all</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Branch-Compliance/","title":"Check Branch Compliance","text":"<p>This check will confirm the branch name for the pull request matches the guidelines.</p> <p>If the check is unsuccessful, it will remind you of the conventions for next time. Following the conventions on branch naming is very important for CI processes.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Branch-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check branch-compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Code-Compliance/","title":"Check Code Compliance","text":"<p>This check will confirm the <code>cs</code> files changed within a pull request are compliant to the guidelines for code files. This check will run only the compliance checks that have the Compliance Type of <code>code</code> in the table on the linked page.</p> <p>If the check is unsuccessful, you can trigger BHoMBot to make certain fixes for you. This can be accessed by viewing the details of the check and clicking the <code>Fix</code> button to trigger the process on the pull request.</p> <p>If you believe the check has failed erroneously, you can request dispensation from the CI/CD team. This can be accessed by viewing the details of the check and clicking the <code>Request Dispensation</code> button to trigger the process on the pull request. The CI/CD team will review the failures and weigh up the options on progressing the pull request. Dispensation may not always be granted, but this will be a discussion between the pull request collaborators and the CI/CD team.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Code-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check code-compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Compliance/","title":"Check Compliance","text":"<p>This check will trigger all compliance checks available to BHoMBot to be queued for the pull request. BHoMBot will confirm what compliance checks are being triggered when the command is run.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Copyright-Compliance/","title":"Check Copyright Compliance","text":"<p>This check will confirm the <code>cs</code> files changed within a pull request are compliant to the guidelines for having valid copyright on their code files. This check will run only the compliance checks that have the Compliance Type of <code>copyright</code> in the table on the linked page.</p> <p>If the check is unsuccessful, you can trigger BHoMBot to make certain fixes for you. This can be accessed by viewing the details of the check and clicking the <code>Fix</code> button to trigger the process on the pull request.</p> <p>If you believe the check has failed erroneously, you can request dispensation from the CI/CD team. This can be accessed by viewing the details of the check and clicking the <code>Request Dispensation</code> button to trigger the process on the pull request. The CI/CD team will review the failures and weigh up the options on progressing the pull request. Dispensation may not always be granted, but this will be a discussion between the pull request collaborators and the CI/CD team.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Copyright-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check copyright-compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Core/","title":"Check Core","text":"<p>This check will confirm the pull request will compile successfully on its own. This check is operated by both BHoMBot (all repositories) and Azure DevOps (selected repositories).</p> <p>The check will clone the repository associated to the pull request, then clone the repositories listed in that repositories <code>dependencies.txt</code> file and build them in the order listed in that file. The pull request will then be built last.</p> <p>Providing the compilation is successful, the check will return a pass. If the pull request cannot compile then it will return an error. BHoMBot will list the errors as annotations, while Azure needs to be reviewed to ascertain the errors.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Core/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check core</code></p> <p>Azure DevOps&gt;<code>/azp run &lt;Your_Toolkit&gt;.CheckCore</code></p> <p>(where <code>&lt;Your_Toolkit&gt;</code> is the name of your repository).</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Dataset-Compliance/","title":"Check Dataset Compliance","text":"<p>This check will confirm the <code>json</code> files changed within a pull request are compliant to the dataset guidelines for dataset files. This check will run only the compliance checks that have the Compliance Type of <code>dataset</code> in the table on the linked page.</p> <p>If the check is unsuccessful, you can trigger BHoMBot to make certain fixes for you. This can be accessed by viewing the details of the check and clicking the <code>Fix</code> button to trigger the process on the pull request.</p> <p>If you believe the check has failed erroneously, you can request dispensation from the CI/CD team. This can be accessed by viewing the details of the check and clicking the <code>Request Dispensation</code> button to trigger the process on the pull request. The CI/CD team will review the failures and weigh up the options on progressing the pull request. Dispensation may not always be granted, but this will be a discussion between the pull request collaborators and the CI/CD team.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Dataset-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check dataset-compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Documentation-Compliance/","title":"Check Documentation Compliance","text":"<p>This check will confirm the <code>cs</code> files changed within a pull request are compliant to the documentation guidelines for code files. This check will run only the compliance checks that have the Compliance Type of <code>documentation</code> in the table on the linked page.</p> <p>If the check is unsuccessful, you can trigger BHoMBot to make certain fixes for you. This can be accessed by viewing the details of the check and clicking the <code>Fix</code> button to trigger the process on the pull request.</p> <p>If you believe the check has failed erroneously, you can request dispensation from the CI/CD team. This can be accessed by viewing the details of the check and clicking the <code>Request Dispensation</code> button to trigger the process on the pull request. The CI/CD team will review the failures and weigh up the options on progressing the pull request. Dispensation may not always be granted, but this will be a discussion between the pull request collaborators and the CI/CD team.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Documentation-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check documentation-compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Installer/","title":"Check Installer","text":"<p>The Check-Installer pipeline answers the question of:</p> <p>If this pull request is merged to <code>develop</code> or <code>main</code>, could we build a deployable installer from it?</p> <p>This checks all of the repositories included within the BHoM_Installer against the branch of the pull request of the toolkit being checked, and ensures all repositories included within the installer are built successfully. Any problems are then identified early and able to be handled appropriately.</p> <p>If any part of the installer fails to build successfully then a failed check will be returned to the pull request.</p> <p>For BHoMBot, if you have dependant pull requests linked as part of a series, running the check on one pull request will trigger a check result (success or failure depending on the outcome) to all pull requests in the series, as they will have all been tested when requested.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Installer/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check installer</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Installer/#arguments","title":"Arguments","text":"<p><code>-quick</code> - if this flag is provided, then only the code changed by the pull request and its immediate dependencies (upstream) will be compiled. If not provided, the default of compiling all the code in the installer will be used instead.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Null-Handling/","title":"Check Null Handling","text":"<p>This check will confirm the changes proposed by the pull request do not negatively impact the results of Null Handling tests.</p> <p>The check will clone the repository associated to the pull request, and its dependencies listed within the <code>dependencies.txt</code> file, and compile all of them to get the relevant DLLs. Once the DLLs are generated, the Null Handling test will generate against the <code>master</code> branches of those repositories. Following that result, the DLLs will be regenerated against the branch of the pull request and generate a second result to compare with.</p> <p>If the two results come back equal (i.e. there is no change to Null Handling presented by your pull request) then this will report back as a pass.</p> <p>If the errors of your branch report less Null Handling errors than the <code>master</code> result, AND any errors in your branch report exist on the <code>master</code> result, this will be deemed to be an improvement and will report back as a pass.</p> <p>If the errors of your branch are less than those of the <code>master</code> result, but the errors on your branch result do not exist on the <code>master</code> result, this will be deemed to be a failure as your pull request(s) are resulting in new Null Handling errors.</p> <p>If the errors of your branch are more than the errors of the <code>master</code> result then this is also deemed to be a failure as your pull request(s) are increasing the number of Null Handling errors.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Null-Handling/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check null-handling</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-PR-Builds/","title":"Check-PR-Builds","text":"<p>Trigger Status: This check is automatically triggered when you raise a PR and push commits to that PR.</p> <p>These checks, run by AppVeyor, validate that the current state of the code on the PR builds successfully with all of its own dependencies.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Project-Compliance/","title":"Check Project Compliance","text":"<p>This check will confirm the <code>csproj</code> files changed within a pull request are compliant with the guidelines for project files.</p> <p>If the check is unsuccessful, you can trigger BHoMBot to make the fixes for you. This can be accessed by viewing the details of the check and clicking the <code>Fix</code> button to trigger the process on the pull request.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Project-Compliance/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check project-compliance</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Ready-To-Merge/","title":"Check Ready To Merge","text":"<p>This check will confirm the pull request is ready to merge based on the following conditions.</p> <ul> <li>Any requested changes have been addressed (changed to an approving review) or dismissed</li> <li>The pull request does not have a <code>status:do-not-merge</code> label</li> <li>The pull request has suitable labels for the change log - labels should be starting with <code>type:</code> to denote the type of pull request</li> <li>The pull request has at least one approving review</li> <li>The pull request has passed <code>check-core</code> and <code>check-installer</code> from BHoMBot</li> </ul> <p>This check is done for all pull requests that are linked in a series. If any of the pull requests are not ready, then the check will report that none of them are ready. This is to protect against merging pull requests in a series that may be dependent on each other accidently, where one pull request is ready to merge but another is not. This protects the installer builds (where <code>check-installer</code> reports a pass to all pull requests because the changes are ok, but if one of the pull requests then isn't merged it will fail to build the installer later) as well.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Ready-To-Merge/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check ready-to-merge</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Required/","title":"Check Required","text":"<p>This check will trigger all required checks available to BHoMBot to be queued for the pull request. BHoMBot will confirm what required checks are being triggered when the command is run.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Required/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check required</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Serialisation/","title":"Check Serialisation","text":"<p>This check will confirm the changes proposed by the pull request do not negatively impact the results of serialisation tests.</p> <p>The check will clone the repository associated to the pull request, and its dependencies listed within the <code>dependencies.txt</code> file, and compile all of them to get the relevant DLLs. Once the DLLs are generated, the serialisation test will generate against the <code>master</code> branches of those repositories. Following that result, the DLLs will be regenerated against the branch of the pull request and generate a second result to compare with.</p> <p>If the two results come back equal (i.e. there is no change to serialisation presented by your pull request) then this will report back as a pass.</p> <p>If the errors of your branch report less serialisation errors than the <code>master</code> result, AND any errors in your branch report exist on the <code>master</code> result, this will be deemed to be an improvement and will report back as a pass.</p> <p>If the errors of your branch are less than those of the <code>master</code> result, but the errors on your branch result do not exist on the <code>master</code> result, this will be deemed to be a failure as your pull request(s) are resulting in new serialisation errors.</p> <p>If the errors of your branch are more than the errors of the <code>master</code> result then this is also deemed to be a failure as your pull request(s) are increasing the number of serialisation errors.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Serialisation/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check serialisation</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Unit-Tests/","title":"Check Unit Tests","text":"<p>This check will confirm the unit tests set up within a <code>.ci/Datasets</code> folder on a repository run successfully using the Unit Test framework.</p> <p>The check will clone the repository associated to the pull request, and its dependencies listed within the <code>dependencies.txt</code> file, and compile all of them to get the relevant DLLs. Once the DLLs are generated, the unit tests will then run and compare the serialised results against the results coming out from the pull request.</p> <p>The result of a unit test check may require further investigation and interpretation by a human reviewer.</p> <p>If the check passes, then the unit tests serialised and the results from the pull request match exactly.</p> <p>If the check fails, then it means the check found differences between the serialised results, and the new results. This is where investigation may be needed, as some differences may be failures (where the pull request is negatively impacting the result), but some differences may be improvements (where the pull request is making outcomes better compared to the serialised results which are made against a version of <code>master</code> that the toolkit leads are happy with).</p> <p>If the check fails, but is providing better results and a human review agrees that the pull request is improving the standard, then it is recommended to update the unit tests against <code>master</code> after merging the pull request as soon as possible to ensure that version of results are stored for future pull requests. Unit tests can be updated on the pull request itself if agreed by the toolkit lead.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Unit-Tests/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check unit-tests</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Versioning/","title":"Check Versioning","text":"<p>This check will confirm the changes proposed by the pull request do not negatively impact the results of versioning tests.</p> <p>The check will clone all the repositories in the BHoM_Installer and compile all of them to get the relevant DLLs. Once the DLLs are generated, the versioning test will generate against the <code>master</code> branches of those repositories. Following that result, the DLLs will be regenerated against the branch of the pull request and generate a second result to compare with.</p> <p>If the two results come back equal (i.e. there is no change to versioning presented by your pull request) then this will report back as a pass.</p> <p>If the errors of your branch report less versioning errors than the <code>master</code> result, AND any errors in your branch report exist on the <code>master</code> result, this will be deemed to be an improvement and will report back as a pass.</p> <p>If the errors of your branch are less than those of the <code>master</code> result, but the errors on your branch result do not exist on the <code>master</code> result, this will be deemed to be a failure as your pull request(s) are resulting in new versioning errors.</p> <p>If the errors of your branch are more than the errors of the <code>master</code> result then this is also deemed to be a failure as your pull request(s) are increasing the number of versioning errors.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Versioning/#trigger-commands","title":"Trigger commands:","text":"<p>BHoMBot</p> <p><code>@BHoMBot check versioning</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/CI%20Checks/Check-Versioning/#arguments","title":"Arguments","text":"<p><code>-force</code> - if provided, this will force the versioning check to run even if it could be bypassed. If no <code>.cs</code> files have been changed by the pull request, it will bypass the versioning check to save time (as only changes to <code>.cs</code> files typically introduce versioning issues). Use this flag to force versioning to be checked regardless of whether <code>.cs</code> files have changed.</p> <p><code>-quick</code> - if provided, this will only compile the code in the request pull request and any immediate upstream dependencies. Without this flag, all the code in the installer is compiled to then check versioning against.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AssemblyInfo-compliance/","title":"AssemblyInfo compliance","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AssemblyInfo-compliance/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AssemblyInfo-compliance/#details","title":"Details","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AssemblyInfo-compliance/#assembly-information","title":"Assembly Information","text":"<p>This section is only valid for projects utilising the old-style CSProject files, where an <code>AssemblyInfo.cs</code> file is present. If an <code>AssemblyInfo.cs</code> file is not present, then the compliance of this information can be found here.</p> <p>Each DLL should have suitable assembly information to support automated processes and confirming the version of the code which the DLL was built against. This includes these three items:</p> <ul> <li><code>&lt;AssemblyVersion&gt;</code></li> <li><code>&lt;AssemblyFileVersion&gt;</code></li> <li><code>&lt;AssemblyDescription&gt;</code></li> </ul> <p>The <code>AssemblyVersion</code> should be set to the major version for the annual development cycle. This is set by DevOps, and will typically be a 4-digit number where the first number is the major version for the year, followed by three 0's - e.g. <code>5.0.0.0</code> for the 2022 development calendar (note, development calendars are based on release schedules as outlined by DevOps, not any other calendar system).</p> <p>The <code>AssemblyFileVersion</code> should be set to the current development milestone, which is the major version followed by the milestone, followed by two 0's - e.g. <code>5.3.0.0</code> for the development milestone running from June-September 2022.</p> <p>The <code>AssemblyDescription</code> attribute should contain the full link to the repository where the DLL is stored, e.g. <code>https://github.com/BHoM/Test_Toolkit</code> for DLLs where the code resides in Test_Toolkit.</p> <p>At the start of each milestone, BHoMBot will automatically uptick the <code>AssemblyVersion</code> and <code>AssemblyFileVersion</code> as appropriate, and set the <code>AssemblyDescription</code> if it was not previously set. However, if you add a new project during a milestone, BHoMBot will flag these items as incompliant if they have not been resolved prior to running the <code>project-compliance</code> check. These items can be fixed by BHoMBot if you request BHoMBot to fix the project information.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AttributeHasEndingPunctuation/","title":"AttributeHasEndingPunctuation","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AttributeHasEndingPunctuation/#summary","title":"Summary","text":"<p>Severity - Warning</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/AttributeHasEndingPunctuation/#details","title":"Details","text":"<p>The <code>AttributeHasEndingPunctuation</code> check ensures that an attribute providing documentation (<code>input</code>, <code>description</code> <code>output</code> or <code>multioutput</code>) ends with a suitable piece of punctuation. See the check method for the current accepted list.</p> <p>This check is useful for helping provide delineation between the documentation you provide as the developer, and the documentation provided automatically on components within the UI.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/EngineClassMatchesFilePath/","title":"EngineClassMatchesFilePath","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/EngineClassMatchesFilePath/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/EngineClassMatchesFilePath/#details","title":"Details","text":"<p>The <code>EngineClassMatchesFilePath</code> check looks at whether the the class of the engine method matches based on its file path.</p> <p>For example, <code>Compute</code> class files should sit within the file path <code>Your_Toolkit/Toolkit_Engine/Compute</code> and not within <code>Your_Toolkit/Toolkit_Engine/Query</code>. This check ensures the class name is correct based on the file name.</p> <p>Files contained within an Engines <code>Objects</code> folder are exempt from this check (e.g. files with the file path <code>Your_Toolkit/Toolkit_Engine/Objects/Foo.cs</code> will be exempt).</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasConstructor/","title":"HasConstructor","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasConstructor/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasConstructor/#details","title":"Details","text":"<p>The <code>HasConstructor</code> check ensures that all BHoM objects do not have a constructor unless they are implementing the <code>IImmutable</code> interface on the object.</p> <p>Constructors are only valid on <code>IImmutable</code> objects that contain <code>get</code> only properties, and are necessary for BHoM serialisation to function correctly.</p> <p>The following scenarios will result in this check failing:</p> <ul> <li>An object which contains a constructor, and does not implement the <code>IImmutable</code> interface</li> <li>An object which implements the <code>IImmutable</code> interface, but does not contain a constructor</li> </ul>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasConstructor/#more-information","title":"More information","text":"<p>More information on the use of <code>IImmutable</code> interface within the BHoM can be found here.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasDescriptionAttribute/","title":"HasDescriptionAttribute","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasDescriptionAttribute/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasDescriptionAttribute/#details","title":"Details","text":"<p>The <code>HasDescriptionAttribute</code> check ensures that a method has a <code>Description</code> attribute explaining what the method is doing for users.</p> <p>You can add a <code>Description</code> attribute with the following syntax sitting above the method:</p> <p><code>[Description(\"Your description here\")]</code></p> <p>If you have not used any attributes in your file previously, you may need to add the following usings:</p> <p><code>using BH.oM.Base.Attributes;</code></p> <p><code>using System.ComponentModel;</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasDescriptionAttribute/#description-authoring-guidelines","title":"Description authoring guidelines","text":"<p>We should be aiming for all properties, objects and methods to have a description. With only the very simplest of self explanatory properties to not require a description by exception - and indeed only where the below guidelines can not be reasonably satisfied. </p> <p>So what makes a good description?</p> <ol> <li>A description must impart additional useful information beyond the property name, object and namespace. </li> <li>Further to a definition, the description is an opportunity to include usage guidance, tips or additional context.</li> <li>The description is a place you can include synonyms etc. to help clarify for others in different regions/domains, being inclusive as possible.</li> <li>Also don't forget the addition of a Quantity Attribute can be used now, appropriate for Doubles and Vectors.</li> </ol>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOneConstructor/","title":"HasOneConstructor","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOneConstructor/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOneConstructor/#details","title":"Details","text":"<p>The <code>HasOneConstructor</code> check ensures that all BHoM objects that do have a constructor (and are allowed to do so by implementing the <code>IImmutable</code> interface) only contains one constructor with parameters.</p> <p>Objects which implement a constructor are permitted to also implement a parameterless constructor, but only if this is necessary.</p> <p>Objects which implement more than one constructor taking parameters will be flagged as failing this check.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOneConstructor/#more-information","title":"More information","text":"<p>More information on the use of <code>IImmutable</code> interface within the BHoM can be found here.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOutputAttribute/","title":"HasOutputAttribute","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOutputAttribute/#summary","title":"Summary","text":"<p>Severity - Warning</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasOutputAttribute/#details","title":"Details","text":"<p>The <code>HasOutputAttribute</code> check ensures that a method has a <code>Output</code> or <code>MultiOutput</code> attribute explaining what the method is providing for users.</p> <p>You can add an <code>Output</code> attribute with the following syntax sitting above the method:</p> <p><code>[Output(\"outputName\", \"Your description here\")]</code></p> <p>If you have not used any attributes in your file previously, you may need to add the following using:</p> <p><code>using BH.oM.Reflection.Attributes;</code></p> <p>You may also need to add a reference to the <code>Reflection_oM</code> to your project if you have not previously used it.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasPublicGet/","title":"HasPublicGet","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasPublicGet/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasPublicGet/#details","title":"Details","text":"<p>The <code>HasPublicGet</code> check ensures that object properties have public <code>get</code> accessors. A property of a BHoM object which does not have a public <code>get</code> accessor will fail this check.</p> <p>For example, the following object definition will fail this check, because the <code>get</code> accessor does not exist.</p> <p><code>public double MyDouble { set; }</code></p> <p>This property will pass as a compliant property.</p> <p><code>public double MyDouble { get; set; } = 0.0</code></p> <p>This check is only operating on oM based objects. Objects within an <code>Objects</code> folder of an Engine (<code>Engine/Objects</code>) or Adapters are exempt from this check.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasSingleClass/","title":"HasSingleClass","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasSingleClass/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasSingleClass/#details","title":"Details","text":"<p>The <code>HasSingleClass</code> check ensures there is only one class declaration per <code>cs</code> file. This is designed to make the code easy to find and understand by people coming into BHoM for the first time.</p> <p>For example, a class which looks like the below, would be invalid and fail this check. There should only be one <code>class</code> declaration per file.</p> <pre><code>namesapce BH.Engine.Test\n{\n    public static partial class Query\n    {\n    }\n\n    public static partial class Compute\n    {\n    }\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasSingleNamespace/","title":"HasSingleNamespace","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasSingleNamespace/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasSingleNamespace/#details","title":"Details","text":"<p>The <code>HasSingleNamespace</code> check makes sure only one namespace is declared in a given file.</p> <p>For example, the file below would fail because it is declaring two namespaces within the file.</p> <pre><code>namespace BH.Engine.Test\n{\n}\n\nnamespace BH.Engine.Environment\n{\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasUniqueMultiOutputAttributes/","title":"HasUniqueMultiOutputAttributes","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasUniqueMultiOutputAttributes/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasUniqueMultiOutputAttributes/#details","title":"Details","text":"<p>The <code>HasUniqueMultiOutputAttributes</code> check ensures that a method returning a type of <code>Output&lt;t, ..., tn&gt;</code> has a matching number of <code>MultiOutput</code> attributes that have unique indexes.</p> <p>For example, a method returning <code>Output&lt;Panel, Opening&gt;</code> would require 2 uniquely indexed <code>MultiOutput</code> attributes to document both the <code>Panel</code> and the <code>Opening</code>.</p> <p>If the method looked like the below, while containing 2 <code>MultiOutput</code> attributes, would fail this check, because the index for both outputs cannot be <code>0</code>.</p> <pre><code>[MultiOutput(0, \"panel\")]\n[MultiOutput(0, \"opening\")]\npublic static Output&lt;Panel, Opening&gt; MyTestMethod()\n{\n}\n</code></pre> <p>The method should instead look like this:</p> <pre><code>[MultiOutput(0, \"panel\")]\n[MultiOutput(1, \"opening\")]\npublic static Output&lt;Panel, Opening&gt; MyTestMethod()\n{\n}\n</code></pre> <p>Where the index of the <code>MultiOutput</code> attributes is unique.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasUniqueOutputAttribute/","title":"HasUniqueOutputAttribute","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasUniqueOutputAttribute/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasUniqueOutputAttribute/#details","title":"Details","text":"<p>The <code>HasUniqueOutputAttribute</code> check ensures that there is only one <code>Output</code> or <code>MultiOutput</code> attribute per method. This is to avoid confusion caused by multiple <code>Output</code> or <code>MultiOutput</code> attributes unnecessarily.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidConstructor/","title":"HasValidConstructor","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidConstructor/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidConstructor/#details","title":"Details","text":"<p>The <code>HasValidConstructor</code> check ensures that any BHoM object which implements a constructor with parameters contains all of the parameters it requires to satisfy the Serialisation requirement.</p> <p>Constructors should only exist on objects implementing the <code>IImmutable</code> interface. Objects with this interface should have properties which are <code>get</code> only (no <code>set</code> accessor). All of these <code>get</code> only properties should be parameters to the constructor, with the parameter name matching the property name following the usual lowercase conventions for parameter names.</p> <p>Consider the following <code>IImmutable</code> object, which does not have a constructor.</p> <pre><code>public class MyObject : BHoMObject, IImmutable\n{\n    public virtual int MyInt { get; }\n    public virtual string MyString { get; }\n    public virtual Point MyPoint { get; set; }\n}\n</code></pre> <p>This object will not correctly deserialise, as it will not be able to adequately set the properties <code>MyInt</code> and <code>MyString</code>. Therefore, a constructor must be provided with the parameter names matching, so the deserialisation can correctly align the deserialised data to the object property.</p> <p>The property <code>MyPoint</code> does not have to be a parameter to the constructor, as it implements a <code>set</code> accessor. This is true for any property, including those inherited from the base <code>BHoMObject</code>.</p> <p>As such, a valid constructor would look like this:</p> <pre><code>public MyObject(int myInt, string myString)\n{\n    //Constructor logic\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidConstructor/#example-of-a-valid-object","title":"Example of a valid object","text":"<p>The entire class, in its valid form, would look like this:</p> <pre><code>public class MyObject : BHoMObject, IImmutable\n{\n    public virtual int MyInt { get; }\n    public virtual string MyString { get; }\n    public virtual Point MyPoint { get; set; }\n\n    public MyObject(int myInt, string myString)\n    {\n        //Constructor logic\n    }\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidConstructor/#example-of-an-invalid-object","title":"Example of an invalid object","text":"<p>If the constructor does not contain input parameters for all of the properties which implement only the <code>get</code> accessor, this will flag as a failure under this check. The following object is therefore incompliant, as only <code>MyInt</code> has a matching input parameter:</p> <pre><code>public class MyObject : BHoMObject, IImmutable\n{\n    public virtual int MyInt { get; }\n    public virtual string MyString { get; }\n    public virtual Point MyPoint { get; set; }\n\n    public MyObject(int myInt)\n    {\n        //Constructor logic\n    }\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidConstructor/#more-information","title":"More information","text":"<p>More information on the use of <code>IImmutable</code> interface within the BHoM can be found here.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidCopyright/","title":"HasValidCopyright","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidCopyright/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidCopyright/#details","title":"Details","text":"<p>The <code>HasValidCopyright</code> check ensures that all BHoM files licenced under LGPL v3.0 contain the correct copyright statement as their header.</p> <p>The BHoM copyright statement for BHoM files licenced under LGPL v3.0 can be found here.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidMultiOutputAttributes/","title":"HasValidMultiOutputAttributes","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidMultiOutputAttributes/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidMultiOutputAttributes/#details","title":"Details","text":"<p>The <code>HasValidMultiOutputAttributes</code> check ensures that a method returning a type of <code>Output&lt;t, ..., tn&gt;</code> has a matching number of <code>MultiOutput</code> attributes documenting the returned objects.</p> <p>For example, a method returning <code>Output&lt;Panel, Opening&gt;</code> would require 2 <code>MultiOutput</code> attributes to document both the <code>Panel</code> and the <code>Opening</code>.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidOutputAttribute/","title":"HasValidOutputAttribute","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidOutputAttribute/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidOutputAttribute/#details","title":"Details","text":"<p>The <code>HasValidOutputAttribute</code> check ensures that, if there is a piece of Output documentation is present on a method, that it is of a correct type.</p> <p><code>MultiOutput</code> documentation should only be used on methods providing multiple outputs using the return type of <code>Output&lt;t1, t2, ..., tn&gt;</code>, while <code>Output</code> documentation should be present on methods returning a single type.</p> <p>For example, the following two methods will fail this check because the documentation does not match the return types.</p> <pre><code>[Output(\"outputVariable\", \"My output documentation\")]\npublic static Output&lt;bool, string&gt; MyOutputMethod()\n{\n\n}\n</code></pre> <pre><code>[MultiOutput(0, \"outputVariable\", \"My output documentation\")]\npublic static bool MyOutputMethod()\n{\n\n}\n</code></pre> <p>These methods fail this check because the <code>MultiOutput</code> documentation is on a method returning a single type, while the <code>Output</code> documentation is on a method returning multiple results. For these methods to pass this check, they should look like this:</p> <pre><code>[MultiOutput(0, \"outputVariable\", \"My output documentation\")]\npublic static Output&lt;bool, string&gt; MyOutputMethod()\n{\n\n}\n</code></pre> <pre><code>[Output(\"outputVariable\", \"My output documentation\")]\npublic static bool MyOutputMethod()\n{\n\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidPreviousVersionAttribute/","title":"HasValidPreviousVersionAttribute","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidPreviousVersionAttribute/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HasValidPreviousVersionAttribute/#details","title":"Details","text":"<p>The <code>HasValidPreviousVersionAttribute</code> check ensures that, if there is a piece of versioning documentation present explaining what the previous version of a method or constructor was, the <code>FromVersion</code> is correct.</p> <p>The <code>FromVersion</code> for a <code>PreviousVersion</code> attribute should be set to the current milestone of development, with <code>PreviousVersion</code> attributes being removed at the end of the milestone in preparation for the next.</p> <p>If a <code>PreviousVersion</code> attribute has not been tidied up, it will be flagged by this check and should be removed in the Pull Request which captures it.</p> <p>If a <code>PreviousVersion</code> attribute has been added in that Pull Request, the <code>FromVersion</code> should match the current development milestone cycle.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HiddenInputsAreLast/","title":"HiddenInputsAreLast","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HiddenInputsAreLast/#summary","title":"Summary","text":"<p>Severity - Warning</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/HiddenInputsAreLast/#details","title":"Details","text":"<p>This check ensures that if you have set any <code>Input</code> attributes to have <code>UIExposure.Hidden</code>, they are the last parameters in the list of the method.</p> <p>This is because inputs which are being hidden from the UI are likely to be of a lower priority than those being displayed, and should not get higher precedence in the method signature, particularly when displaying the method to users.</p> <p>This is however just a warning, and final say will rest with the relevant maintainers of the repository.</p> <p>An example of the check failing is given below.</p> <pre><code>[Input(\"environmentObject\", \"Any object implementing the IEnvironmentObject interface that can have its tilt queried.\")]\n[Input(\"distanceTolerance\", \"Distance tolerance for calculating discontinuity points, default is set to BH.oM.Geometry.Tolerance.Distance.\", UIExposure.Hidden)]\n[Input(\"angleTolerance\", \"Angle tolerance for calculating discontinuity points, default is set to the value defined by BH.oM.Geometry.Tolerance.Angle.\")]\npublic static double SomeMethod(this IEnvironmentObject environmentObject, double distanceTolerance = BH.oM.Geometry.Tolerance.Distance, double angleTolerance = BH.oM.Geometry.Tolerance.Angle)\n{\n    return 0.0;\n}\n</code></pre> <p>In this example, the second <code>Input</code> attribute for <code>distanceTolerance</code> is setting the <code>UIExposure</code> to be <code>Hidden</code>, but the third method parameter, <code>angleTolerance</code>, does not have the same <code>UIExposure</code> (the default being <code>Display</code>). This would flag with this compliance check.</p> <p>To correct this, we can either set <code>angleTolerance</code> to also have a <code>UIExposure.Hidden</code>, or change the tolerances around so that <code>angleTolerance</code> comes before <code>distanceTolerance</code> in the argument list.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ImplementsRequiredMethods/","title":"ImplementsRequiredMethods","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ImplementsRequiredMethods/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p> <p>Check frequency - Nightly</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ImplementsRequiredMethods/#details","title":"Details","text":"<p>The <code>ImplementsRequiredMethods</code> check ensures that any object which implements an <code>IElement</code> interface is also implementing, or has access to, the required extension methods. Is an object does not have one of the required extension methods, then this check will report a failure for that object.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributeHasMatchingParameter/","title":"InputAttributeHasMatchingParameter","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributeHasMatchingParameter/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributeHasMatchingParameter/#details","title":"Details","text":"<p>The <code>InputAttributeHasMatchingParameter</code> check ensures that a given <code>Input</code> or <code>InputFromProperty</code> attribute has a matching input parameter on a method.</p> <p>This ensures that our documentation is accurate and valid for what users might see.</p> <p>For example, the following methods would fail this check because the input attribute does not match a given input parameter.</p> <pre><code>[Input(\"hello\", \"My variable\")]\npublic static void HelloWorld(double goodbye)\n{\n\n}\n</code></pre> <pre><code>[InputFromProperty(\"hello\")]\npublic static void HelloWorld(double goodbye)\n{\n\n}\n</code></pre> <p>The correct implementation should instead look like this:</p> <pre><code>[Input(\"hello\", \"My variable\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre> <pre><code>[InputFromProperty(\"hello\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributeIsUnique/","title":"InputAttributeIsUnique","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributeIsUnique/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributeIsUnique/#details","title":"Details","text":"<p>The <code>InputAttributeIsUnique</code> check ensures that there are not duplicate <code>Input</code> or <code>InputFromProperty</code> attributes for the same parameter.</p> <p>This ensures that our documentation is accurate and valid for what users might see.</p> <p>For example, the following methods would fail this check because the input attribute is duplicated</p> <pre><code>[Input(\"hello\", \"My variable\")]\n[Input(\"hello\", \"Also my variable\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre> <pre><code>[Input(\"hello\", \"My variable\")]\n[InputFromProperty(\"hello\")]\npublic static void HelloWorld(double hello, double goodbye)\n{\n\n}\n</code></pre> <p>The correct implementation should instead look like this:</p> <pre><code>[Input(\"hello\", \"My variable\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre> <pre><code>[Input(\"hello\", \"My variable\")]\n[InputFromProperty(\"goodbye\")]\npublic static void HelloWorld(double hello, double goodbye)\n{\n\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributesAreInOrder/","title":"InputAttributesAreInOrder","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributesAreInOrder/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputAttributesAreInOrder/#details","title":"Details","text":"<p>The <code>InputAttributesAreInOrder</code> check ensures that any <code>Input</code> or <code>InputFromProperty</code> attributes are in the same order as the input parameters for the given method.</p> <p>This ensures that our documentation is easy to follow for developets.</p> <p>For example, the following methods would fail this check because the input attribute not in the same order as the method input parameters.</p> <pre><code>[Input(\"hello\", \"My variable\")]\n[Input(\"goodbye\", \"Also my variable\")]\npublic static void HelloWorld(int goodbye, double hello)\n{\n\n}\n</code></pre> <pre><code>[Input(\"goodbye\", \"My variable\")]\n[InputFromProperty(\"hello\")]\npublic static void HelloWorld(double hello, double goodbye)\n{\n\n}\n</code></pre> <p>The correct implementation should instead look like this:</p> <pre><code>[Input(\"goodbye\", \"My variable\")]\n[Input(\"hello\", \"Also my variable\")]\npublic static void HelloWorld(int goodbye, double hello)\n{\n\n}\n</code></pre> <pre><code>[InputFromProperty(\"hello\")]\n[Input(\"goodbye\", \"My variable\")]\npublic static void HelloWorld(double hello, double goodbye)\n{\n\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputParameterStartsLower/","title":"InputParameterStartsLower","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputParameterStartsLower/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/InputParameterStartsLower/#details","title":"Details","text":"<p>The <code>InputParameterStartsLower</code> check ensures that method input variables (parameters) start with a lowercase letter.</p> <p>This example would fail this check, because the variable name starts with an uppercase character.</p> <p><code>public static void HelloWorld(double Hello)</code></p> <p>While this example will pass because the variable name starts with a lowercase character.</p> <p><code>public static void HelloWorld(double hello)</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsDocumentationURLValid/","title":"IsDocumentationURLValid","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsDocumentationURLValid/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsDocumentationURLValid/#details","title":"Details","text":"<p>The <code>IsDocumentationURLValid</code> check ensures that, if there is a documentation URL attribute on the code, that the URL provided can link to a valid web resource.</p> <p>If the check cannot load the URL (returning anything other than a 200 HTTP status code), this will return a fail. If the server is unavailable then this will return a fail and the check may need rerunning if external server availability affects the check.</p> <p>This check does not check the validity of the resource, only that the link provided can be used to access a valid web resource.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsExtensionMethod/","title":"IsExtensionMethod","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsExtensionMethod/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsExtensionMethod/#details","title":"Details","text":"<p>The <code>IsExtensionMethod</code> check makes sure that an engine method within a query, modify, or convert class is classed as an extension method to the first object type, providing the first object type is not a system type. Extension methods are made by using the <code>this</code> keyword prior to the declaration of the first input parameter. If a method does not take any inputs to operate, then it is exempt from this check.</p> <p>For example, the following method declaration will fail this check, because it is missing the <code>this</code> keyword before the first object:</p> <pre><code>public static bool MethodIsValid(Panel myPanel, Opening myOpening)\n{\n    return false;\n}\n</code></pre> <p>Whereas this method will pass the check, because the first parameter contains the <code>this</code> keyword to make the method an extension method.</p> <pre><code>public static bool MethodIsValid(this Panel myPanel, Opening myOpening)\n{\n    return false;\n}\n</code></pre> <p>Methods within the Compute and Create classes are exempt from this check.</p> <p>Files contained within an Engines <code>Objects</code> folder are exempt from this check (e.g. files with the file path <code>Your_Toolkit/Toolkit_Engine/Objects/Foo.cs</code> will be exempt).</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsExtensionMethod/#exempted-types","title":"Exempted types","text":"<p>System types are also exempt from this requirement. A list of the system types currently exempted is available here. If a system type is missing from this list, please feel free to raise a pull request to add it, or raise an issue for a member of the DevOps team to pick up.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsInputAttributePresent/","title":"IsInputAttributePresent","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsInputAttributePresent/#summary","title":"Summary","text":"<p>Severity - Warning</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsInputAttributePresent/#details","title":"Details","text":"<p>The <code>IsInputAttributePresent</code> check ensures that an input parameter has a matching <code>Input</code> or <code>InputFromProperty</code> attribute explaining what the input is required for users.</p> <p>You can add an <code>Input</code> attribute with the following syntax sitting above the method:</p> <p><code>[Input(\"variableName\", \"Your description here\")]</code></p> <p>Alternatively, if the methods returning object has a property which contains a description which matches the input parameter, you can use the <code>InputFromProperty</code> attribute with the following syntax:</p> <p><code>[InputFromProperty(\"variableName\")]</code></p> <p>Or, if your methods returning object has a property which contains a description which matches the input parameter, but the variable name entering the method is not named the same as the object's property, you can use the <code>InputFromProperty</code> to match the two, like so:</p> <p><code>[InputFromProperty(\"variableName\", \"objectPropertyName\")]</code></p> <p>If you have not used any attributes in your file previously, you may need to add the following using:</p> <p><code>using BH.oM.Reflection.Attributes;</code></p> <p>You may also need to add a reference to the <code>Reflection_oM</code> to your project if you have not previously used it.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsPublicClass/","title":"IsPublicClass","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsPublicClass/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsPublicClass/#details","title":"Details","text":"<p>The <code>IsPublicClass</code> check ensures that classes declared within files have the <code>public</code> modifier, rather than <code>private</code> or <code>internal</code>, etc.</p> <p>The following class declaration would fail because it does not give the <code>public</code> modifier.</p> <pre><code>namespace BH.Engine.Test\n{\n    static partial class Query\n    {\n    }\n}\n</code></pre> <p>Files contained within an Engines <code>Objects</code> folder are exempt from this check (e.g. files with the file path <code>Your_Toolkit/Toolkit_Engine/Objects/Foo.cs</code> will be exempt).</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsPublicProperty/","title":"IsPublicProperty","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsPublicProperty/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsPublicProperty/#details","title":"Details","text":"<p>The <code>IsPublicProperty</code> check ensures that object properties are public using the public modifier.</p> <p>The follow object property would fail this check because the modifier is set to private.</p> <p><code>private double MyDouble { get; set; } = 0.1;</code></p> <p>All BHoM object properties should be publicly accessible.</p> <p>This check is only operating on oM based objects. Objects within an <code>Objects</code> folder of an Engine (<code>Engine/Objects</code>) or Adapters are exempt from this check.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsStaticClass/","title":"IsStaticClass","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsStaticClass/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsStaticClass/#details","title":"Details","text":"<p>The <code>IsStaticClass</code> check ensures class declarations contain the <code>static</code> modifier.</p> <p>The following class declaration would fail because it does not give the <code>static</code> modifier.</p> <pre><code>namespace BH.Engine.Test\n{\n    public partial class Query\n    {\n    }\n}\n</code></pre> <p>Files contained within an Engines <code>Objects</code> folder are exempt from this check (e.g. files with the file path <code>Your_Toolkit/Toolkit_Engine/Objects/Foo.cs</code> will be exempt).</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsUsingCustomData/","title":"IsUsingCustomData","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsUsingCustomData/#summary","title":"Summary","text":"<p>Severity - Warning</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsUsingCustomData/#details","title":"Details","text":"<p>The <code>IsUsingCustomData</code> check highlights whether code written within the BHoM is utilising in any capacity the <code>CustomData</code> variable associated with all BHoMObjects.</p> <p><code>CustomData</code> is available for volatile data, useful for users within a Visual Programming environment to append data to an object that the object can carry around. However, this data is not designed to be relied upon within the code of toolkits or engines themselves.</p> <p>The use of Fragments is preferred for storing data being pulled from an external source, and would be the most appropriate replacement for <code>CustomData</code> in most instances of the code base. Some exceptions to this do occur however, and are treated on a case-by-case basis by the governance and CI/CD teams. It is advised to avoid using <code>CustomData</code> where ever possible in the first instance.</p> <p>More information on the reasons behind this can be found on this issue documenting the discussion behind this.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidConvertMethodName/","title":"IsValidConvertMethodName","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidConvertMethodName/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidConvertMethodName/#details","title":"Details","text":"<p>The <code>IsValidConvertMethodName</code> check ensures that <code>Convert</code> class methods are named correctly based on the guidance for BHoM development.</p> <p>The guidance, at the time of writing, states that <code>Convert</code> methods should go <code>To</code> their external software, and <code>From</code> their external software, rather than <code>ToBHoM</code> or <code>FromBHoM</code>.</p> <p>For example, this <code>Convert</code> method will fail:</p> <p><code>public static Span ToBHoM()</code></p> <p>While this one will pass:</p> <p><code>public static Span ToSoftware()</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidConvertMethodName/#naming-conventions","title":"Naming conventions","text":"<p>Although not a strict requirement, it is advised that convert method names reflect the software that the convert is going <code>to</code> or <code>from</code>. This helps make it clear what the external object model is and helps inform users of what to expect when using the convert method.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidCreateMethod/","title":"IsValidCreateMethod","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidCreateMethod/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidCreateMethod/#details","title":"Details","text":"<p>A create method name should meet the following conditions:</p> <ul> <li>If the return type matches the method name, the method name must match the filename and sit within the create folder (without any subfolders)</li> <li>e.g. a <code>Panel</code> object can sit within a file with the structure <code>Engine/Create/Panel.cs</code> in a method called <code>Panel</code></li> </ul> <p>If the above cannot be done, then:  - A sub-folder should be created which matches the return type, the method name must match the file name, and the method name should partially match the return type    - e.g. a <code>Panel</code> object can sit within a file with the structure <code>Engine/Create/Panel/EnvironmentPanel.cs</code> in a method called <code>EnvironmentPanel</code>    - A level of grouping/nesting is permitted when using the second option to help group create methods appropriately. This nesting is permitted up to two levels before it would become incompliant with the guidelines.      - e.g. a <code>Panel</code> object can fit within a file with the structure <code>Engine/Create/PlanarPanels/Panel/EnvironmentPanel.cs</code> or <code>Engine/Create/Panel/PlanarPanels/EnvironmentPanel.cs</code> - here we group the panels by <code>PlanarPanels</code>. Either option is compliant for the check to pass. Any further folders would however be incompliant.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidCreateMethodName/","title":"IsValidCreateMethodName","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidCreateMethodName/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidCreateMethodName/#details","title":"Details","text":"<p>This check is related to IsValidCreateMethod, however, this check ensures the method name matches the file name exactly.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidDataset/","title":"IsValidDataset","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidDataset/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidDataset/#details","title":"Details","text":"<p>Datasets should be stored as valid BHoM JSON objects within a <code>Dataset</code> folder of a repository/toolkit. Dataset files should contain only one serialised dataset object (from BH.oM.Data.Library.Dataset ).</p> <p>This test will take the JSON file and attempt to deserialise it back to a <code>Dataset</code> object. If the deserialisation fails, the error will be reported.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidDataset/#warnings","title":"Warnings","text":"<p>The check will also interrogate the source information for the dataset and ensure:</p> <ul> <li>That source information exists</li> <li>That an author has been provided for the source</li> <li>That a title has been provided for the source</li> </ul> <p>If any of these conditions is not met, a warning will be returned. A warning will not prohibit the Pull Request from being merged, but it may be prudent to address the issues to provide confidence in the source of the dataset.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidEngineClassName/","title":"IsValidEngineClassName","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidEngineClassName/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidEngineClassName/#details","title":"Details","text":"<p>The <code>IsValidEngineClassName</code> check ensures that any engine class is one of either <code>Create</code>, <code>Compute</code>, <code>Convert</code>, <code>Modify</code>, <code>Query</code>. Any engine file which does not create one of these classes will fail this check.</p> <p>Classes within the <code>Objects</code> folder of engines are not checked against this criteria.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidIImmutableObject/","title":"IsValidIImmutableObject","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidIImmutableObject/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidIImmutableObject/#details","title":"Details","text":"<p>The <code>IsValidIImmutableObject</code> check ensures that <code>IImmutable</code> objects contain at least one property which has only a <code>get</code> accessor (no <code>set</code> accessor).</p> <p>If an object has no properties which are <code>get</code> only, then the <code>IImmutable</code> interface should not be used.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsValidIImmutableObject/#more-information","title":"More information","text":"<p>More information on the use of <code>IImmutable</code> interface within the BHoM can be found here.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsVirtualProperty/","title":"IsVirtualProperty","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsVirtualProperty/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/IsVirtualProperty/#details","title":"Details","text":"<p>The <code>IsVirtualProperty</code> check ensures that object properties are using the <code>virtual</code> modifier.</p> <p>The follow object property would fail this check because the virtual modifier does not exist.</p> <p><code>public double MyDouble { get; set; } = 0.1;</code></p> <p>This property would pass this check because the virtual modifier has been set.</p> <p><code>public virtual MyDouble { get; set;} = 0.1;</code></p> <p>All BHoM object properties should be virtual to allow for easy extension.</p> <p>This check is only operating on oM based objects. Objects within an <code>Objects</code> folder of an Engine (<code>Engine/Objects</code>) or Adapters are exempt from this check.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/MethodNameContainsFileName/","title":"MethodNameContainsFileName","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/MethodNameContainsFileName/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/MethodNameContainsFileName/#details","title":"Details","text":"<p>The <code>MethodNameContainsFileName</code> check ensures that method names within Engine files (with the exception of <code>Create</code> methods) at least partially match the file name.</p> <p>For example, a method <code>BHoMTypeList()</code> can exist inside a file <code>TypeList.cs</code>, because the method name contains the file name. However, <code>BHoMTypeCollection()</code> would not be valid as <code>TypeList.cs</code> is not contained within the method name.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/MethodNameStartsUpper/","title":"MethodNameStartsUpper","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/MethodNameStartsUpper/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/MethodNameStartsUpper/#details","title":"Details","text":"<p>The <code>MethodNameStartsUpper</code> check ensures that method declarations start with an uppercase character.</p> <p>For example, the following method declaration would fail this check because the method name begins with a lowercase character.</p> <p><code>public static void helloWorld()</code></p> <p>While this one will pass because it starts with an uppercase character.</p> <p><code>public static void HelloWorld()</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ModifyReturnsDifferentType/","title":"ModifyReturnsDifferentType","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ModifyReturnsDifferentType/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ModifyReturnsDifferentType/#details","title":"Details","text":"<p>The <code>ModifyReturnsDifferentType</code> check ensures that <code>Modify</code> methods return either <code>void</code> or a different type to the first input. Methods returning <code>void</code> will be returning the first input parameter, modified by the method, to the user in a visual programming environment. Further information is available here and here.</p> <p>For example, the following method would fail because the return type is the same as the first input.</p> <p><code>public static Panel AddOpenings(this Panel panel)</code></p> <p>Whereas this method will pass because the return type is different from the input type.</p> <p><code>public static Opening AddOpenings(this Panel panel)</code></p> <p>And this method will pass because its return type is <code>void</code> and will return the first input object to the user in a visual programming environment.</p> <p><code>public static void AddOpenings(this Panel panel)</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ModifyReturnsSameType/","title":"ModifyReturnsSameType","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ModifyReturnsSameType/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ModifyReturnsSameType/#details","title":"Details","text":"<p>The <code>ModifyReturnsSameType</code> check ensures that <code>Modify</code> methods return the same type as the first input. This ensures that the modify methods are giving users back the same object type they're putting in.</p> <p>For example, the following method would fail because the return type is not the same as the first input.</p> <p><code>public static Opening AddOpenings(this Panel panel)</code></p> <p>Whereas this method will pass because the return type matches the input type.</p> <p><code>public static Panel AddOpenings(this Panel panel)</code></p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ObjectNameMatchesFileName/","title":"ObjectNameMatchesFileName","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ObjectNameMatchesFileName/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/ObjectNameMatchesFileName/#details","title":"Details","text":"<p>The <code>ObjectNameMatchesFileName</code> check ensures that object names match the file names provided. This check is for <code>object</code> classes only within an oM. This ensures that objects and code files match 1:1 for people looking for object definitions within oM projects.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PreviousInputNamesAttributeHasMatchingParameter/","title":"PreviousInputNamesAttributeHasMatchingParameter","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PreviousInputNamesAttributeHasMatchingParameter/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PreviousInputNamesAttributeHasMatchingParameter/#details","title":"Details","text":"<p>The <code>PreviousInputNamesAttributeHasMatchingParameter</code> check ensures that a given <code>PreviousInputNames</code> attribute has a matching input parameter on a method.</p> <p>This ensures that our documentation is accurate and valid for what users might see.</p> <p>For example, the following method would fail this check because the input attribute does not match a given input parameter.</p> <pre><code>[PreviousInputNames(\"hello\", \"notHello\")]\npublic static void HelloWorld(double goodbye)\n{\n\n}\n</code></pre> <p>The correct implementation should instead look like this:</p> <pre><code>[PreviousInputNames(\"hello\", \"notHello\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PreviousInputNamesAttributeIsUnique/","title":"PreviousInputNamesAttributeIsUnique","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PreviousInputNamesAttributeIsUnique/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PreviousInputNamesAttributeIsUnique/#details","title":"Details","text":"<p>The <code>PreviousInputNamesAttributeIsUnique</code> check ensures that there are not duplicate <code>PreviousInputNames</code> attributes for the same parameter.</p> <p>This ensures that our documentation is accurate and valid for what users might see.</p> <p>For example, the following method would fail this check because the input attribute is duplicated</p> <pre><code>[PreviousInputNamesAttributeIsUnique(\"hello\", \"notHello\")]\n[PreviousInputNamesAttributeIsUnique(\"hello\", \"alsoNotHello\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre> <p>The correct implementation should instead look like this:</p> <pre><code>[PreviousInputNamesAttributeIsUnique(\"hello\", \"notHello, alsoNotHello\")]\npublic static void HelloWorld(double hello)\n{\n\n}\n</code></pre>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/","title":"Project References and Build Paths","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#details","title":"Details","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#references","title":"References","text":"<p>In order to aid people working on BHoM repositories across multiple platforms, and to avoid conflict between BHoM DLLs, project references to other BHoM repositories (for example, the <code>Environment_oM</code> from BHoM itself, or the <code>Environment_Engine</code> from BHoM_Engine) need to be set to a certain path.</p> <p>This path should be to the <code>ProgramData</code> folder in the default drive of the machine. BHoM installs to the location <code>:/ProgramData/BHoM</code> folder, and all project files inside a toolkit have a postbuild event (see below) to copy their DLLs to the <code>:/ProgramData/BHoM/Assemblies</code> folder. By referencing DLLs in this location, it means people can install BHoM using an installer, clone a toolkit and begin developing without needing to clone and build the dependencies.</p> <p>Therefore, DLL references should be set to:</p> <p><code>$(ProgramData)/BHoM/Assemblies/TheDLL.dll</code></p> <p>For example, if we want to reference <code>Environment_oM</code> from BHoM, our project reference should look like:</p> <p><code>$(ProgramData)/BHoM/Assemblies/Environment_oM.dll</code></p> <p>If the project reference is set to a copy of the <code>Environment_oM</code> DLL from another location, there is a risk that the DLL will be out of date to the <code>main</code> and you could therefore be building on top of an out of date framework.</p> <p>If the project reference is not set to the example above, then this check will highlight that, and provide a suggestion of the path the DLL reference should have.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#exemptions","title":"Exemptions","text":"<p>References to DLLs within your own solution file should be made as Project References, rather than as DLL references.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#copy-local","title":"Copy Local","text":"<p>In order to prevent duplicate DLLs, some of which may be out of date, being placed in your repositories <code>Build</code> folder, and risk ending up in your Assesmblies folder run building <code>BHoM_UI</code>, the <code>copy local</code> property for all BHoM references should be set to <code>false</code>.</p> <p>This check will also ensure this and flag any DLLs which do not have their <code>copy local</code> property set to <code>false</code>.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#exemptions_1","title":"Exemptions","text":"<p>References can be set to <code>copy local true</code> if the project file is within the <code>.ci/unit-tests</code> folder path. DLLs referenced for NUnit unit tests require the DLLs to be copied locally and so this is valid.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#specific-version","title":"Specific Version","text":"<p>In order to prevent DLLs being locked to specific versions, some of which may be out of date, the <code>specific version</code> property for all BHoM references should be set to <code>false</code>.</p> <p>This check will also ensure this and flag any DLLs which do not have their <code>specific version</code> property set to <code>false</code>.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#build-folder","title":"Build Folder","text":"<p>In order to facilitate the above, a projects output folder should be set to <code>..\\Build\\</code> to put all DLLs from your solution file in the correct folder. The <code>Build</code> folder is where the BHoM_UI looks to take DLLs for the install process when building locally.</p> <p>This check will ensure that all build configurations (including Debug and Release) have their output folder path set to <code>..\\Build\\</code> and flag any instances where this is not correct.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#assembly-information","title":"Assembly Information","text":"<p>This section is only valid for projects utilising the new-style CSProject files, where an <code>AssemblyInfo.cs</code> file is not present. If an <code>AssemblyInfo.cs</code> file is present, then the compliance of this information can be found here.</p> <p>Each DLL should have suitable assembly information to support automated processes and confirming the version of the code which the DLL was built against. This includes these three items:</p> <ul> <li><code>&lt;AssemblyVersion&gt;</code></li> <li><code>&lt;FileVersion&gt;</code></li> <li><code>&lt;Description&gt;</code></li> </ul> <p>The <code>AssemblyVersion</code> should be set to the major version for the annual development cycle. This is set by DevOps, and will typically be a 4-digit number where the first number is the major version for the year, followed by three 0's - e.g. <code>5.0.0.0</code> for the 2022 development calendar (note, development calendars are based on release schedules as outlined by DevOps, not any other calendar system).</p> <p>The <code>FileVersion</code> should be set to the current development milestone, which is the major version followed by the milestone, followed by two 0's - e.g. <code>5.3.0.0</code> for the development milestone running from June-September 2022.</p> <p>The <code>Description</code> attribute should contain the full link to the repository where the DLL is stored, e.g. <code>https://github.com/BHoM/Test_Toolkit</code> for DLLs where the code resides in Test_Toolkit.</p> <p>At the start of each milestone, BHoMBot will automatically uptick the <code>AssemblyVersion</code> and <code>FileVersion</code> as appropriate, and set the <code>Description</code> if it was not previously set. However, if you add a new project during a milestone, BHoMBot will flag these items as incompliant if they have not been resolved prior to running the <code>project-compliance</code> check. These items can be fixed by BHoMBot if you request BHoMBot to fix the project information.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/Project-References-and-Build-Paths/#postbuild-events","title":"PostBuild events","text":"<p>In order to facilitate a projects DLL being placed in the <code>ProgramData</code> folder for development testing, each project within a <code>sln</code> file must have its own postbuild event for copying its DLL to the correct location.</p> <p>The postbuild event for this should be:</p> <p><code>xcopy \"$(TargetDir)$(TargetFileName)\"  \"C:\\ProgramData\\BHoM\\Assemblies\" /Y</code></p> <p>With nothing changed from the above example.</p> <p>If your toolkit relies on external libraries to run, then the relevant project must also provide the suitable postbuild event to copy those DLLs to the <code>ProgramData</code> folder as well.</p> <p>Similarly, if your toolkit has any datasets, then a suitable project within your toolkit must provide the suitable postbuild event to copy the datasets to the <code>C:/ProgramData/BHoM/Datasets</code> folder.</p> <p>BHoMBot is not able to provide any automatic fixes for this compliance item, but will highlight if it detects that it is inaccurate</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PropertyAccessorsHaveNoBody/","title":"PropertyAccessorsHaveNoBody","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PropertyAccessorsHaveNoBody/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/PropertyAccessorsHaveNoBody/#details","title":"Details","text":"<p>The <code>PropertyAccessorsHaveNoBody</code> check ensures that object property accessors do not have method bodies included with them.</p> <p>For example, the following object definition will fail this check, because the <code>get</code> accessor has a body.</p> <p><code>public double MyDouble { get { return 0.1; }; set; }</code></p> <p>Whereas this property will fail because the <code>set</code> accessor has a body.</p> <p><code>public double MyDouble { get; set { _val = value; }; }</code></p> <p>This property will pass as a compliant property.</p> <p><code>public double MyDouble { get; set; } = 0.0</code></p> <p>This check is only operating on oM based objects. Objects within an <code>Objects</code> folder of an Engine (<code>Engine/Objects</code>) or Adapters are exempt from this check.</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/UIExposureHasDefaultValue/","title":"UIExposureHasDefaultValue","text":""},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/UIExposureHasDefaultValue/#summary","title":"Summary","text":"<p>Severity - Fail</p> <p>Check method - Here</p>"},{"location":"DevOps/Code%20Compliance%20and%20CI/Compliance%20Checks/UIExposureHasDefaultValue/#details","title":"Details","text":"<p>This check ensures that if you have set any <code>Input</code> attributes to have <code>UIExposure.Hidden</code>, they have default values for the parameters.</p> <p>This is because inputs which are being hidden from the UI are unable to be given inputs by users, so suitable defaults must be provided if the input is to be hidden from a UI but accessible within code-use.</p> <p>An example of the check failing is given below.</p> <pre><code>[Input(\"environmentObject\", \"Any object implementing the IEnvironmentObject interface that can have its tilt queried.\")]\n[Input(\"distanceTolerance\", \"Distance tolerance for calculating discontinuity points, default is set to BH.oM.Geometry.Tolerance.Distance.\", UIExposure.Hidden)]\n[Input(\"angleTolerance\", \"Angle tolerance for calculating discontinuity points, default is set to the value defined by BH.oM.Geometry.Tolerance.Angle.\", UIExposure.Hidden)]\npublic static double SomeMethod(this IEnvironmentObject environmentObject, double distanceTolerance, double angleTolerance = BH.oM.Geometry.Tolerance.Angle)\n{\n    return 0.0;\n}\n</code></pre> <p>In this example, the second <code>Input</code> for <code>distanceTolerance</code> does not have a default value set, while <code>angleTolerance</code> does.</p> <p>To correct this, we need to give a default value to <code>distanceTolerance</code>, or remove the desire to have <code>UIExposure.Hidden</code> on the input.</p>"},{"location":"DevOps/Development%20Cycle/","title":"Introduction to the Development Cycle","text":"<p>This section outlines the development cycle used by the BHoM Community in preparing, producing, and delivering the BHoM package to the world.</p>"},{"location":"DevOps/Development%20Cycle/#milestones","title":"Milestones","text":"<p>Our development cycle works to delivery milestones - where the end of each milestone we release a new beta product of our codebase. These milestones are divided into the year by the DevOps team and aims to provide regular releases to the world that can be depended upon. Because the majority of our tools are delivered for the AEC industry, which relies on solid tools to perform their work, we aim to ensure our deployments are regular enough to be depended upon, but not so often that they might not contain robust changes that people can track. Thus, we develop in milestone cycles.</p> <p>Currently 1 milestone is 12 weeks long, with 4 milestones per calendar year. The astute among you will know that 4 * 12 is 48 weeks and not 52 as a traditional calendar year contains. The remaining 4 weeks are divided up across the year to provide planning weeks between milestones, and allow for downtime between milestones. We are aware of the risk of continuous cycles of development within our community, and the risk that poses to burn out and other adverse mental health effects on our community. Therefore we aim to deliberately place blocks of time when we are not activiely developing to our code base (unless individuals personally wish to) and instead taking time to reflect, plan, and regroup before tackling another milestone. We encourage our community members to have breaks (for themselves (it's always good to have a holiday!), and for their mental/physical health) as they find appropriate, but we have also realised we can support the culture of taking rest time by encoding it into our development cycles.</p> <p>Each milestone is referred to by 2 numbers, in an <code>x.y</code> format. The <code>x</code> number refers to the major year we are developing for. You can therefore identify the year a development occurred by this number, and the table below gives a reference of historic milestone years. The <code>y</code> number refers to the sub-milestone within the calendar year we are developing for, therefore allowing us to identify the quarter in which development took place.</p> <p>As a development community, we are always developing one milestone in advance of what the end-users might be seeing. The end of each milestone becomes our beta release for that quarter, so the development community is always working for 12 weeks on a milestone to culminate in its delivery. This might cause some confusion, because the <code>x.0</code> milestone is typically October-December of a given year, and not January-March as some might expect (as the first milestone of the major year). However, when you see that the <code>x.0</code> beta is delivered at the end of December/early January to the world, it makes more sense (hopefully) - the users get to start the year on version <code>x.0</code>.</p> <p>Once one milestone is over and the beta is produced (in line with our end of milestone procedures), we move into the next milestone. See our Operating Procedures for more information on what occurs at the start and end of a milestone.</p>"},{"location":"DevOps/Development%20Cycle/#sprints","title":"Sprints","text":"<p>Each milestone is broken up into 6 development sprints, with each sprint lasting 2 weeks. This is longer than traditional software development sprints, but accounts for our community being mostly voluntary, with members typically working in the AEC industry and delivering projects alongside contributing to our community. Therefore, we don't want to push too much pressure on our development community to try to deliver enhancements to our tools on a weekly basis when things could quickly become stressful by unexpected life events! Thus, we conduct fortnightly sprints.</p> <p>Each sprint comprises 2 calendar weeks from a Monday to the Sunday 14 days later.</p> <p>Each sprint can have its own objectives depending on the team. For example, the DevOps team regularly chunk sprints into sprints that focus on our procedures, or on our bots, or on other aspects of our workload. This makes it easier for everyone to keep track of what's going on. Other teams just do development with no fixed objective other than to meet their milestone goals, and that's perfectly ok too - each team is different and we all contribute in different ways.</p> <p>The numbering of the sprints is from 1-6 inclusive (for human readability as opposed to computing 0-5 readability). Where a planning sprint may be placed, this will be referred to either as <code>Planning Sprint</code> or sprint 0 if absolutely necessary.</p> <p>The final sprint of the milestone is typically reserved for bug fixing, compliance issues, and preparing for the release of the beta for that milestone.</p>"},{"location":"DevOps/Development%20Cycle/#discussion","title":"Discussion","text":"<p>As always, we welcome discussion on our calendars if you have any suggestions or queries!</p>"},{"location":"DevOps/Development%20Cycle/#historic-milestones","title":"Historic Milestones","text":"<p>All betas listed here were released at the end of their span.</p> Milestone Year Span 2.3 2019 July - September 3.0 2019 September - December 3.1 2020 January - March 3.2 2020 April - June 3.3 2020 July - September 4.0 2020 September - December 4.1 2021 January - March 4.2 2021 April - June 4.3 2021 July - September 5.0 2021 September - December 5.1 2022 January - March 5.2 2022 April - June 5.3 2022 July - September 6.0 2022 September - December 6.1 2023 January - March 6.2 2023 April - June 6.3 2023 July - September 7.0 2023 September - December"},{"location":"DevOps/Development%20Cycle/2022/","title":"2022","text":""},{"location":"DevOps/Development%20Cycle/2023/","title":"2023","text":""},{"location":"DevOps/Development%20Cycle/2024/","title":"2024","text":""},{"location":"DevOps/Development%20Cycle/2026/","title":"2026","text":"<p>This page outlines the BHoM development sprint schedule for 2026. Our development cycle follows a quarterly release cadence with six two-week sprints per quarter, preceded by a planning week.</p> <p></p>"},{"location":"DevOps/Development%20Cycle/2026/#release-schedule-overview","title":"Release Schedule Overview","text":"Release Planning Week Sprint Period Beta Release v9.1 Dec 29, 2025 \u2013 Jan 9 Jan 12 \u2013 Apr 3 April 2026 v9.2 Apr 6 \u2013 Apr 10 Apr 13 \u2013 Jul 3 July 2026 v9.3 Jul 6 \u2013 Jul 10 Jul 13 \u2013 Oct 2 October 2026 v10.0 Oct 5 \u2013 Oct 9 Oct 12 \u2013 Jan 1, 2027 January 2027"},{"location":"DevOps/Development%20Cycle/2026/#q1-2026-release-v91","title":"Q1 2026 \u2014 Release v9.1","text":"<p>Planning Week: December 29, 2025 \u2013 January 9, 2026</p> Sprint Start End Sprint 1 Jan 12 Jan 23 Sprint 2 Jan 26 Feb 6 Sprint 3 Feb 9 Feb 20 Sprint 4 Feb 23 Mar 6 Sprint 5 Mar 9 Mar 20 Sprint 6 Mar 23 Apr 3"},{"location":"DevOps/Development%20Cycle/2026/#q2-2026-release-v92","title":"Q2 2026 \u2014 Release v9.2","text":"<p>Planning Week: April 6 \u2013 April 10, 2026</p> Sprint Start End Sprint 1 Apr 13 Apr 24 Sprint 2 Apr 27 May 8 Sprint 3 May 11 May 22 Sprint 4 May 25 Jun 5 Sprint 5 Jun 8 Jun 19 Sprint 6 Jun 22 Jul 3"},{"location":"DevOps/Development%20Cycle/2026/#q3-2026-release-v93","title":"Q3 2026 \u2014 Release v9.3","text":"<p>Planning Week: July 6 \u2013 July 10, 2026</p> Sprint Start End Sprint 1 Jul 13 Jul 24 Sprint 2 Jul 27 Aug 7 Sprint 3 Aug 10 Aug 21 Sprint 4 Aug 24 Sep 4 Sprint 5 Sep 7 Sep 18 Sprint 6 Sep 21 Oct 2"},{"location":"DevOps/Development%20Cycle/2026/#q4-2026-release-v100","title":"Q4 2026 \u2014 Release v10.0","text":"<p>Planning Week: October 5 \u2013 October 9, 2026</p> Sprint Start End Sprint 1 Oct 12 Oct 23 Sprint 2 Oct 26 Nov 6 Sprint 3 Nov 9 Nov 20 Sprint 4 Nov 23 Dec 4 Sprint 5 Dec 7 Dec 18 Sprint 6 Dec 21 Jan 1, 2027"},{"location":"DevOps/Development%20Cycle/2026/#sprint-cadence","title":"Sprint Cadence","text":"<p>Each development cycle follows a consistent structure:</p> <ul> <li>Planning Week \u2014 Backlog refinement, sprint planning, and alignment across teams</li> <li>Sprints 1\u20136 \u2014 Two-week development sprints with defined deliverables</li> <li>Beta Release \u2014 End of cycle release for testing and validation</li> </ul> <p>All sprints run Monday through Friday. Sprint boundaries align to facilitate coordination across our global contributor network.</p>"},{"location":"DevOps/Development%20Cycle/2026/#questions","title":"Questions?","text":"<p>For questions about the development schedule or contributing to an upcoming sprint, reach out via the BHoM Slack or open a discussion on GitHub.</p>"},{"location":"DevOps/Operating%20Procedures/","title":"Introduction to our Operating Procedures","text":"<p>The section outlines the operating procedures under which the DevOps Team work. It oulines our playbooks, our procedures, our prototcols, and other aspects of DevOps decision making.</p> <p>This content is made available so that our way of working is transparent and everyone can work together to achieve our common goals within the BHoM Community. Is is part of the BHoM DevOps strategy that</p> <p>The purpose of DevOps is to support, not hinder</p> <p>And this is achieved best when everyone can understand the tasks being undertaken.</p>"},{"location":"DevOps/Operating%20Procedures/#changes-to-our-procedures","title":"Changes to our procedures","text":"<p>Our operating procedures are reviewed periodically by the DevOps Team who will make changes as appropriate as our development objectives and outcomes change. Typically, unless there is a drastic emergency requirement to update our operating procedures instantly, any changes made to our operating procedures are done to come into effect from the start of the next development milestone. That is, if an operating procedure changes during sprint 2 of a milestone, the changes made will not come into effect until the planning sprint of the following milestone (10 weeks later) unless there is an urgent reason to implement them sooner. As such, you may find some operating procedures have a section saying</p> <p>With effect from Milestone x.y</p> <p>And a section which might make changes to the original text in the procedure document. Where such areas exist, they will take precedence over existing documents until the documentation is amended to incorporate the changes properly once in effect.</p> <p>## Discussing changes</p> <p>Some changes will be put up for discussion while others may just be changed on the procedure document. It is down to the DevOps team to decide what is most appropriate, however, they should err on the side of public discourse being the preferred option.</p> <p>Anyone is free to raise discussions about changes if the DevOps team does not do so themselves.</p>"},{"location":"DevOps/Operating%20Procedures/#discussing-procedures","title":"Discussing procedures","text":"<p>Discussions about the procedures as a whole is also welcomed, including questions, queries, and suggestions - please feel free to jump over to the discussions page and get involved!</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/","title":"Beta Patching","text":"<p>The contents of this page detail the actions to be undertaken in the event of a desire to provide a patch to a beta release. These procedures may be updated at any point.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#1-related-documents","title":"1 - Related documents","text":"<p>The following documents are not considered part of this procedure, but contain additional information which may be beneficial. It is recommended these are read in conjunction with this document.</p> <ul> <li>Beta testing procedure</li> <li>Producing a beta installer guide</li> </ul>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#2-activation-of-this-procedure","title":"2 - Activation of this procedure","text":"<p>Activation of this procedure is done by DevOps at any time that a repository included in the beta installer receives a bug fix to its <code>main</code> branch outside of the final sprint of a milestone, or where one or more repositories may have not been included in the initial release where more testing may have been required.</p> <p>If the development cycle is currently in the final sprint of a milestone, then a beta patch cannot be produced as a new beta is being created, and the bug fix should be dispatched for that beta instead.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#3-procedure-for-patching-missing-repositories","title":"3 - Procedure for patching - missing repositories","text":"<p>Where a repository has not made the initial beta due to issues with testing and the pull request from <code>develop</code> into <code>main</code> has been closed, this pull request will be reopened and undergo the standard testing and review procedure. Once the Pull Request is merged, DevOps will then carry out the following functions.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#4-procedure-for-patching-bug-fixes","title":"4 - Procedure for patching - bug fixes","text":"<p>A new branch from <code>main</code> for the repository to be patched should be made, with code written to resolve the bug and reviewed via a Pull Request in the usual manner without circumventing the standard code review procedures. The Pull Request must be tested thoroughly, ideally against any existing test procedure for that repository where available. Where a test procedure is not available, it is the Discipline Code Lead who is responsible for signing off on the Pull Request. Once the Pull Request is merged, DevOps will then carry out the following functions.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#41-patching-develop","title":"4.1 - Patching <code>develop</code>","text":"<p>The same branch (if not deleted) can be used to patch <code>develop</code> as well and ensure the bug fix is in both branches so alphas aren't affected either. Thie pull request can be handled in the usual fashion as it will be going into <code>develop</code> as part of that milestone and not need any special support. However, it is important that the bug fix is put into <code>develop</code> to prevent the patch being needed again at the end of the milestone when <code>develop</code> is merged into <code>main</code>.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#5-preparing-the-patch","title":"5 - Preparing the patch","text":"<p>The following actions must be undertaken to prepare the beta patch.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#51-change-log-update","title":"5.1 - Change log update","text":"<p>DevOps responsible for generating an updated change log for the patched beta to include the change being fixed.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#52-create-the-tag-on-the-repository","title":"5.2 - Create the tag on the repository","text":"<p>DevOps is responsible for tagging the repository with the appropriate patch number.</p> <p>Should the patch number be required, the patch number should always be 1 greater than the most recent patch number. For example, if a beta patch has previously been generated on a different repository (thus making the current beta version Vx.y.b.1) then the beta patch for this repository will become Vx.y.b.2 even if this repository does not have a Vx.y.b.1 patch itself.</p> <p>An important note to make, is the <code>TargetCommit</code> must be set to <code>main</code> to target the <code>main</code> branch - otherwise it will default to target the default branch (which is <code>develop</code> for beta repositories). This will cause issues if not set and other work is committed to <code>develop</code> before the tags are completed.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#53-produce-the-beta-installers","title":"5.3 - Produce the beta installers","text":"<p>Full details of producing a beta installer can be found in the Producing a Beta Installer guide.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#54-testing-the-beta-installer","title":"5.4 - Testing the beta installer","text":"<p>DevOps is responsible for deciding the scope of testing the patched beta artefact. Where there is any doubt as to the potential scope of changes produced by the patch, a full beta test should be conducted, as per the guidelines in this procedure.</p> <p>Where the scope of testing can be clearly defined, the Discipline Lead of the affected repository is responsible for reporting back on successful use of the beta patch artefact, using all available test procedures. This work may be delegated down as appropriate to other developers and users, but the Discipline Code Lead takes final responsibility for reporting back.</p> <p>The testing of the beta patch artefact should be a matter of priority, and the DevOps lead and Discipline Code Lead should remain in regular contact to ensure the results are reported back ASAP. Ideally this should be completed by the end of the next business day at the latest.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#55-releasing-the-beta-installer","title":"5.5 - Releasing the beta installer","text":"<p>This is to be done in line with the release of a standard beta, the procedure for which can be found here.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20patching%20procedure/#6-external-website","title":"6 - External website","text":"<p>The BHoM.xyz website should be updated as appropriate, including new API updates were applicable.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/","title":"Beta Testing","text":"<p>The contents of this page detail the actions to be undertaken, with approximate timings, at the end of a Milestone to test the Beta installers in the lead up to the release of that Milestones beta. These procedures may be updated at any point. This document forms part of the End of Milestone Procedure.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#1-purpose","title":"1 - Purpose","text":"<p>The purpose of this test procedure is to ensure that all aspects of the Beta installers are checked in the lead up to the production of the Beta installer. The outcome of this procedure is to give confidence to those using the Beta that the toolkits and operations will work as designed.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#2-scope","title":"2 - Scope","text":"<p>The scope of testing is restricted to elements of the installer most likely to impact use of the installers. It is not designed to sign off as a complete bug-free installer, however, the state of the Beta should not be worse than that of its previous version. This ensures that each Beta trends towards a more positive setting with each release.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#3-running-tests","title":"3 - Running tests","text":"<p>Each discipline lead is responsible for ensuring suitable, adequate, and reasonable tests are conducted on each of the toolkits within their group. These tests should be run as often as possible during a milestone, but are strictly monitored during the final sprint of a milestone.</p> <p>During the final sprint, a discipline lead must ensure they, or a suitable member of their team, carries out an adequate test of each toolkit using a given Beta installer. Building from source is not permitted for these tests, as the purpose is to ensure the final Beta installer is fit for purpose.</p> <p>It is advised that testing utilises the formal test procedures where applicable to make the process of testing and verifying the code base easier, as test procedures should capture the core functionality. Where a test procedure does not exist, it is the responsibility of the discipline lead to ensure suitable testing is carried out.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#31-test-reports","title":"3.1 - Test Reports","text":"<p>Each day during the final sprint, the DevOps Lead or their appointed deputy is responsible for collating the test reports. Test reports should confirm what toolkits have been tested, whether any toolkits have been exempted (see below), and any issues that have been found. It is the responsibility of each Discipline Lead to provide accurate information upon request on the state of their testing.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#32-fixing-issues","title":"3.2 - Fixing issues","text":"<p>It is the responsibility of each Discipline Lead to triage issues found as a result of testing. Any bug which did not exist in the previous Beta should be prioritised, following standard best practice for issue management generally. Bugs which existed in the previous Beta should not be prioritised during this period (though may be triaged and resolved if there are no other issues).</p> <p>As a rule of thumb, the following hierarchy should apply when triaging issues for resolution during the final sprint (in order from most important to least).</p> <ul> <li>Issues which impact the delivery of the Beta installer should be prioritised.</li> <li>Issues which impact the Core Framework or UIs and User Experience (UX)</li> <li>Issues which impact multiple toolkits but are not classified as Core Framework (e.g, an issue which impacts all Structural Adapters)</li> <li>Issues which were not present in the previous Beta</li> <li>Issues which were present in the previous Beta</li> </ul> <p>Guidance and support on issue triaging can be obtained from the Governance and DevOps teams.</p> <p>Discipline leads are responsible for ensuring they have adequate resource to resolve issues found, including reviewing the Pull Requests, and subsequent re-tests.</p> <p>If an issue is resolved with the approval of DevOps, and merged to the repository's <code>develop</code> branch, DevOps will reproduce the Pull Request which merges <code>develop</code> into <code>main</code> to include this additional fix.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#33-exceptions","title":"3.3 - Exceptions","text":"<p>It may be appropriate for a toolkit to not receive testing every day during the final sprint, providing the following criteria can be met.</p> <ol> <li>The Discipline Lead, along with any relevant Toolkit Lead or key stakeholder, is satisfied that the code base contained within that Toolkit is isolated to changes made in the core</li> <li>The core for that toolkit on which it depends has not changed since the last test</li> <li>There have been no Pull Requests merged on that toolkit since the last test</li> </ol> <p>The Discipline Lead of the toolkits concerned may consult with other relevant stakeholders, including other Discipline Leads, however, the final responsibility for testing, or skipping, a toolkit resides with the Discipline Lead. It is recommended that should any of the criteria above not be met, that the toolkit undergo a subsequent retest.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#4-merging-develop-into-main","title":"4 - Merging <code>develop</code> into <code>main</code>","text":"<p>Once suitable testing has been conducted on the Pull Request which is aimed to be deployed in the Beta, the testers must comment with suitable approving reviews. The Discipline Code Lead must then inform DevOps that the Pull Request is ready to be merged, and DevOps will then merge the Pull Request for deployment if it is deemed appropriate to do so. Instances where it may not be appropriate to merge a Pull Request include if the Pull Request is depending on code in a higher repository (for example BHoM_Engine) that has not yet been merged. In these cases the Pull Request may have to wait, and may risk not being included if the higher repository Pull Request is not subsequently deployed.</p>"},{"location":"DevOps/Operating%20Procedures/Beta%20testing%20procedure/#5-final-beta-test","title":"5 - Final Beta test","text":"<p>After the creation of the Beta artefact, the Beta must be signed off by each Discipline Lead. The Beta must be tested against all available Test Procedures for code residing within the installer. Additional tests are allowed, but cannot be used as substitutions to the test procedures. Where a test procedure does not exist, the Discipline Lead is responsible for ensuring adequate and suitable testing is performed for that area of code.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/","title":"End of milestone","text":"<p>The contents of this page detail the actions to be undertaken at the end of a given Milestone. These procedures may be updated at any point.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#related-documents","title":"Related documents","text":"<p>The following documents are considered part of this procedure, and contain more in-depth details about specific aspects. It is recommended these are read in conjunction with this document.</p> <ul> <li>Beta testing procedure</li> <li>Producing a beta installer guide</li> <li>Preparing a new Milestone</li> </ul>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#1-scope","title":"1 - Scope","text":"<p>The scope of this document is restricted to the end of a development Milestone as decided by DevOps.</p> <p>Interpretation of this procedure rests with the DevOps Lead or their nominated individual.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#2-events","title":"2 - Events","text":""},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#21-final-sprint-begins","title":"2.1 - Final Sprint Begins","text":"<p>The final sprint is placed under <code>feature-freeze</code> whereby any code which matches the definition of a <code>feature</code> is blocked from being merged into the beta code. Clarifications on what constitutes a <code>feature</code> can be sought from the DevOps Team.</p> <p>During the final sprint, all development should be done against the daily test artefacts, and all members of the development teams should be installing the daily artefacts to evaluate the effectiveness of code developed during that milestone. This is to help avoid situations of bugs being found only in the final beta that exist within the alphas and test artefacts, but may not be visible when building code from source.</p> <p>Development teams are responsible for ensuring their developers undertake this practice, and core users within their teams should also begin moving from the previous beta to new alphas and test artefacts in this sprint to aid the testing process. Discipline leads may be asked to confirm certain progress reports of testing during this phase.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#22-beta-test-procedure-takes-effect","title":"2.2 - Beta Test Procedure takes effect","text":"<p>The Beta Test Procedure is outlined in this document and will be followed in accordance with the above statement regarding developing against the Beta installers. The DevOps team will oversee this operation during the lifecycle of the final sprint.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#23-develop-into-main","title":"2.3 - <code>develop</code> into <code>main</code>","text":"<p>All repositories which are set to be included in the Beta must have Pull Requests raised to merge the code which has been developed during the milestone from their respective <code>develop</code> branches into their <code>main</code> branches for deployment.</p> <p>New branches must be made from the <code>develop</code> branch and a Pull Request raised for each repository as appropriate. Each Pull Request will require a review and test prior to merging into <code>main</code> and deploying in the Beta. This Pull Request should be raised by someone within the DevOps team. Once the Pull Requests are raised, the BHoMBot command <code>@BHoMBot check beta-status</code> should be triggered for each Pull Request. This will provide an initial report on the impact of each individual Pull Request to aid merging decision making.</p> <p>The branch name must be suitable and unique for the milestone as this will form the Beta Test Branch for BHoMBot installer payloads when generating test installers during the final sprint.</p> <p>Each Pull Request must be reviewed and signed off by the relevant testers as determined by each Discipline Code Lead prior to it being merged to <code>main</code>. Where a Pull Request is dependant on upstream changes (e.g. a Toolkit depending on a BHoM_Engine change), the upstream changes must be prioritised for testing and review, even if the Toolkit Pull Request does not then get merged.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#24-pull-request-lock-down","title":"2.4 - Pull Request lock down","text":"<p>Pull Request lock down will be put into effect once the Pull Requests for merging <code>develop</code> into <code>main</code> have been raised. No Pull Request may be merged into a repository that is included in the Beta without approval from DevOps.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#25-final-merging-of-develop-into-main","title":"2.5 - Final merging of <code>develop</code> into <code>main</code>","text":"<p>The deadline for the final merging of any Pull Request aiming to deploy code to the beta will be announced by DevOps at the start of the final sprint, but will not be later than 9am on the day of the artefact being produced.</p> <p>Once this deadline has passed, any Pull Requests not yet merged for deployment will be closed and their changes will not be deployed in the Beta. They may be deployed in future Betas if subsequent milestones merge <code>develop</code> into <code>main</code>. The code will not be lost, as it will continue to reside on the <code>develop</code> branch and will continue through into the next milestone.</p> <p>If a Toolkit requires alignment updates to compile and deploy, a separate Pull Request will be raised by DevOps which performs this alignment with no further changes incorporated.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#26-tagging","title":"2.6 - Tagging","text":"<p>Each repository included in the beta must be tagged at the commit latest to <code>main</code> for the version being produced.</p> <p>An important note to make, is the <code>TargetCommit</code> must be set to <code>main</code> to target the <code>main</code> branch - otherwise it will default to target the default branch (which is <code>develop</code> for beta repositories). This will cause issues if not set and other work is committed to <code>develop</code> before the tags are completed.</p> <p>The installer repository should also be tagged to correspond to the version of the installer at the time the beta was produced.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#27-change-log-creation","title":"2.7 - Change Log Creation","text":"<p>The Change Log is prepared by a member of the DevOps team using the authorised script. The Change Log should encompass every pull request merged during the milestone to the <code>main</code> branch for deployment, from every repository included within the installer.</p> <p>The following checks must be done as part of the Change Log Creation:  - That all repositories included in the installer are present and correctly pulling PR information  - That the grouping categories are correctly set  - Toolkits are correctly included change logs as appropriate</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#28-prepare-release-notes-script","title":"2.8 - Prepare release notes script","text":"<p>The Release Notes script puts a release tag onto the <code>main</code> branches of repositories included within the installer. The release notes are prepared by a member of the DevOps team using the authorised script. The release notes should follow the standard for BHoM releases.</p> <p>The following checks must be done as part of the Release Notes preparation:  - The release notes title is accurate  - The release notes themselves are accurate  - The release notes script can successfully produce a release note on a CI Test repository</p> <p>Authorisation for the execution of the script during this preparation and testing phase resides with the DevOps team.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#29-dispatch-release-notes","title":"2.9 - Dispatch release notes","text":"<p>A manual release is to be made of the BHoM_Documentation repository. These releases are to contain their correct titles, but their bodies may be left blank while the change log is produced.</p> <p>The release notes body in the release notes script is to be double checked to ensure the link to documentation release notes is accurate for the given repository status.</p> <p>The release notes script is then to be used to tag the releases across all repositories included within the installer.</p> <p>Once the appropriate change logs are prepared, these should be edited into the release notes on the documentation repositories.</p> <p>Authorisation for final execution of the script resides with the Governance team.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#210-produce-beta-installer","title":"2.10  - Produce beta installer","text":"<p>Full details of producing a beta installer can be found in the Producing a Beta Installer guide.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#211-release-beta-installer-for-testing","title":"2.11 - Release beta installer for testing","text":"<p>The beta installer should be released to the key individuals responsible for toolkits across the organisations for testing. Testing should ensure their toolkits show up correctly, and work as intended for the given release. This testing is a final review, with testing of functionality ideally done during the final sprint using daily alphas.</p> <p>The discipline team leads are responsible for reporting back to the DevOps team their approval of the installer. The installer may be tested overnight to allow a broad testing regime globally. The method of approval will be determined at the time of release, but is likely to include public confirmation via Teams or other appropriate channels. Discipline leads are responsible for ensuring the code which sits within their remit is approved appropriately. They will be called upon to assist in any bug fixes which may be found with the beta installer to ensure timely resolutions.</p> <p>The release should be made public on appropriate collaboration channels.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#212-accepting-or-rejecting-the-beta","title":"2.12 - Accepting or Rejecting the Beta","text":"<p>Following the final testing and reporting back to the DevOps Team, a final judgement will be made as to whether the beta should be released to the public. If the testing is inadequate, or there are significant issues that may be caused by the release of the beta, then the beta may be rejected. Any person may petition for a beta to be rejected if they feel it would be prudent to do so, however, the final decision to accept or reject the beta resides with the DevOps Team.</p> <p>If the beta is to be released, then the milestone will be closed out in accordance with the remainder of this procedure.</p> <p>If the beta is not to be released, then one of the following scenarios may be undertaken.</p> <ul> <li>The beta testing period is extended</li> <li>The beta is abandoned</li> </ul> <p>If the beta testing period is to be extended, this should be announced on appropriate communications channels, detailing the reasons for extending the testing period and the new timelines to be followed. The timelines to be followed will be determined by the DevOps Team as an appropriate judgement call based on the situation. If an extended testing period is required, the time taken to complete the testing protocols will count as part of the milestone in which the beta was due to be delivered. The subsequent milestone will be shortened appropriately to accommodate this, in chunks no shorter than whole sprints. For example, if week 1 of the new milestone is given to the previous milestone to extend beta testing, week 2 of the new milestone will be converted into a downtime week, and the new milestone will begin in week 3. In this example, the new milestone will then be 10 weeks long and will reduce by 1 feature sprint. If the subsequent milestone does not need to be affected by a testing extension then the new milestone will start as planned in week 1 and not be reduced.</p> <p>If the beta is to be abandoned, the milestone will be closed out in accordance with the remainder of this procedure, with the exception of communications regarding the release of the artefact. Appropriate communications will be made explaining the situation and outlining when a new beta will be planned to be made available at the end of the next milestone.</p> <p>Abandoning the beta should not be a decision taken lightly, and all efforts should be made to ensure a beta delivery for a milestone. A late delivery is preferred over no delivery.</p> <p>It is not appropriate to deliver a partial beta, owing to the interconnected workings of many toolkits which sit in different disciplines, and the versioning constraints which would require large work to be undertaken to temporarily remove items from the beta at that stage.</p> <p>Until a beta is released, or the milestone is closed out in the event of abandoning a beta, the pull request freeze remains in effect, unless otherwise decided by the DevOps Team.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#213-close-milestone","title":"2.13 - Close milestone","text":"<p>The milestone should be closed and the GitHub milestones updated to reflect the new development periods.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#214-prepare-next-milestone","title":"2.14 - Prepare next milestone","text":"<p>Following the close out of the milestone, the next milestone should be set up ready to begin as soon as is appropriate. Typically, this might be after a weekend, but should be set up in such a way that the next milestone could begin the next day after release.</p> <p>Full details of actions needed to be undertaken to set up the next milestone can be found in the Preparing a new Milestone Procedure</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#3-communications-of-the-end-of-the-milestone","title":"3 - Communications of the end of the milestone","text":""},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#31-release-beta-installer-publicly","title":"3.1 - Release beta installer publicly","text":"<p>Once the installer has been reviewed, and the discipline leads have reported back to the DevOps team their acceptance of the installer, the installer should be release for general consumption. This should be done in the following ways.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#32-update-of-external-website","title":"3.2 - Update of external website","text":"<p>The BHoM.xyz website should be updated by a member of the DevOps team to incorporate the new public installer for the end of the milestone. The website should be updated to highlight this is a new installer, and references changed as appropriate.</p>"},{"location":"DevOps/Operating%20Procedures/End%20of%20milestone%20procedure/#4-lift-pr-lock-down","title":"4 - Lift PR lock down","text":"<p>The lock down of Pull Request merging can now be lifted, with Pull Requests able to be merged as appropriate as part of the code creation for the next set of alphas and subsequent beta. The lifting of Pull Request lock down must be clearly announced on Teams and other appropriate communication channels.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/","title":"Preparing a new milestone","text":"<p>The contents of this page detail the actions to be undertaken at the beginning of a given Milestone. These procedures may be updated at any point.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#1-related-documents","title":"1 - Related documents","text":"<p>The following documents are considered related to this procedure. It is recommended these are read in conjunction with this document for a full understanding of the procedures being followed.</p> <ul> <li>End of Milestone procedure</li> </ul>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#2-purpose","title":"2 - Purpose","text":"<p>The purpose of this procedure is to outline the steps which are to be taken during the transition period from one milestone to the next. Due to the nature of development, the current development calendar does not provide for hard breaks between development cycles. The release of one beta, and end of that milestone, does not have breathing space to the next milestone. This is afforded by the slick operation in which milestones are turned around, benefited by the experience and skill of the team involved, and the automation of many of the processes involved, requiring only oversight.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#3-halting-this-procedure","title":"3 - Halting this procedure","text":"<p>If at any time an event occurs which draws the capability of the new milestone being advanced into doubt, the Governance lead or the CI/CD lead may bring a halt to proceedings. Halting this procedure should be done prior to any irreversible changes being made to the code base as part of this procedure. Should a halting of this procedure be initiated, the Governance and CI/CD teams should meet to discuss the situation and prepare a continuation plan that allows the cause of the halt to be handled. As appropriate, other discipline leads should be updated and included in that process, particularly where a halting of the procedure may cause a delay to development.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#4-tasks","title":"4 - Tasks","text":"<p>The following tasks should be completed as part of the preparation of a new milestone. Full details of each task are given further below. All of the tasks below are the responsibility of the CI/CD lead to ensure completion, however, many tasks will be delegated to suitable individuals.</p> <ul> <li>The milestone that has just closed should have all relevant planning milestones closed on all repositories</li> <li>Appropriate planning milestones are set up across all repositories for the new milestone</li> <li>The installer versions are upticked to reflect the new milestone</li> <li>Upticking current milestone version for Test Toolkit</li> <li>The <code>AssemblyFileVersion</code> should be updated across all repositories</li> <li>The Versioning_Toolkit needs to have a new upgrader added and prepared for the next milestone to aid the next milestones development</li> <li>The <code>PreviousVersionAttribute</code>s should be removed across all repositories, along with all <code>Versioning_xy.json</code> files</li> <li>Upticking of copyright versions on BHoM repositories only</li> </ul>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#41-closure-of-milestones","title":"4.1 - Closure of milestones","text":"<p>The planning milestones on repositories included within the installer for the milestone just completed should be closed, including both RC and Release milestones.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#42-opening-of-milestones","title":"4.2 - Opening of milestones","text":"<p>Unless previously done, the milestones for RC and Release, with appropriate deadline dates, should be opened and added to all repositories included within the installer.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#43-upticking-installers","title":"4.3 - Upticking installers","text":"<p>The installer should be upticked within their code base to ensure the latest set of alphas reflect the new milestone.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#44-upticking-test-toolkit","title":"4.4 - Upticking Test Toolkit","text":"<p>Test_Toolkit also has a reference to the current milestone in development to aid with some compliance checks, and should be updated in the following locations:  - CodeComplianceTest_Engine/Query/CurrentVersion.cs</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#45-assembly-file-version-updates","title":"4.5 - Assembly File Version updates","text":"<p>The script to allow BHoMBot to update the Assembly File Versions should be executed. Pull Requests should be merged within 2 days of being raised, as Assembly File Versions have to be accurate to allow versioning to work appropriately. There should be no reason for delay to this task, and the CI/CD lead should work with Discipline leads to ensure timely merging of those Pull Requests.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#46-new-versioning-upgrader","title":"4.6 - New Versioning Upgrader","text":"<p>The Versioning_Toolkit needs to have a new upgrader added with the previous upgrader locked for future developments.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#47-removal-of-previousversion-attributes","title":"4.7 - Removal of <code>PreviousVersion</code> attributes","text":"<p>To keep the code base tidy, the script allowing BHoMBot to remove <code>PreviousVersion</code> attributes on code should be executed. Pull Requests should be merged within 5 days of being raised.</p>"},{"location":"DevOps/Operating%20Procedures/Preparing%20a%20new%20milestone/#48-upticking-of-copyright","title":"4.8 -  Upticking of copyright","text":"<p>Once per year, in the first sprint of January, all code within the BHoM organisation needs copyrights to be updated to reflect the new year. The script to allow BHoMBot to do this should be executed, and Pull Requests merged within 5 days. BHoMBot copyright compliance checks will be provided to aid checking that the copyright is valid, with Discipline leads then responsible for merging the Pull Requests around other Pull Requests, but no later than 5 days after being raised.</p> <p>The following areas need to be upticked:</p> <ul> <li>All <code>.cs</code> files within the BHoM organisation across all repositories which are not archived</li> <li>The primary copyright header on the BHoM/BHoM repository</li> <li>The copyright footers on bhom.xyz in the index file here and here</li> <li>The copyright footers on bhom.xyz/documentation in the yml file</li> </ul>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/","title":"Producing a beta installer","text":"<p>This outlines the steps necessary to follow to obtain a beta installer, and make it available for testing and release. This document forms part of the End of Milestone Procedure.</p>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/#1-scope","title":"1 - Scope","text":"<p>This procedure/guide is designed for the creation of a beta installer at the end of a milestone, or when a patch is required. </p>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/#11-pre-informationdecisions","title":"1.1 - Pre-information/decisions","text":"<p>The following information is to be provided and authorised by the DevOps team:</p> <ul> <li>PatchVersion - this should be 0 for an end of milestone release, but if doing a beta patch release, this should refer to the patch number being produced</li> <li>ReleaseType - this should be set to beta for any beta installer</li> <li>Version - this should be set to the end of milestone version, inclusive of v - e.g. v3.0 v3.1, etc.</li> </ul>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/#2-beta-test-artefacts","title":"2 - Beta Test Artefacts","text":"<p>Prior to the distribution of the beta, beta test artefacts are to be produced during each day of the final sprint of the milestone. These are generated by BHoMBot at 3am UK time and should be set up by DevOps to trigger nightly.</p> <p>The beta test branch should be set appropriately from the Pull Requests which aim to merge the <code>develop</code> branches into <code>main</code>. Where a branch does not exist (because it has been merged or because there is nothing to deploy this milestone for that repository) then the <code>main</code> branch must be used instead.</p> <p>Queuing up beta test artefacts is already written into BHoMBots code but the trigger is commented out during the milestone when not required. Turning this trigger on should be done by DevOps at the start of the final sprint of the milestone.</p> <p>The major version should be set without a <code>v</code> at the start, and should be set to the milestone that it is being produced for - e.g. <code>6.1</code> for the 6.1 milestone.</p> <p>The <code>type</code> of the installer payload should be set to <code>BetaTest</code>.</p>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/#3-beta-artefacts","title":"3 - Beta Artefacts","text":"<p>Producing a final beta artefact involves queuing up a new payload for BHoMBot, which can be done by DevOps using the scripts available to queue up tasks into BHoMBots queue.</p> <p>The major version should be set with a <code>v</code> at the start for the final artefact - e.g. <code>v6.1</code> for the 6.1 milestone.</p> <p>The <code>type</code> of the installer payload should be set to <code>Beta</code>.</p>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/#31-beta-patching","title":"3.1 - Beta Patching","text":"<p>Producing a Beta patch is the same as producing a final beta, with the action being queued up by DevOps for BHoMBot to execute.</p> <p>The major version should be set with a <code>v</code> at the start of the final artefact and be set to the milestone that has been completed that is being patched - e.g. <code>v6.1</code> to patch the 6.1 beta.</p> <p>The minor version should be set to a number appropriate for the number of patches made - e.g. <code>2</code> if this is the second patch being made.</p> <p>The <code>type</code> of the installer payload should be set to <code>Beta</code>.</p>"},{"location":"DevOps/Operating%20Procedures/Producing%20a%20beta%20installer/#4-releasing-the-artefact","title":"4 - Releasing the artefact","text":"<p>Releasing the artefact involves downloading the appropriate artefact from the location where BHoMBot produces Beta artefacts for review, and uploading them to the appropriate location for general consumption. This is a manual process after sign off of the beta has been acquired.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/","title":"Getting started for developers","text":"<p>Welcome Developers! \ud83d\ude80</p> <p>Here's a quick start guide. After reading this, you might want to head to create your own Toolkit.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#building-bhom-from-source","title":"Building BHoM from Source","text":"<p>Please follow the steps below:</p> <ol> <li>Use git <code>clone</code> (or use GitHub desktop) to download the repositories in the list below.</li> <li>Use your preferred IDE to build the solutions in the order as they appear below.  We recommend Visual Studio Community.</li> </ol> <p>Build order</p> <p>The first time you build BHoM you need to clone and build the repos in the order specified below.</p> <p>You must pick all the Mandatory repos.</p> <p>Rebuilding and seeing changes in the UIs (Grasshopper, Excel, ...)</p> <p>When building in visual studio, the compiled assemblies will go in the <code>./Build</code> folder of your Repo; additionally, there is a Post-Build event that copies the files in the central BHoM folder: <code>C:\\ProgramData\\BHoM\\Assemblies</code>.</p> <p>When you build, if there is any UI open (e.g. Rhino/Grasshopper/Revit/Excel), the dlls will not be overwritten in the central folder because they are referenced by the UI software. Therefore, to ensure the changes are visible in the UI, you must make sure to close all UI software, then reopen it to see updated changes.</p> <p>Debugging and Edit-and-continue</p> <p>Please have a look at the page dedicated to Debugging and Edit-and-continue for tips on how to be most effective when coding/debugging with BHoM.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#mandatory-base-repos","title":"Mandatory base repos","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#main-repos","title":"Main repos","text":"<p>Compile each of these, one after the other:</p> <ul> <li>BHoM</li> <li>BHoM_Engine</li> <li>BHoM_Adapter </li> <li>BHoM_UI</li> <li>CSharp_Toolkit</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#user-interfaces","title":"User interface(s)","text":"<p>Compile one or more of the following - depending on the User interface software you want to use:</p> <ol> <li>Rhinoceros_Toolkit and then Grasshopper_Toolkit (requires Rhinoceros_Toolkit)</li> <li>Excel_Toolkit</li> </ol> <p>The following repos are optional.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#optional-base-repos","title":"Optional base repos","text":"<p>These repos are sometimes used as stand-alone, and sometimes are also referenced by other repos. </p> <p>You might find them useful \ud83d\ude80 </p> <ul> <li>BHoM_Datasets - makes Datasets available (some test scripts might be using them)</li> <li>Socket_Toolkit - send messages through Sockets. Some toolkits use this.</li> <li>Mongo_Toolkit - database connection. Some toolkits use this.</li> <li>Versioning_Toolkit - allows retro-compatibility of components (auto upgrade to newest version).</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#toolkits","title":"Toolkits \ud83c\udf0d","text":"<p>Toolkits provide the connection to other software.</p> <p>Clone and build any toolkit you want to use!</p> <p>Some examples:</p> <ul> <li>For Structural FEA analysis</li> <li>Robot_Toolkit (for students, Robot offers a free version)</li> <li>GSA_Toolkit</li> <li>ETABS_Toolkit</li> <li>Many others available!</li> <li>For Environmental simulation </li> <li>IES_Toolkit</li> <li>EnergyPlus_Toolkit</li> <li>Many others available too!</li> <li>Others:</li> <li>Speckle_Toolkit</li> <li>LifeCycleAssessment_Toolkit</li> <li>Explore https://github.com/BHoM ...</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#faq-and-help","title":"FAQ and help","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#i-cant-rebuild-the-solution-nuget-packages-missing-error","title":"I can't Rebuild the solution: <code>NuGet package(s) missing</code> error","text":"<p>Sometimes you might encounter this error. Although Visual Studio \"Rebuild All\" command should take care of Restoring the NuGet packages for you, to solve this just run that manually. Right click the solution \u2192 <code>Restore NuGet Packages</code>.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/#i-have-done-some-changes-to-my-code-but-when-i-open-grasshopper-or-excel-or-the-code-still-behaves-as-before-why-it-is-not-updated","title":"I have done some changes to my code, but when I open Grasshopper (or Excel, or ...) the code still behaves as before! Why it is not updated?","text":"<p>After compiling, check that the Build was successful, by looking in the \"Output\" tab at the bottom of the VS interface; make sure no errors are there, and also that the Post-build event worked successfully. See the notes above.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Coding-Templates/","title":"BHoM coding templates","text":"<p>Visual studio template files have been set up to help guide and simplify the development process of the BHoM.</p> <p>The currently available templates are:</p> <ul> <li>Toolkit Template. You can use this to create a scaffolded Visual Studio solution ready for the development of a Toolkit. It includes an Adapter, an Engine and an oM project templates.</li> <li>Engine method templates. They make it faster to to add new Engine methods to an Engine project.</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Coding-Templates/#toolkit-template","title":"Toolkit template","text":"<p>For more guidance on how to use the Toolkit template, please see Toolkit Template.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Coding-Templates/#engine-method-templates-add-them-to-visual-studio","title":"Engine method templates - add them to Visual Studio","text":"<p>To get visual studio to detect the templates follow these steps:</p> <ol> <li>Download the template zip files from here.</li> <li>Place the files in the visual studio templates folder. This will generally be:</li> <li>C:\\Users\\ USERNAME \\OneDrive\\Documents\\ VISUAL STUDIO VERSION \\Templates\\ProjectTemplates\\Visual C# for any project template like the BHoM Adapter Template.</li> <li>C:\\Users\\ USERNAME \\OneDrive\\Documents\\ VISUAL STUDIO VERSION \\Templates\\ItemTemplates\\Visual C# for any item template like Engine method templates.</li> <li>Restart visual studio.</li> </ol> <p>When you choose New Project from the visual studio menu all project templates should now show up there and when adding a new item to an existing project should now mean all the item templates should show up.</p> <p>Known Issues</p> <p>If template is used to add a method by right clicking on a folder, an extra the folder name will be added. This will in many cases be wrong and conflict with the class name. Issues have been raised to improve the templates further going forward. In the meantime, please check the namespace of added methods.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Using-Git/","title":"How to use Git","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Using-Git/#introduction","title":"Introduction","text":"<p>This documentation will be focused on the use of Git Bash.</p> <p>The first step is to create a space on your computer where you want all your local files to be stored. Now you want to create different repositories (repos) in this folder. Do this by opening up git bash and using <code>git clone (web address)</code>. A good list of repos for getting started can be found here.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Using-Git/#pushing-code-changes-to-github","title":"Pushing code changes to GitHub","text":"<p>Before getting started it is recommended to read through this first.</p> <p>Start off by creating a new branch with an appropriate name.</p> <p>You create a new branch with <code>git checkout -b (name of the branch)</code>. Make sure that you are on develop when creating a new branch to prevent branches created from other branches.  It is now time for you to do the changes you wish to do. When you are satisfied with everything it is time make a commit. You should always rebuild the code to make sure that it compiles, and if needed test out the code before pushing it to GitHub. </p> <p>Start by running <code>git status</code> which will show you, in red, all of the files that has been changed. If everything looks alright use <code>git add .</code> which adds all of the files to the commit. If you wish to only add selected files you can use <code>git add (name of the file)</code> for the files you wish to include. </p> <p>Once the files are added it can be a good idea to double-check using <code>git status</code> again, and the included files should now be showed in green instead of red. Then it is time to use commit these changes with <code>git commit -m (\"message\")</code>. Keep in mind that this message will be shown on GitHub along the commit so a somewhat brief explanation of what is included in the commit can be a good idea.</p> <p>Finally it is time to actually push the commit to GitHub with <code>git push origin (branch name)</code>. It is now possible to create a pull request on GitHub.  If you were to need to make any more changes before the PR is merged just make sure you are on your branch for that feature, (no need to create a new branch) and do the necessary changes and then  start the push process again, starting with <code>git status</code> and <code>git add .</code>. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Using-Git/#avoiding-conflicts","title":"Avoiding conflicts","text":"<p>In order to avoid conflicts when creating pull requests make sure that the repository you are working on is up to date.  Make sure you are on the develop branch by using <code>git checkout develop</code> Start off by using <code>git fetch origin</code> which gets updates from other repositories and then <code>git pull origin (branch name)</code> to update your code from others.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/","title":"BHoM's coding style and conventions","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#general-c-conventions","title":"General C# conventions","text":"<p>Our coding style generally follows the Microsoft guidelines on C#.</p> <p>However, to attain a higher level of clarity and transparency, BHoM code also adheres to additional customised rules and style guidelines.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#additional-conventions","title":"Additional conventions","text":"<p>BHoM code also adheres to customised rules and style guidelines. These are in place for several reasons, mainly:</p> <ul> <li>to make easier to read and contribute to the codebase;</li> <li>to ensure the functionality can be correctly exposed to the UIs;</li> <li>to organise functionality and classes in a tidy, easy-to-find manner.</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#access-modifiers","title":"Access modifiers","text":"<p>Access modifiers specify the accessibility level of type and type members. They denote whether a type or member can be used by other code in the same assembly, and in other assemblies.</p> <ul> <li>In line with BHoM's focus on clarity and transparency, we generally use the <code>public</code> access modifier, which allows a type or member to be accessed by any other code in the same assembly or other assembly that reference it.</li> <li>When absolutely necessary, we use the <code>private</code> access modifier to limit the access of a type or member to only code in the same class.</li> <li>Although C# provides many access modifiers, we limit our use to the two mentioned above.</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#filenames-objects-and-methods","title":"Filenames, objects and methods","text":"<ul> <li>A <code>.cs</code> file can contain only 1 (one) <code>class</code>, and there is no concept as a <code>Helper</code> or <code>Utils</code> class.</li> <li>For oM objects the name of the <code>.cs</code> file is the Name (excluding the namespace) of the Object (class), e.g. the <code>Line</code> class is in the <code>Line.cs</code> file.</li> <li>For engine methods, a file can only contain methods whose name start or end with the name of their file file, e.g. <code>Flip(Line line)</code> and <code>Flip(Arc arc)</code> are in the same file <code>Flip.cs</code>, and <code>FilterPanels</code> and <code>FilterOpenings</code> can both reside inside a <code>Filter.cs</code> file.</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#folders-and-namespaces","title":"Folders and namespaces","text":"<p>Namespaces and the folder structure that contains the <code>.cs</code> files have a close relationship. To define the correct folder structure helps keeping the relationship with the namespaces. This, in turn enables additional functionalities, such as deriving the web address of the source code of a method.</p> <p>For a <code>Class</code>, an <code>Attribute</code>, an <code>Enum</code>, and an <code>Interface</code>, the folder structure respects the following rules:</p> <ul> <li> <p>If a file is in a sub folder, the namespace of the entity must follow: if <code>Bar</code> is in a sub folder <code>Elements</code>, its namespace must suffix the <code>Elements</code> word <code>BH.oM.Structure.Elements</code>.</p> </li> <li> <p>An <code>Enum</code> must be in a separate folder <code>Enums</code>. Although, the namespace remains unchanged, and does not follow - i.e. <code>Enums</code> is appended as suffix. For example <code>BarFEAType</code> is in the sub folder <code>Elements</code>, and it is an <code>enum</code>. Its namespace respects A., so it contains the <code>Elements</code> word, but does not contain the <code>Enum</code> word: BH.oM.Structure.Elements. At the same time, since it is an <code>Enum</code> it is in an <code>Enums</code> folder.</p> </li> <li> <p>The same rule as B. applies to:</p> </li> <li><code>Attribute</code> =&gt; <code>Attributes</code></li> <li><code>Interface</code> =&gt; <code>Interfaces</code></li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#enum-ordering","title":"Enum ordering","text":"<p>The order an Enum is written is the order in which it is displayed in the UI dropdown options. This order is therefore important to the UX of using the Enum within a workflow. The order should therefore follow one of the following conventions. There may be occasions when an Enum order does not follow the conventions below. These occasions should be clearly documented with the reasons why a different convention has been followed.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#alphabetical","title":"Alphabetical","text":"<p>The order of the Enum should be alphabetical (following British-English spelling conventions) in ascending order (i.e. A-z).</p> <p>Caveat for <code>Undefined</code></p> <p>If your Enum option has an <code>Undefined</code> option to denote a default unset option, then this should go as the first option at the top of the Enum.</p> <p>For an example of an Enum following this convention, see the Environment Panel Type Enum.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#logical","title":"Logical","text":"<p>The order of the Enum can be in a logical order instead where this makes more sense than alphabetical. An example of such an Enum might be one that records the size of an object. In this case, the options might be:</p> <pre><code>ExtraSmall\nSmall\nNormal\nLarge\nExtraLarge\n</code></pre> <p>This order for the Enum makes logical sense and provides a good UX where users will have context from the name of the Enum that the order might be different to alphabetical (e.g. the name might be <code>UnitSize</code>).</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Coding-Style/#yoda-condition","title":"Yoda condition","text":"<p>For conditional statements, the variable expression should be placed in front of the constant expression. When this order is reversed, it is referred to as a \"Yoda condition\". For readability, we avoid using Yoda conditions in our code base. An example of both is given below.</p> <pre><code>string str = \"hello world\" \n\nif (str == \"BHoM\") { /* \u2026 */} //most common convention - preferred for BHoM development\n\nelse if (\"BHoM\" == str) {/* \u2026 */} //Yoda style, as the constant \"BHoM\" precedes the string variable\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Debugging-Edit-and-continue/","title":"BHoM Debugging and Edit-and-continue","text":"<p>When developing a Toolkit, you may want to Debug the code you've written, or even use the Edit-and-continue feature that is available in many IDEs (mainly, Visual Studio). In particular, Edit-and-continue can be very useful in reducing rebuild iterations.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Debugging-Edit-and-continue/#standard-debugging","title":"Standard debugging","text":"<p>Simply fire up your UI application and attach to its process.</p> <p>This way you will be able to follow code execution and check exceptions; however, this does not allow for code modification while debugging.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Debugging-Edit-and-continue/#enabling-edit-and-continue","title":"Enabling Edit-and-continue","text":"<p>The Edit-and-continue feature allows you to do code modifications without having to close the UI (e.g. Rhino/Grasshopper or Excel) and rebuilding the Solution.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Debugging-Edit-and-continue/#edit-and-continue-for-rhinograsshopper","title":"Edit-and-continue for Rhino/Grasshopper","text":"<p>In a nutshell, to enable Edit-and-continue at least from a Rhino/Grasshopper process, you need to create a temporary (possibly <code>.gitignore</code>d) project that uses the latest .NET Framework version compatible with Rhino (any 4.7, and possibly later, should work), setting that up as the \"Startup project\", and configured in its Debug options to launch the Rhino executable. Starting this Project will launch the debugger attached to a new instance of Rhino, in which the Edit-and-continue will work.</p> <p>Note that not all IDEs support this (notably, not the Express editions of Visual Studio \u2013 only the Community, Professional and Enterprise ones do).</p> <p>Step by step instructions:</p> <ol> <li> <p>Add a .NET Framework Console App to your Solution (e.g. your Toolkit). To add it:</p> <p>1.1 Right-click on the solution in the Solution Explorer, select Add, New Project: </p> <p>1.2 Search for \"framework\" and select \"Console App\" showing \".NET Framework\" in the description: </p> <p>1.3 Call the new project \"Debug\" (this is useful to avoid tracking this project with git, as it gets excluded via the <code>.gitignore</code>). Then, select a .NET 4.7 version for the framework. The specific version may vary depending on what you have installed on your machine, and what the currently installed Rhino version supports. Generally, any 4.7 subversion should be available and working, but higher versions (e.g. 4.8) may work as well. Click Create when done. </p> <p>1.5 You will end up with this project (if you have a red icon, it indicates that it is untracked by git, as it should be). </p> </li> <li> <p>Right-click the newly created Project, then select \"Set as startup project\". The project name will now be displayed in bold. </p> </li> <li> <p>Configure the project to start with an UI application attached. For Rhino/Grasshopper:</p> <p>3.1 Go in the project settings by right-clicking the Project and selecting \"Properties\".</p> <p>3.2 Go in the \"Debug\" section on the left, then select the \"Start external program\" radio button and specify the Rhino executable path (as found on your machine - check where it's located and copy its path) in the textbox.</p> <p></p> </li> <li> <p>Start the debugger with new instance of the UI software attached (e.g Rhino).    Press F5 or the big green \"play\" button at the top to start Rhino; this instance of Rhino will have the debugger already attached and the Edit-and-Continue feature enabled.</p> </li> </ol> <p>The last step will fire up your UI application and you will be able to modify the code while debugging (just press the <code>Pause</code> button in Visual Studio). The Edit-and-Continue will be working for all the code in the Solution.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/","title":"Logging and exceptions","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#bhom-logging","title":"BHoM Logging","text":"<p>BHoM implements an Events Log (the Log) which can store information about processes executing within the BHoM environment. All parts of the code base are encouraged to make use of this Log rather than implementing additional logging systems, and we encourage discussions on improving our logging system as we grow.</p> <p>The Log is housed within the BHoM_Engine project, so is available to all tools and toolkits building on the BHoM framework.</p> <p>The <code>Event</code> object contains enough properties to enable debugging and reporting issues or information to users via the Log. An event can be one of these types.</p> <p>You can record events in the Log by using any of the following options:</p> <ul> <li><code>BH.Engine.Base.Compute.RecordError(string message)</code> </li> <li><code>BH.Engine.Base.Compute.RecordWarning(string message)</code> </li> <li><code>BH.Engine.Base.Compute.RecordNote(string message)</code> </li> </ul> <p>This will log either an Error, a Warning, or a Note as appropriate with the message of your choosing.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#logging-exceptions","title":"Logging Exceptions","text":"<p>If you want to also handle <code>Exception</code> information within your Event, you can call one of these methods:</p> <ul> <li><code>BH.Engine.Base.Compute.RecordError(Exception exception, string message = \"\")</code> </li> <li><code>BH.Engine.Base.Compute.RecordWarning(Exception exception, string message = \"\")</code> </li> <li><code>BH.Engine.Base.Compute.RecordNote(Exception exception, string message = \"\")</code></li> </ul> <p>This will record the event with the type of your choosing and include information from the C# exception passed with it. You can provide an optional message to assist users as well.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#accessing-events","title":"Accessing events","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#accessing-all-events-since-the-start","title":"Accessing All Events Since the Start","text":"<p>You can access all events logged since the BHoM was started by calling <code>BH.Engine.Base.Query.AllEvents()</code>.</p> <p>If you want to get the list of all the events that occurred since you started your script/program, you can use <code>BH.Engine.Reflection.Query.AllEvents()</code>. In Grasshopper, it will look something like this:</p> <p></p> <p>As you can see, events are also BHoM object that you can explode as any other typical BHoM object.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#accessing-all-current-events","title":"Accessing All Current Events","text":"<p>You can control the Current Events to capture events that occur during the run of your code. To do this, start by clearing the current event log to ensure you have nothing from another process by calling <code>BH.Engine.Base.Compute.ClearCurrentEvents()</code>. Then, when you're ready to obtain the current events, you can use <code>BH.Engine.Base.Query.CurrentEvents()</code> to get all the events logged since the current events were last cleared.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#accessing-all-events-since-a-certain-time","title":"Accessing All Events Since A Certain Time","text":"<p>You can access all events logged since a certain time by calling <code>BH.Engine.Base.Compute.EventsSince(DateTime utcTime)</code>. This will return all events logged where the <code>UtcTime</code> of the event is on or after the provided <code>utcTime</code> passed into the method.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#accessing-all-events-with-periodic-bookmarks","title":"Accessing All Events With Periodic Bookmarks","text":"<p>Finally, you can access events based on a moving bookmark, which acts similar to <code>EventsSince()</code> but provides the current time as the next bookmark. When you call <code>BH.Engine.Base.Compute.EventsSinceBookmark()</code>, it will provide all the events which have occurred since the last time you called the method. On startup, the bookmark timestamp will be the time of initialisation of the code. When you call the method, the bookmark is then updated to be the time you inspected the events log, so the second time you call <code>EventsSinceBoomark()</code>, you will only get the events which have occured on or after the first time you checked.</p> <p>For example, if the system starts up at 10:30:00am then this is the initial time of the bookmark. If you inspect the <code>EventsSinceBookmark()</code> at 10:32:00am, you will get all the events which have occurred after 10:30:00, and the bookmark is updated to be 10:32:00am. If you inspect <code>EventsSinceBookmark()</code> again at 10:34:00, you will get all the events which occurred after 10:32:00, and the bookmark is updated to 10:34:00.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#dealing-with-errors","title":"Dealing with errors","text":"<p>Things don't always run according to plan. Two typical situations can occur:</p> <ul> <li>The input value your method received are invalid or insufficient to generate the output. </li> <li>The methods you call inside your method are failing </li> </ul> <p>In either case, you are generally left with a few choices:</p> <ul> <li>throw an exception, </li> <li>return a null value, </li> <li>return a dummy value. </li> </ul> <p>The first option stops the execution of the code completely while the other two allows things to continue but with the risk of the problem remaining unnoticed. A lot of times, none of those options are satisfactory. Let's take a simple example:</p> <pre><code>public List&lt;object&gt; MyMethod(List&lt;BHoMObject&gt; elements)\n{\n   List&lt;object&gt; results = new List&lt;object&gt;();\n   foreach (BHoMObject element in elements)\n      results.Add(DoSomething(element));\n   return results;\n} \n</code></pre> <p>If <code>DoSomething()</code> throws an exception, this method will fail and pass on the exception. This might be the desired behaviour but we might also want to return all the successful results and just ignore the failing ones. In that case, we could write:</p> <pre><code>public List&lt;object&gt; MyMethod(List&lt;BHoMObject&gt; elements)\n{\n   List&lt;object&gt; results = new List&lt;object&gt;();\n   foreach (BHoMObject element in elements)\n   {\n      try \n      {\n         results.Add(DoSomething(element));\n      }\n      catch {}\n   }\n   return results;\n} \n</code></pre> <p>This does the job. But it also hide completely the fact that an error occurred for some of the elements so the results are incomplete.</p> <p>This is why we have added a log system to the BHoM so all exceptional events can be recorded and passed to the UI.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#recording-events","title":"Recording Events","text":"<p>If we use the log, the code above could look like this:</p> <pre><code>using BH.Engine.Base;\n\npublic List&lt;object&gt; MyMethod(List&lt;BHoMObject&gt; elements)\n{\n   List&lt;object&gt; results = new List&lt;object&gt;();\n   foreach (BHoMObject element in elements)\n   {\n      try \n      {\n         results.Add(DoSomething(element));\n      }\n      catch \n      {\n         Compute.RecordWarning(\"Element \" + element.BHoM_Guid + \" failed\");\n      }\n   }\n   return results;\n} \n</code></pre> <p>There are 3 levels of event you can record:</p> <ul> <li>Error: <code>RecordError()</code> </li> <li>Warning: <code>RecordWarning()</code> </li> <li>Note: <code>RecordNote()</code> </li> </ul> <p>In Grasshopper, they will look like this:</p> <p></p> <p>So the UI components will automatically expose all the events that occurred during their execution.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#so-when-should-i-use-each-type-of-event","title":"So when should I use each type of event?","text":"<p>Besides fatal errors, <code>RecordError()</code> should be used in cases when we are not able to return any result for the provided input:</p> <pre><code>public static Point Centroid(this PolyCurve curve, double tolerance)\n{\n  if (!curve.IsClosed(tolerance))\n  {\n    Base.Compute.RecordError(\"Input curve is not closed. Cannot calculate centroid.\");\n    return null;\n  }\n  [...]\n}\n</code></pre> <p>Note that errors most often go with returning <code>null</code> (or <code>.NaN</code> in case of doubles).</p> <p><code>RecordWarning()</code> is for all kind of situations when the result is possible to compute, but we cannot ensure if it is 100% correct. It is also suitable if provided object has been modified in not certainly desired way:</p> <pre><code>public static Vector Normal(this PolyCurve curve, double tolerance)\n{\n  if (curve.IsSelfIntersecting(tolerance))\n    Base.Compute.RecordWarning(\"Input curve is self-intersecting. Resulting normal vector might be flipped.\");\n\n  [...]\n}\n</code></pre> <p>And last <code>RecordNote()</code> is meant for the cases when everything run correctly but there is still some info that we would like to communicate to the end user:</p> <pre><code>public override List&lt;object&gt; Push([...])\n{\n  [...]\n  if (pushConfig == null)\n  {\n    BH.Engine.Base.Compute.RecordNote(\"Revit Push Config has not been specified. Default Revit Push Config is used.\");\n    pushConfig = new RevitPushConfig();\n  }\n  [...]\n}\n</code></pre> <p>As one can see, there is no very strict convention on when to use each level of event. However, these examples should illustrate their intended purpose.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#what-about-exceptions","title":"What About Exceptions?","text":"<p>Does that mean that we should stop using exceptions? No!</p> <p>If your method ends up in a situation where it could not return any meaningful output, it should still throw an exception. Any method that catches an exception, on the other hand, should ALWAYS record something in the Log to make the user aware of what happened.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#log-errors-as-exceptions","title":"Log errors as exceptions","text":"<p>You can also opt to catch BHoM Error Events as Exceptions if you so wish. By default, errors are just logged in the Log and not handled any further. However, you can call <code>BH.Engine.Base.Compute.ThrowErrorsAsExceptions(true)</code> which will turn off the suppression of exception throwing.</p> <p>If you choose to do this, any error recorded into the Log while this suppression is off will be thrown as an exception itself, which you can then catch in a <code>try/catch</code> statement.</p> <p>If you want to turn the suppression back on after your use, you can call <code>BH.Engine.Base.Compute.ThrowErrorsAsExceptions(false)</code> and this will revert the Log to work in the default manner.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#good-log-messages","title":"Good Log Messages","text":"<p>It's important to note that the events in the Log are designed to be seen by users as well as developers. Therefore care should be taken to ensure the event message is as informative as possible. Ideally, for errors or warnings, information should be provided on how the user could resolve the issue, to avoid them needing to contact a developer for help. Users enjoy problem solving, but we don't need to make it unnecessarily difficult!</p> <p>Consider the following example:</p> <pre><code>public static bool MyMethod(List&lt;BHoMObject&gt; objects)\n{\n   for(int x = 0; x &lt; objects.Count; x++)\n   {\n      if(objects[x] == null)\n         BH.Engine.Base.Compute.RecordError(\"Object was null, could not compute object.\");\n\n      [...]\n   }\n}\n</code></pre> <p>Here we will have told the user the object is null and so we cannot work with it, which is fair enough, however, how could the user fix this error? If they have a list of several hundred (or thousand) objects, such as all the bars in a structures model, or all the panels in an environments model, simply telling them the object was null may not help them fix it. It's also worth considering that multiple objects in the list could be <code>null</code> and the user might get the same error multiple times on the component.</p> <p>Therefore, ensure the message provides the user some information which they can use to fix the problem. Such as:</p> <pre><code>public static bool MyMethod(List&lt;BHoMObject&gt; objects)\n{\n   for(int x = 0; x &lt; objects.Count; x++)\n   {\n      if(objects[x] == null)\n         BH.Engine.Base.Compute.RecordError($\"The object at index {x} was null, could not compute object.\");\n\n      [...]\n   }\n}\n</code></pre> <p>Here we've added only a small amount of extra information - the index of the object which is null - but in doing so, we've now empowered the user to inspect their objects at that specific index to identify the problem and potentially fix it.</p> <p>On the flip side, don't oversaturate the user with information so that they're unable to process the important bits. Keep the information in the message factual and to the point for a positive user experience.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#suppressing-events","title":"Suppressing Events","text":"<p>There may be times when you don't want the user to be given events, for example when your method is handling expected errors occuring with the objects. You might not want to user to be told <code>Polyline is not planar</code> if it doesn't actually matter to your process and you do something different for planar vs non-planar polylines.</p> <p>Obviously you can't always remove the events being logged from parts of the code base where they exist, particularly if building on top of the BHoM framework where the community has opted to put in event logging for when the methods are used on their own in one of the BHoM supported UIs.</p> <p>Therefore, the option exists to suppress the event logging, and prevent events being logged to the user during the execution of your method.</p> <p>To do this, call the <code>BH.Engine.Base.Compute.StartSuppressRecordingEvents(bool suppressErrors, bool suppressWarnings, bool suppressNotes)</code> method. Each <code>boolean</code> input corresponds to the type of event you wish to suppress. You can suppress all 3, or just certain combinations of the 3 as you wish depending on your use case.</p> <p>When events are suppressed, they go into the suppressed log, which is separate from the Events Log. This is a mechanism deliberately put in for the event where suppression occurs by accident - events are not lost completely and can be retrieved as needed.</p> <p>When calling <code>StartSuppressRecordingEvents</code> you provide the <code>booleans</code> for the events you want to suppress. However, if another method has opted to suppress events then this will also occur. Take the example:</p> <pre><code>public static bool MethodA(List&lt;BHoMObject&gt; objects)\n{\n   BH.Engine.Base.Compute.StartSuppressRecordingEvents(false, true, false); //Suppress Warnings but not Errors or Notes\n\n   MethodB(objects);\n}\n\npublic static bool MethodB(List&lt;BHoMObject&gt; objects)\n{\n   BH.Engine.Base.Compute.StartSuppressRecordingEvents(true, false, false); //Suppress Errors but not Warnings or Notes\n\n   [...]\n}\n</code></pre> <p>When <code>MethodA</code> is called by itself warnings will be suppressed, and when <code>MethodB</code> is called by itself errors will be suppressed. However because <code>MethodA</code> calls <code>MethodB</code> as part of its execution, <code>MethodA</code> will suppress warnings, and <code>MethodB</code> will suppress errors, meaning the end result will be BOTH errors and warnings are suppressed. This has been done so that <code>MethodB</code> could not override the suppression desires of <code>MethodA</code> by stating <code>false</code> to suppressing warnings.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#stop-suppressing-events","title":"Stop suppressing events","text":"<p>When you're ready to stop suppressing events, simply call the method <code>BH.Engine.Base.Compute.StopSuppressRecordingEvents()</code>. This will reset event logging to the default state for all types of events.</p> <p>You should always stop event suppression at the end of the method you have started it, to prevent the Log system being suppressed for longer than necessary and risking events not being raised to users when they should.</p> <p>If you want to suppress warnings, then turn warnings back on and suppress errors, you would do so like this example:</p> <pre><code>public static bool MethodA(List&lt;BHoMObject&gt; objects)\n{\n   BH.Engine.Base.Compute.StartSuppressRecordingEvents(false, true, false); //Suppress Warnings but not Errors or Notes\n\n   [...]\n\n   BH.Engine.Base.Compute.StopSuppressRecordingEvents(); //Turn on all events\n   BH.Engine.Base.Compute.StartSuppressRecordingEvents(true, false, false); //Suppress Errors\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Handling-Exceptional-Events/#retrieving-suppressed-events","title":"Retrieving suppressed events","text":"<p>If you want to retrieve events raised during the suppressed time period, you can call <code>BH.Engine.Base.Compute.RetrieveSuppressedLog()</code>. This will move all events recorded during the suppressed period to the main Log, which can be accessed in the ways outlined at the top of this page.</p> <p>The suppressed log will be reset once its events have been retrieved, so you don't need to worry about retrieving duplicates.</p> <p>Retrieved events won't appear on the UI on components though, so users may still not know about them initially, but they can be queried using the same access components above in any of the BHoM supported UIs.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Null-Handling/","title":"Null handling","text":"<p>Null Handling is the practice of protecting against <code>null</code> inputs to methods within the engines and adapters.</p> <p><code>Null</code> inputs can throw errors that are unhelpful to the user, typically a <code>object is not set to an instance of an object</code> exception, which does not provide the user with much information on how to resolve this problem within their chosen UI.</p> <p>As such, it is good practice to ensure all of the inputs to a method are valid before trying to run operations on them. Take the following method as an example.</p> <pre><code>public static string GetName(BH.oM.Environment.Elements.Panel panel)\n{\n    string name = \"\";\n    name += panel.Name + \" \";\n    name += panel.Construction.Name;\n    return name;\n}\n</code></pre> <p>If <code>panel</code> is <code>null</code>, then the line <code>name += panel.Name + \" \";</code> will throw a <code>NullReferenceException</code> as you cannot get the <code>Name</code> property of an object with no data associated to it (<code>null</code>). This may then confuse the user. Therefore, we should check whether the <code>panel</code> is <code>null</code> and tell the user before using it.</p> <pre><code>public static string GetName(BH.oM.Environment.Elements.Panel panel)\n{\n    if(panel == null)\n    {\n        BH.Engine.Reflection.Compute.RecordError(\"Panel cannot be null when querying the name. The panel should have data associated to it and be a valid instantiation of the object.\"); //Suitable error message that helps the user understand what's going on\n        return \"\"; //A suitable return - you could `return null;` here instead if needed\n    }\n\n    string name = \"\";\n    name += panel.Name + \" \";\n    name += panel.Construction.Name;\n    return name;\n}\n</code></pre> <p>The return from a <code>null</code> check should be appropriate for the return object type. For complex objects (e.g. a BHoM object return type, such as a <code>Panel</code> or <code>Bar</code>), returning <code>null</code> should be appropriate, as empty objects (such as <code>return new Panel();</code>) will likely cause more problems down the line if the object is not <code>null</code>, but has no data. For primitive types (e.g. <code>string</code>, <code>int</code>) then returning a suitable default is appropriate, such as an empty string (<code>\"\"</code>). For numbers (<code>int</code>, <code>double</code>, etc.), returning a number should be carefully considered. <code>0</code> may be a valid response to the method that the downstream workflow will rely on, so consider returning negative numbers (e.g. <code>-1</code>) instead, or numbers outside the realm of reality for the equation (such as <code>1e10</code> or <code>-1e10</code> for large and small numbers respectively). The same is for <code>bool</code> return types, consider what <code>true</code> or <code>false</code> may imply further down the line and return the appropriate response. For collections, empty collections are appropriate.</p> <p>The final decision for what the return should be will reside with the relevant toolkit lead, who should take into consideration the expected use cases and user stories.</p> <p>The error message should also convey to the user which bit of the data is <code>null</code> and what they need to fix it. Consider the above example, the <code>panel</code> may not be <code>null</code> but the <code>Construction</code> property might be. Therefore <code>panel.Construction.Name</code> will also throw a <code>NullReferenceException</code>.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Null-Handling/#isnull","title":"IsNull","text":"<p>For complex objects, with multiple properties to check, you may wish to implement an <code>IsNull</code> check query method, which takes the object and checks all of the nested data to check if any of it is <code>null</code> and returns a <code>true</code> or <code>false</code> and an error message if anything was <code>null</code>. An example of this can be seen in the Structure_Engine <code>IsNull</code> method which checks objects and their complex properties. This is useful for areas where the entire object must have valid data, but may not be appropriate for other instances. It is toolkit lead and developer discretion as to which way null checks should be handled in a given method.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Null-Handling/#cheat-sheet","title":"Cheat Sheet","text":"<p>The following cheat sheet can be used as a guideline for what should be the default return type if a <code>null</code> check has failed for different types. This is not the definitive list, and many occasions may do something different with suitable justification. But if in doubt, the following can be used and would be accepted in 99 cases out of 100.</p> Return type Return value <code>int</code>, <code>decimal</code> <code>-1</code> or <code>0</code> - whichever is the most appropriate downstream <code>double</code> <code>double.NaN</code> or <code>-1</code> or <code>0</code> - whichever is the most appropriate downstream <code>float</code> <code>float.Nan</code> or <code>-1</code> or <code>0</code> - whichever is the most appropriate downstream <code>string</code> <code>\"\"</code> or <code>null</code> - whichever is the most appropriate downstream <code>bool</code> <code>false</code> or <code>true</code> - whichever is the most appropriate downstream (will depend on what the method is doing, e.g. a query for <code>HasConstruction</code> could return <code>false</code> appropriately because a <code>null</code> object cannot have a construction) <code>List</code> or other <code>IEnumerable</code> Empty list (<code>new List&lt;object&gt;();</code>) or <code>null</code> Complex object (e.g. a <code>BHoMObject</code> such as <code>Panel</code> or <code>Bar</code> <code>null</code>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/","title":"Targeting multiple API versions","text":"<p>It might happen that a Toolkit targeting a specific software will have to reference different assemblies for different versions of the software. </p> <p>For example, this happens for ETABS_Toolkit. We will take it as an example in this page.</p> <p>In ETABS, the various versions of the software have different API assemblies, and the assemblies have different names depending on the software version. For example: ETABS version 2016 has an API assembly named ETABS2016.dll; ETABS version 2017 has one named ETABSv17.dll.</p> <p>For this reason, it's important to set the Build Configuration of the solution in a manner that allows the needed flexibility and maintains scalability.</p> <p>For the sake of semplicity we will refer to this as \"versioning\" in this wiki page.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#guidelines","title":"Guidelines","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#limit-the-versioning-to-the-vs-projects-that-need-it","title":"Limit the versioning to the VS Projects that need it","text":"<p>For example, ETABS_Toolkit needs to reference the software API (and therefore different versions of it) only in the project ETABS_Adapter.</p> <p>This means that the other projects of the toolkit, namely ETABS_Engine and ETABS_oM, can avoid the problem altogether. No action should be taken on them.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#if-only-one-vs-project-needs-versioning-make-sure-the-others-projects-build-configuration-target-the-base-build","title":"If only one VS Project needs versioning, make sure the others projects' Build configuration target the base build.","text":"<p>You can set this in Visual Studio Build menu \u2192 Configuration Manager.</p> <p>This means that Projects that do not need versioning \u2013 in the ETABS example the Engine and the oM \u2013 have to: - For \"Debug-type\" builds: target the base <code>Debug</code> configuration; - For \"Release-type\" builds: terget the base <code>Release</code> configuration.</p> <p>The following screenshot shows an example for \"Debug-type\" build: </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#make-sure-builds-are-having-clear-separate-assembly-name","title":"Make sure builds are having clear separate assembly name","text":"<p>The assembly name can be set by modifying the Project's <code>.csproj</code> file.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#more-info-on-how-to-modify-the-csproj","title":"More info on how to modify the <code>.csproj</code>","text":"<p> This can be done by:   <ul> <li> <p>In VS, right click the project in Solution Explorer \u2192 Unload Project \u2192 right click again \u2192 edit <code>.csproj</code>. Edit,  save, then right-click again on the project and do Reload Project.  </p> </li> <li> <p>OR by navigating to the project folder and editing the <code>.csproj</code> directly.  </p> </li> </ul> <p>The AssemblyName has to be defined so that it reflects the build version (e.g. 2017, 2018, etc.) and to be consistent with the naming conventions adopted for the specific Toolkit.</p> <p>See the following example for the ETABS as an example:</p> <pre><code>  &lt;PropertyGroup&gt;\n    &lt;Configuration Condition=\" '$(Configuration)' == '' \"&gt;Debug17&lt;/Configuration&gt;\n    &lt;Platform Condition=\" '$(Platform)' == '' \"&gt;AnyCPU&lt;/Platform&gt;\n    ...\n    &lt;AssemblyName&gt;ETABS17_Adapter&lt;/AssemblyName&gt;\n    ...\n  &lt;/PropertyGroup&gt;\n  &lt;PropertyGroup&gt;\n    &lt;Configuration Condition=\" '$(Configuration)' == '' \"&gt;Debug18&lt;/Configuration&gt;\n    &lt;Platform Condition=\" '$(Platform)' == '' \"&gt;AnyCPU&lt;/Platform&gt;\n    ...\n    &lt;AssemblyName&gt;ETABS18_Adapter&lt;/AssemblyName&gt;\n    ...\n  &lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#test-all-builds-are-coming-out-correctly","title":"Test all builds are coming out correctly","text":"<p>Once you are done, please try to build using all configurations.</p> <p>To ensure you are doing this correctly, go to the Toolkit's <code>Build</code> folder and delete all its contents every time you test a different Build.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Best-practices/Toolkits-targeting-multiple-versions-of-the-same-software/#make-sure-the-a-build-config-is-added-to-the-bhom-installer","title":"Make sure the a Build config is added to the BHoM installer","text":"<p>Contact the Toolkit's responsible - they will do it for you or assist you in doing that.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/","title":"Accessing Datasets in code","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#how-to-access-bhom-datasets-programmatically","title":"How to access BHoM Datasets programmatically","text":"<p>Accessing various datasets, such as material or section datasets, can be useful when coding for BHoM. For example, you may need datasets when coding C# Unit Tests, or when programming some particular Engine function. </p> <p>Access BHoM Datasets from a C# program, you need to ensure the correct dependencies are added to your project. The following steps will guide you through the process of adding the appropriate dependencies and demonstrate a few methods for accessing your desired dataset.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#step-1-access-reference-manager","title":"Step 1: Access Reference Manager","text":"<p>Access the Reference Manager in the C# project where you want to add the dependency.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#step-2-browse-for-the-dll","title":"Step 2: Browse for the DLL","text":"<p>Go to the \"Browse\" tab and click the \"Browse\" button in the bottom-right corner.</p> <p></p> <p>Navigate to the BHoM assemblies folder using the File Explorer window. The folder is usually located at C:\\ProgramData\\BHoM\\Assemblies. Select Data_oM.dll and press \"Add.\"</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#step-3-add-dependency","title":"Step 3: Add Dependency","text":"<p>Make sure to check the box next to Data_oM.dll in the Reference Manager window and press \"OK.\"</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#step-4-modify-file-path","title":"Step 4: Modify File Path","text":"<p>Open the project file of your specific C# project by double-clicking it with the left mouse button. Locate the line responsible for loading Data_oM.dll and modify the file path as shown in the image below.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#step-5-get-the-dataset-data","title":"Step 5: Get the Dataset data","text":"<p>The following example demonstrates how to access the Section Library from BHoM, specifically the .</p> <p>To access the library, use the <code>Match</code> method as shown in the example below. This returns the <code>HE1000M</code> section defined in the <code>EU_SteelSectionLibrary</code> dataset.</p> <pre><code>var steelSection = BH.Engine.Library.Query.Match(\"EU_SteelSections\", \"HE1000M\", true, true) as ISteelSection;\n</code></pre> <p>The Match method takes four arguments:</p> <ol> <li>Library Name: \"EU_SteelSections\"</li> <li>Object Name: \"HE1000M\"</li> <li>Case Sensitivity: true or false</li> <li>Consider Spaces: true or false</li> </ol> <p>The boolean values allow you to specify whether your search should be case-sensitive and whether to consider spaces within the object name.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#find-existing-libraries","title":"Find Existing Libraries","text":"<p>If you're unsure about the available datasets, check the BHoM_Datasets repository. </p> <p>Under BHoM_Datasets\\DataSets, you'll find multiple folders and subfolders containing numerous <code>json</code> files. Each json is a dataset, and each folder acts as a dataset library. </p> <p>For example, in the folder <code>[BHoM_Datasets repo folder]\\BHoM_Datasets\\DataSets\\Structure\\SectionProperties\\EU_SteelSections</code> you will find the following json files:</p> <p></p> <p>These .json files contain multiple objects. To extract objects from these datasets, you'll need the name of the desired object. This can be found as an attribute within the .json file. To locate these names, you can open the .json file in an editor like Visual Studio Code and search for the object name you need.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#compliance","title":"Compliance","text":"<p>Compliance regulations for Datasets are outlined in IsValidDataset.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#source","title":"Source","text":"<p>For users of the data to be able to verify where it is coming from, it is important to populate the Source object for the dataset. As many of the properties of the source as available should generally be populated, with an emphasis on the following:</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#title","title":"Title","text":"<p>The title of the publication/paper/website/... from which the data has been taken.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#sourcelink","title":"SourceLink","text":"<p>An HTTP link to the source. Important to allow users of the data to easily identify where the data is coming from.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#confidence","title":"Confidence","text":"<p>Level of confidence both in the data source and in how well the serialised data in the BHoM dataset has been ensured to match the source. It should be noted that, independent of the confidence level on the Dataset, all Datasets distributed with the BHoM are subject to the General Disclaimer.</p> <p>The confidence is split into 5 distinct categories, and the creator/distributor/maintainer of the dataset should always aim for the highest level of confidence achievable.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#undefined","title":"Undefined","text":"<p>Default value - assume no fidelity and no source.</p> <p>Should generally be avoided when adding a new Dataset for distribution with the BHoM - one of the levels below should be explicitly defined.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#none","title":"None","text":"<p>The Dataset may not have a reliable source and/or fidelity to the source has not been tested.</p> <p>To be used for prototype Datasets where no reliable data is available, and not for general distribution within the BHoM. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#low","title":"Low","text":"<p>The Dataset comes from an unreliable source, but the data matches the source based on initial checks.</p> <p>For cases where no reliable source for the data type is available. Can be allowed to be distributed with the BHoM in circumstances where no reliable source can be found and the data still can be deemed useful.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#medium","title":"Medium","text":"<p>The Dataset comes from a reliable source and matches the source based on initial checks.</p> <p>For most cases the minimum required level of confidence for distribution of a Dataset with the BHoM. To reach this level of confidence, the Source object should be properly filled in, and a substantial spot checking of the data should have been made. If at all possible, maintainers of a Medium confidence level Dataset should strive to fulfil the requirements of High confidence.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Accessing-Datasets-in-code/#high","title":"High","text":"<p>The Dataset comes from a reliable source and matches the source based on extensive review and testing.</p> <p>Highest level of confidence for BHoM datasets, and should generally be the aspiration for all Datasets included with the BHoM.</p> <p>To achieve this, a clear testing procedure should generally be in place, which outlines how all of the data points in the Dataset have been checked against the source data and/or verified by other means to be correct.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Creation-of-Datasets/","title":"Creation of Datasets","text":"<p>Datasets are a way to store and distribute BHoMObjects for use by others. For example, a list of standard structural materials or section properties as well as global warming potential for various materials.</p> <p>The data should be serialised in a Dataset object, and the relevant <code>.csproj</code> file in the repo, in which the Dataset is stored, should have a post build event implemented that ensures that the Dataset is copied to the <code>C:\\ProgramData\\BHoM\\Datasets folder</code>. This will allow it to be picked up by the <code>Library_Engine</code>.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Creation-of-Datasets/#generate-a-new-dataset","title":"Generate a new dataset","text":"<p>To generate a new dataset to be used with the BHoM the following steps should be taken.</p> <ol> <li> <p>Generate the objects to be stored in the new Dataset. This means creating the BHoMObject of the correct type in any of the supported UIs. See below for an example of how to create a handful of standard European steel materials in Grasshopper. Remember to give the created objects an easily identifiable name as the name is what will show up when using the data in the dropdowns. Remember that all BHoM objects should be defined in SI units.</p> <p></p> </li> <li> <p>Store the created objects in a Dataset object and give the dataset an appropriate name. This is the name for the dataset - the name that appears in the UI is described the next step.</p> <p></p> </li> <li> <p>Populate the source object and assign it to the dataset. See guidance below regarding the source.</p> <p></p> </li> <li> <p>Convert the dataset object and store it to a single line json file. This is easiest done using the FileAdapter. The library engine relies on the json files to be a single line per object, while the default json output from the FileAdapter is putting the json over multiple lines. To make sure the produced json file is in the correct format for the library engine, provide a File.PushConfig with <code>UseDatasetSerialization</code> set to true and <code>BeautifyJson</code> set to <code>false</code> to the push command. Name the file something clearly identifiable, as the name of the file will be what is used to identify the dataset by the library engine, and will be what it is called in the UI menu.</p> <p></p> </li> <li> <p>For personal use, do one of the following:</p> <ol> <li>Place the file in the relevant subfolder of the C:\\ProgramData\\BHoM\\Datasets folder. If no relevant subfolder already exists, a new one can be added. The folder will be used to generate the menus used to find the dataset in the menu system, and also makes a whole folder searchable using the Library method. Remember that running an installer will reset the datasets folder so for this option backup the json file, or use option ii.</li> <li>Place the json file in a subfolder of a folder of your own choice and use the custom dataset folder outlined below.</li> </ol> </li> <li>For distribution of the Dataset to the BHoM community do the following:<ol> <li>Store the dataset in the appropriate repository folder:<ul> <li>For a general dataset, such as standard materials etc., place the json file in an appropriate subfolder folder in BHoM_Datasets.</li> <li>For a toolkit specific dataset put the json file in a Dataset folder in the root folder of the toolkit to host the dataset. If no such folder exist, it should be created. Make sure that the oM project in the toolkit has the following post-build event code: <code>xcopy \"$(SolutionDir)DataSets\\*.*\" \"C:\\ProgramData\\BHoM\\DataSets\" /Y /I /E</code> that ensures that the dataset is copied over to the C:\\ProgramData\\BHoM\\Datasets folder.</li> </ul> </li> <li>Raise a Pull request on GitHub and ask for review from relevant parties.</li> </ol> </li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Datasets/Creation-of-Datasets/#custom-dataset-folder","title":"Custom dataset folder","text":"<p>By default, the Library_Engine scans the C:\\ProgramData\\BHoM\\Datasets for all json files and loads them up to be queryable by the UI and the methods in the library engine. This location is reset with each BHoM install to make sure all datasets are up-to-date and that any modifications or fixes correctly are applied to the data. For some cases it can be also useful to have your own datasets stored in your own folder for example on a network drive to share during work on a particular project.</p> <p>For these reasons it is possible to get the Library_Engine to scan other folders for datasets as well. This can easily be controlled via the AddUserPath and RemoveUserPath commands that can be called from any UI. After the AddUserPath command has been run once for a particular folder, the library engine will store the information about this folder in its settings and will keep on looking in subfolders of that location for any json files to be used as dataset.</p> <p></p> <p>To stop the Library_Engine from looking in this particular folder, use the RemoveUserPath command, providing a link to the folder you no longer want to be scanned by the Library_Engine.</p> <p></p> <p>Remember that the menu system of the Dataset dropdown components are built up using the subfolders, so even if only a single dataset is placed in this custom folder it might be a good idea to still put your json file in an appropriate subfolder.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/","title":"Diffing and Hashing: guide for developers","text":"<p>This page gives a more in-depth technical explanation about some diffing methods, and also serves as a guide for developers to build functionality on top of existing diffing code. See the Diffing and the Hash wiki pages for a more quick-start guide.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#contents","title":"Contents","text":"<ul> <li>Developing Toolkit-specific diffing methods</li> <li>IDiffing() method: internal workings</li> <li>Invoking of the Toolkit-specific diffing methods</li> <li>What happens for objects that do not have a Toolkit-specific diffing method</li> <li>Other Diffing methods inner workings</li> <li>ObjectDifferences() method inner workings</li> <li>Mapping our ComparisonConfig to Kellerman library</li> <li>Customising the Diffing output: ComparisonInclusion() extension method</li> <li>Customising the Hash: HashString() extension method</li> <li>Toolkit-specific ComparisonConfig options</li> <li>Testing and profiling</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#developing-toolkit-specific-diffing-methods","title":"Developing Toolkit-specific diffing methods","text":"<p>The <code>IDiffing()</code> method is designed to be a \"universal\" entry point for users wanting to diff their objects; for this reason, it has an automated mechanism to call any Toolkit-specific diffing method that can is compatible with the input objects. This work similarly to the Extension Method discovery pattern that is often leveraged in many BHoM methods.</p> <p>A Toolkit-specific Diffing method is defined as a method: - that is <code>public</code>; - whose name ends with <code>Diffing</code>; - that has the following inputs:   - a first <code>IEnumerable&lt;object&gt;</code> for the past objects;   - a second <code>IEnumerable&lt;object&gt;</code> for the following objects;    - any number of optional parameters;   - a final <code>DiffingConfig</code> parameter (that should default to <code>null</code>, and be auto initialised if null within the implementation).</p> <p>Any method that respect these criteria is discovered and stored during the assembly loading through this method. It gets invoked by the <code>IDiffing()</code> as explained here.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#idiffing-method-internal-workings","title":"<code>IDiffing()</code> method: internal workings","text":"<p>The IDiffing method does a series of automated steps to ensure that the most appropriate diffing method gets invoked for the input objects.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#invoking-of-the-toolkit-specific-diffing-methods","title":"Invoking of the Toolkit-specific diffing methods","text":"<p>The IDiffing first looks for any Toolkit-specific diffing method that is compatible with the input objects (relevant code here). This is done by checking if there is a <code>IPersistentAdapterId</code> stored on the objects; if there is, the namespace to which that <code>IPersistentAdapterId</code> object belongs is taken as the source namespace to get a compatible Toolkit-specific diffing method. For example, if the input objects own a <code>RevitIdentifier</code> fragment (which implements <code>IPersistentAdapterId</code>), then the namespace <code>BH.oM.Adapters.Revit.Parameters</code> is taken. This namespace, which is an <code>.oM</code> one, is \"modified\" to an <code>.Engine</code> one, so the related Toolkit Engine is searched for a diffing method. </p> <p>If a Toolkit-specific diffing method match is found, that is then invoked. For example, this is how <code>RevitDiffing()</code> gets called by the IDiffing. Note that only the first matching method gets invoked. This is because we only allow to have 1 Toolkit-specific diffing method. If you have method overloading over your Toolkit-specific Diffing method (for example, because you want to provide the users with multiple choices when they choose to invoke directly your Toolkit-specific diffing method), you must ensure that all overloads are equally valid and can any can be picked by the IDiffing with the same results (like it happens for <code>RevitDiffing()</code>: all methods end up calling a single, <code>private</code> Diffing method, and additional inputs are optional, so they all behave the same if called by the IDiffing).</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#what-happens-for-objects-that-do-not-have-a-toolkit-specific-diffing-method","title":"What happens for objects that do not have a Toolkit-specific diffing method","text":"<p>If the previous step does not find any <code>Toolkit-specific diffing method</code> compatible with the input objects, then a variety of steps are taken to try possible diffing methods. In a nutshell, a series of checks are done on the input objects to see what diffing method is most suitable. This is better described in the following diagram. For more details on each individual diffing method, see here.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#other-diffing-methods-inner-workings","title":"Other Diffing methods inner workings","text":"<p>In addition to the main Diffing method <code>IDiffing()</code>, there are several other methods that can be used to perform Diffing. These are a bit more advanced and should be used only for specific cases. All diffing methods can be found in the Compute folder of Diffing_Engine.</p> <p>Most diffing methods are simply relying on an ID that is associated to the input objects, or a similar way to determine which object should be compared to which. Once a match is found, the two matched objects (one from the <code>pastObjects</code> set and one from the <code>followingObjects</code> set) are sent to the <code>ObjectDifferences()</code> method, as illustrated by the following diagram.  </p> <p>This diagram also illustrates that only the <code>DiffWithHash()</code> method does not rely on the <code>ObjectDifferences()</code> method. The <code>DiffWithHash()</code> is a rather simple and limited method, in that it cannot identify Modified objects but only new/old ones, and it is described here.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#objectdifferences-method-inner-workings","title":"<code>ObjectDifferences()</code> method inner workings","text":"<p>As shown above, the method that does most of the work in diffing is the <code>BH.Engine.Diffing.Query.ObjectDifferences()</code> method. </p> <p>This is the method that has the task of finding all the differences between two input objects. This method currently leverages an open-source, free library called <code>CompareNETObjects</code> by Kellerman software. It maps our <code>ComparisonConfig</code> options to the equivalent class in the <code>CompareNETObjects</code> library, and then executes the comparison using it.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#mapping-our-comparisonconfig-to-kellerman-library","title":"Mapping our <code>ComparisonConfig</code> to Kellerman library","text":"<p>Because not all of the options available in the ComparisonConfig are mappable to Kellerman's, <code>ObjectDifferences()</code> has to adopt a workaround. For example, our numerical approximation options are not directly compatible. The general compatibility strategy is: - if an option is mappable/convertible, map/convert it from our <code>ComparisonConfig</code> to Kellerman's <code>CompareLogic</code> object. This is true for most of them. - if an option is not compatible with Kellerman (like our numerical approximation options), set Kellerman <code>CompareLogic</code> so it finds all possible differences with regards to that option (like we do for numerical differences), then iterate the differences found and cull out those that are non relevant (example for the numerical differences).</p> <p>The loop to iterate over the differences found by Kellerman is also useful to further customise the output, as shown by the following section.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#customising-the-diffing-output-comparisoninclusion-extension-method","title":"Customising the Diffing output: <code>ComparisonInclusion()</code> extension method","text":"<p>In order to customise our diffing output, we want to customise how the <code>ObjectDifferences()</code> method determines the differences between objects. This is done through a specific <code>ComparisonInclusion()</code> extension method that is invoked when we loop through the differences found by the Kellerman library. This is essentially an application of the Extension Method discovery pattern that is often leveraged in many BHoM methods.</p> <p>You can implement a <code>ObjectDifferences()</code> method in your Toolkit to customise how the difference between two specific objects is to be considered by the diffing. This method must have the following inputs, in this order: - a fist object input (which will be the object coming from the <code>pastObjs</code> set); - a second object input, of the same type as the first object (which will be the object coming from the <code>followingObjs</code> set); - a <code>string</code> input, which will contain the Full Name of the property difference found by the <code>ObjectDifferences()</code> method; - a <code>BaseComparisonConfig</code> input, which will be passed in by the <code>ObjectDifferences()</code> method.</p> <p>The method must return a <code>ComparisonInclusion</code> object, which will contain information on whether the difference should be included or not, and how to display it.</p> <p>Here is an example of <code>ComparisonInclusion()</code> for RevitParameters: <pre><code>public static ComparisonInclusion ComparisonInclusion(this RevitParameter parameter1, RevitParameter parameter2, string propertyFullName, BaseComparisonConfig comparisonConfig)\n{\n    // Initialise the result.   \n    ComparisonInclusion result = new ComparisonInclusion();\n\n    // Differences in any property of RevitParameters will be displayed like this.\n    result.DisplayName = parameter1.Name + \" (RevitParameter)\"; \n\n    // Check if we have a RevitComparisonConfig input.\n    RevitComparisonConfig rcc = comparisonConfig as RevitComparisonConfig;\n\n    // Other logic\n    ...\n}\n</code></pre></p> <p>Note that this method supports Toolkit-specific <code>ComparisonConfig</code> objects, like e.g. <code>RevitComparisonConfig</code>. See the section below for more details.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#customising-the-hash-hashstring-extension-method","title":"Customising the Hash: <code>HashString()</code> extension method","text":"<p>If you want a specific object to be Hashed in a particular way, you can implement a <code>HashString()</code> extension method for that object in your Toolkit. The <code>HashString()</code> method will get invoked when computing the Hash(). This is essentially an application of the Extension Method discovery pattern that is often leveraged in many BHoM methods.</p> <p>This method must have the following inputs, in this order: - An object input, which will be the object for which we are calculating the Hash. - A <code>string</code> input, which will indicated the FullName of the property being analysed by the Hash() method (for example when the input object is a property of another object; this can be useful in certain cases, and if not useful can simply be ignored). - A <code>BaseComparisonConfig</code> input, which can be used to  will be passed in by the <code>Hash()</code> method.</p> <p>Here is an example of <code>HashString()</code> for RevitParameters:</p> <pre><code>public static string HashString(this RevitParameter revitParameter, string propertyFullName = null, BaseComparisonConfig comparisonConfig = null)\n{\n    // Null check.\n    if (revitParameter == null) return null;\n\n    string hashString = revitParameter.Name + revitParameter.Value;\n\n    // Check if we have a RevitComparisonConfig input.\n    RevitComparisonConfig rcc = comparisonConfig as RevitComparisonConfig;\n\n    // Other logic\n    ...\n}\n</code></pre> <p>Note that this method supports Toolkit-specific <code>ComparisonConfig</code> objects, like e.g. <code>RevitComparisonConfig</code>. See the section below for more details.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#toolkit-specific-comparisonconfig-options","title":"Toolkit-specific <code>ComparisonConfig</code> options","text":"<p>There are cases where you may need more options to further customise the Hash or Diffing process, to refine how they work with your Toolkit's objects.</p> <p>The \"default\" <code>comparisonConfig</code> object gives all the default options, and it inherits from the <code>BaseComparisonConfig</code> abstract class. This abstract class can be extended by the \"Toolkit-specific\" <code>comparisonConfig</code>s, so you can include additional options to deal with certain objects in your Toolkit. See an example with Revit's <code>RevitComparisonConfig</code>.</p> <p>If you implement your own Toolkit-specific <code>ComparisonConfig</code> object, you will need to implement the functions that deal with it too, which should include at least one of: - A toolkit-specific <code>Diffing()</code> method (example in Revit), which your users can call independently, or that may be automatically called by the IDiffing method, as shown here. - A toolkit-specific <code>HashString()</code> method (example in Revit), which will get invoked when computing the Hash().  - Any number of <code>ComparisonInclusion()</code> methods that you might need to customise the diffing output per each object (example in Revit for RevitParameters), as explained here. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Diffing%20and%20Hashing/Diffing-and-Hashing-%E2%80%93-guide-for-developers/#testing-and-profiling","title":"Testing and profiling","text":"<p>We have a DiffingTests repo which contains Unit Tests and profiling functions. These are required given the amount of options and use cases that both offer.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/","title":"Coding BHoM in a Grasshopper CSharp script component","text":"<p>BHoM can be referenced and used in a Grasshopper \"C# Script\" component. The only additional requirement as of the current version is to also reference <code>netstandard.dll</code> in the same Grasshopper component.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#find-the-net-standard-assembly-dll-file","title":"Find the .NET Standard assembly dll file","text":"<p>Currently, a reference to the .NET Standard assembly is required to use BHoM from a C# script component in Grasshopper. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#download-or-find-on-your-drive-the-net-standard-assembly","title":"Download (or find on your drive) the .NET Standard assembly","text":"<p>You can download the right version of <code>netstandard.dll</code> (currently, 2.0.3 is the one used in BHoM) from here: 1. Click on \"download package\". 2. Open the downloaded <code>.npckg</code> file with a Zip archiver like 7zip. 3. Go in the folder <code>build/netstandard2.0/ref/</code> and you will find <code>netstandard.dll</code>. 4. Place the <code>netstandard.dll</code> somewhere in your C: drive where you will be able to find it, and remember that location. You could place it in the BHoM installation directory (normally <code>C:\\ProgramData\\BHoM\\</code>), but be aware that if you reinstall or update BHoM it will get deleted.</p> <p>Note</p> <p>If you downloaded <code>netstandard.dll</code> previously but you can't remember where you placed it, you can search for a copy of <code>netstandard.dll</code> in your disk.  \u26a0\ufe0f However, there could be multiple copies/versions of a <code>netstandard.dll</code> file on your drive. If you find multiple files called <code>netstandard.dll</code>, then it's better to re-download it from the link above to make sure you are using the right version. \u26a0\ufe0f</p> <p>Search for <code>netstandard.dll</code> in Explorer from your C: drive:</p> <p></p> <p>Once found, get its location by right-clicking on it and doing \"Open location\", then copy the location in Explorer. Take note of it.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#reference-the-assemblies-in-the-c-script-component","title":"Reference the assemblies in the C# Script component","text":"<p>To start coding let's create a \"C# Script\" component in Grasshopper where we will reference the required DLLs.</p> <ol> <li>Drop a \"C# Script\" component in the canvas.</li> <li>Right click it, do \"Manage Assemblies\". A window will pop up.</li> <li>Click \"Add\". A File Explorer window will pop up.</li> <li>Add a reference to the <code>netstandard.dll</code> file, found as explained above. Select it and do \"Open\". You will see that it appears in the Referenced Assemblies section.</li> <li>Click \"Add\" again. Navigate to the BHoM assemblies directory (normally <code>C:\\ProgramData\\BHoM\\Assemblies</code>). There you will find all BHoM DLLs. As a minimum, we will want to include <code>BHoM.dll</code> and <code>BHoM_Engine.dll</code>. We can add as many as we need, but don't add them all together. You will come back to add more in case the script complains that some are missing.</li> </ol> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#start-scripting","title":"Start scripting!","text":"<p>Let's make an example where we want to create a <code>BH.oM.Geometry.Point</code> object in the script. To do so, we need to add another 2 references, <code>Geometry_oM.dll</code> and <code>Dimensional_oM.dll</code>. Let's do that as explained above. We will end up having the following:</p> <p></p> <p>Next, let's open the script and write: <pre><code>BH.oM.Geometry.Point p = new BH.oM.Geometry.Point();\np.X = 3;\np.Y = 5;\np.Z = 1;\n\nA = p;\n</code></pre></p> <p>You will have this:</p> <p></p> <p>Press OK, and voila, a BHoM point is created! You can also check its values with the <code>Explode</code> component:</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#script-with-more-complex-objects","title":"Script with more complex objects","text":"<p>Do the same for any other BHoM object you may want to create. Using more complex objects will require to add more references, like explained in the previous section. For example, if we want to create a structural node with this point, we can do:</p> <pre><code>BH.oM.Geometry.Point p = new BH.oM.Geometry.Point();\np.X = 3;\np.Y = 5;\np.Z = 1;\n\nBH.oM.Structure.Elements.Node node = new BH.oM.Structure.Elements.Node();\nnode.Position = p;\n\nA = p;\n</code></pre> <p>However, if you press OK, you will be met with an error like:</p> <p></p> <p>This simply means that you need to add references to <code>Structure_oM.dll</code>. If we add that and try again, the error will still not go away, but will be different:</p> <p></p> <p>This is because the <code>Structure_oM.dll</code> itself depends on <code>Analytical_oM.dll</code>. By adding this last dependency the error will go away.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#simplfying-namespaces","title":"Simplfying namespaces","text":"<p>For complex C# script components where multiple object types are used, it can be cumbersome to type <code>BH.oM.Geometry.Node</code> everytime you want to create a <code>Node</code>. </p> <p>On L13 of the C# component you can add references to specific namespaces:</p> <p></p> <p>Note</p> <p>You need to be mindful that the BHoM object types do not clash with the Rhino object types. For example, on L13 <code>using BH.oM.Geometry</code> and trying to use a <code>Point</code> object will return an error.</p> <p>That is because on L6 there is a reference to <code>Rhino.Geometry</code> and the component cannot distinguish between a Rhino.Geometry.Point and a BH.oM.Geometry.Point.</p> <p>A workaround to this is to shortern the namespace. For example, <code>using BHG = BH.oM.Geometry</code> will allow you to use <code>BHG.Point</code> without causing an ambiguity error with a <code>Rhino.Geometry.Point</code>.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/BHoM-Grasshopper-CSharp/#using-bhom-objects-as-inputs","title":"Using BHoM objects as inputs","text":"<p>If you want to use a BHoM object as an input for the C# component, you need to first change the type hint to <code>System.Object</code>:</p> <p></p> <p>When you use the object in the script, you need to first cast it to a BHoM object. Then you can use the object as you would in any other IDE:</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/","title":"Using Visual Studio Code For BHoM Development","text":"<p>Visual Studio Code as of June 2023 is a viable option for .Net and C# development on windows. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/#required-software","title":"Required Software","text":"<ul> <li>VS Code</li> <li>C# Dev Kit</li> <li>C# Intellisense</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/#required-configuration","title":"Required Configuration","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/#attach-to-process-for-debugging","title":"Attach to Process For Debugging","text":"<p>Add a folder to your tool's root directory titled <code>.vscode</code> Add a file to <code>.vscode</code> folder titled <code>launch.json</code> <pre><code>Tool_Repo_Folder\n|\n|--- .vscode\n      |\n      |---launch.json\n</code></pre></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/#attach-to-process-of-your-choosing","title":"Attach to process of your choosing","text":"<p>within your <code>launch.json</code> add the following</p> <pre><code>{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    //To attach to running process of your choosing\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Attach to Process\",\n            \"type\": \"clr\", \n            \"request\": \"attach\",\n            \"processId\": \"${command:pickProcess}\"\n        }\n      ],\n        \"postDebugTask\": \"echo\"\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/#attach-to-running-process-of-pre-defined-name","title":"Attach to running process of pre-defined name","text":"<p>within your <code>launch.json</code> add the following</p> <pre><code>{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    //To attach to running process automatically\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n         {\n             \"name\": \"Attach to Revit\",\n             \"type\": \"coreclr\", \n             \"request\": \"attach\",\n             \"processName\": \"Revit.exe\",\n             \"justMyCode\": false\n         }\n    ],\n        \"postDebugTask\": \"echo\"\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/IDEs/Using%20Visual%20Studio%20Code/#working-as-a-team","title":"Working As A Team","text":"<p>Not all members of the team will want to work in VS Code. Please be considerate of this as you develop by adding the <code>.vscode</code> folder to your <code>.gitignore</code></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/","title":"Revit Toolkit intro","text":"<p>Welcome to the Revit Toolkit documentation! </p> <p>Here you will find information on what Revit_Toolkit can do for you as well as how to make that (and even more) happen. </p> <p>Feel free to explore and raise an issue if you need or do not like something. Enjoy!</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/#overview","title":"Overview","text":"<p>Revit_Toolkit includes a range of support classes and methods that extend the core BHoM to embrace the complexity of Revit. These, among others, are:</p> <ul> <li>dedicated Requests supported by a range of filtering methods that allow specified queries</li> <li>BHoM wrappers for Revit elements: <code>Sheets</code>, <code>Viewports</code>, <code>IViews</code>, <code>DraftingInstances</code>, <code>ModelInstances</code> etc.</li> <li>general methods to process Revit elements and documents, mainly for conversion and adapter processing purposes</li> </ul> <p>All relevant methods and classes are <code>public</code>, therefore other applications can be built upon the code base of Revit_Toolkit (see simple Forms app sample).</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Geometry%20Conversion/","title":"Geometry conversion","text":"<p>The table below presents geometry conversion methods offered by Revit_Toolkit.</p> Revit type  Supported conversion direction BHoM type <code>Autodesk.Revit.DB.XYZ</code> &lt; - &gt; <code>BH.oM.Geometry.Point</code> <code>Autodesk.Revit.DB.XYZ</code> &lt; - &gt; <code>BH.oM.Geometry.Vector</code> <code>Autodesk.Revit.DB.Plane</code> &lt; - &gt; <code>BH.oM.Geometry.CoordinateSystem.Cartesian</code> <code>Autodesk.Revit.DB.Line</code> &lt; - &gt; <code>BH.oM.Geometry.Line</code> <code>Autodesk.Revit.DB.Arc</code> &lt; - &gt; <code>BH.oM.Geometry.Arc</code> / <code>BH.oM.Geometry.Circle</code> <code>Autodesk.Revit.DB.Ellipse</code> &lt; - &gt; <code>BH.oM.Geometry.Ellipse</code> <code>Autodesk.Revit.DB.NurbSpline</code> &lt; - &gt; <code>BH.oM.Geometry.NurbsCurve</code> <code>Autodesk.Revit.DB.HermiteSpline</code> - &gt; <code>BH.oM.Geometry.NurbsCurve</code> <code>Autodesk.Revit.DB.Analysis.Polyloop</code> - &gt; <code>BH.oM.Geometry.Polyline</code> <code>Autodesk.Revit.DB.PolyLine</code> - &gt; <code>BH.oM.Geometry.Polyline</code> <code>Autodesk.Revit.DB.CurveLoop</code> &lt; - &gt; <code>BH.oM.Geometry.PolyCurve</code> <code>Autodesk.Revit.DB.Solid</code> &lt; - <code>BH.oM.Geometry.ISurface</code> <code>Autodesk.Revit.DB.Solid</code> &lt; - <code>BH.oM.Geometry.BoundaryRepresentation</code> <p>In a special case where Revit requires an unbound curve (e.g. in case of floor outlines) closed BHoM curves are split in half to create a continuous loop consisting of two unbound Revit curves.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Handling%20of%20Parameters/","title":"Handling of Parameters","text":"<p>Efficient handling of Revit parameters is one of the key features of Revit_Toolkit. It is possible thanks to <code>RevitParameter</code> BHoM wrappers that are being generated per each parameter of an element (and its type) on Pull and unwrapped on Push. </p> <p><code>RevitParameters</code> are stored in dedicated fragments that are attached to the BHoM object correspondent with the Revit element. For full control over what is pulled vs what is pushed, separate fragments for Pull (<code>RevitPulledParameters</code>) and Push (<code>RevitParametersToPush</code>) are used.</p> <p>Diagram below shows the relationship between <code>RevitPulledParameters</code> and Push <code>RevitParametersToPush</code>:</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Handling%20of%20Parameters/#getting-and-setting-parameter-values-in-one-diagram","title":"Getting and setting parameter values in one diagram","text":"<p>The diagram below shows how to get or set the parameter values depending on whether they are type or instance.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Handling%20of%20Parameters/#parameter-mapping","title":"Parameter mapping","text":"<p>It may sometimes happen that different families have the same value stored under different parameter names. In such case, there is a need to map the values from more than one source into a single set. This can be done with the use of custom mapping settings that are part of Revit adapter settings.</p> <p><code>MappingSettings</code> object has a property named <code>ParameterMaps</code> that can contain parameter maps, each containing a set of <code>ParameterLinks</code> that define following relationships: - relationship between the name of a Revit parameter and the name of a property of a BHoM object, to which its value will be assigned on Pull - relationship between the name of a Revit parameter and the name under which the value will be stored in <code>RevitPulledParameters</code> on Pull - the opposite to the first: relationship between the name of a property of a BHoM object, which value will be assigned to a given Revit parameter on Push - the opposite to the second: relationship between the name under which the value is stored in <code>RevitParametersToPush</code> and the name of a Revit parameter to which it will be assigned on Push</p> <p>If multiple Revit parameter names will be mapped into one name on the BHoM side: - on Pull: first parameter found in the Revit element under one of the specified names will be copied over to the BHoM object - on Push: the value originating from the BHoM object will be copied over to the first existing parameter found in the Revit element under one of the specified names</p> <p>What is more, mapping can also be applied to type parameters, using <code>ElementTypeParameterLinks</code>.</p> <p>Parameter maps are created per type, therefore a map specified for columns will not affect e.g. walls. The whole concept is mapped out in the diagram below.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Programmatic%20Filtering/","title":"Programmatic filtering","text":"<p>On code level, each Revit-applicable type that inherits from <code>IRequest</code> is coupled with a <code>BH.Revit.Engine.Core.ElementIds</code> method that extracts the ElementIds of Revit elements that match the requirements it imposes. These methods can be used without prior creation of <code>IRequest</code>.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Pull%20from%20Revit%20Details/","title":"Pull from Revit Details","text":"<p>This chapter explains in detail the Pull action - it is recommended to read Revit Adapter details section first for the information about mechanics of the adapter itself.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Pull%20from%20Revit%20Details/#pull-options-requests-and-revitpullconfig","title":"Pull options: Requests and RevitPullConfig","text":"<p>As explained in Pull from Revit basics, there are two action-specific inputs that drive Pull:</p> <ul> <li>Request of type deriving from <code>IRequest</code> explained in more detail in a dedicated section</li> <li>Action config of type <code>RevitPullConfig</code></li> </ul> <p>They are specified as arguments of the <code>Pull</code> method of <code>RevitAdapter</code>. Depending on the thread on which the <code>Pull</code> method is executed, they will be either sent via Sockets as a data package (if <code>Pull</code> is executed outside of Revit thread) or passed directly to <code>RevitUIAdapter</code> (if everything is run on a single Revit thread).</p> <p>Next, <code>RevitUIAdapter</code> triggers Pull action, which points directly to <code>Read</code> CRUD method. <code>Read</code> executes following tasks:</p> <ol> <li>Collects ElementIds of Revit elements that meet requirements set by the Request (done in <code>BH.Revit.Engine.Core.Query.ElementIds</code>).</li> <li> <p>Checks discipline enforced by:</p> <ul> <li>Request - this happens e.g. when the filter is <code>FilterRequest</code> with <code>Type</code> property equal to <code>BH.oM.Structure.Elements.Bar</code> - pulling of elements of given type is possible only for structural discipline</li> <li><code>RevitPullConfig</code> - value carried by <code>Discipline</code> property</li> </ul> <p>If discipline is not enforced by any of the two above, <code>Discipline.Physical</code> is used as default. Conflict between disciplines is not allowed: if both Request and <code>RevitPullConfig</code> enforce a discipline (none of them is equal to <code>Discipline.Undefined</code>) and the disciplines enforced by each are not equal, the operation is cancelled with an error. 3. Retrieves the Revit elements under ElementIds from point 1. and converts them to BHoM for discipline determined in point 2. Conversion of all elements is being driven by <code>BH.Revit.Engine.Core.Convert.IFromRevit</code> dispatcher method combined with <code>BH.Revit.Engine.Core.Query.IBHoMType</code> and <code>BH.Revit.Engine.Core.Query.ConvertMethod</code> queries. To avoid converting any of the objects more than once, identifier of each object that has been converted in a given adapter action is being stored in <code>refObjects</code> dictionary together with the output of the convert.</p> </li> </ol> <p>The usual flow looks as in the picture below:</p> <p></p> <ol> <li>If <code>PullGeometryConfig</code> contains instruction to pull geometry, it is extracted from the elements and attached to the output BHoM objects as <code>RevitRepresentation</code> fragments.</li> <li>If <code>PullRepresentationConfig</code> contains instruction to pull mesh representation, it is extracted from the elements and attached to the output BHoM objects as <code>RevitRepresentation</code> fragments.</li> </ol> <p>Finally, the converted BHoM objects are returned to <code>RevitAdapter</code> (using a Sockets bypass if <code>RevitAdapter</code> and <code>RevitUIAdapter</code> do not run on the same thread).</p> <p>The diagram below maps out the above workflow - it should be read as an action-specific variation of the Adapter action stage of the general Adapter flowchart.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Push%20to%20Revit%20Details/","title":"Push to Revit Details","text":"<p>This chapter explains in detail the Push action.</p> <p>Note</p> <p>It's recommended to read Revit Adapter details section first for the information about mechanics of the adapter itself.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Push%20to%20Revit%20Details/#main-inputs-to-the-push-action","title":"Main inputs to the Push action","text":"<p>As explained in Push to Revit basics, there are three action-specific inputs that drive Push:</p> <ul> <li>Objects, an <code>IEnumerable&lt;IBHoMObject&gt;</code> to be pushed to Revit</li> <li>Push type of type <code>BH.oM.Adapter.PushType</code> explained in more detail below.</li> <li>Action config of type <code>RevitPushConfig</code></li> </ul> <p>They are specified as arguments of the <code>Push</code> method of <code>RevitAdapter</code>. Depending on the thread on which the <code>Push</code> method is executed, they will be either sent via Sockets as a data package (if <code>Push</code> is executed outside of Revit thread) or passed directly to <code>RevitUIAdapter</code> (if everything is run on a single Revit thread).</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Push%20to%20Revit%20Details/#pushtype","title":"PushType","text":"<p>Push type specifies the way in which Revit elements should be created and updated. The <code>RevitUIAdapter</code> triggers the Push action, which, depending on <code>PushType</code>, executes to a combination of <code>Delete</code>, <code>Create</code> and <code>Update</code> CRUD methods, as explained below. </p> <ul> <li>If <code>PushType</code> includes deleting Revit elements, <code>Push</code> method collects ElementIds of Revit elements that are linked to relevant BHoM objects and deletes them by calling Delete CRUD method.</li> <li>If <code>PushType</code> includes creating Revit elements, <code>Push</code> method creates new Revit elements based on BHoM objects by calling Create CRUD method. Conversion is driven by <code>BH.Revit.Engine.Core.Convert.IToRevit</code> dispatcher method. To avoid converting any of the objects more than once, identifier of each object that has been converted in a given adapter action is being stored in <code>refObjects</code> dictionary together with the output of the convert.</li> <li> <p>If <code>PushType</code> includes updating Revit elements, <code>Push</code> method collects ElementIds of Revit elements that are linked to relevant BHoM objects and updates them by calling Update CRUD method. Two methods are required to explicitly update a Revit element of given type:</p> <ul> <li>type-specific <code>BH.Revit.Engine.Core.Modify.Update</code> that handles properties and parameters</li> <li>type-specific <code>BH.Revit.Engine.Core.Modify.SetLocation</code> that handles geometry of the element</li> </ul> <p>The above are being dispatched by <code>BH.Revit.Engine.Core.Modify.IUpdate</code> and <code>BH.Revit.Engine.Core.Modify.ISetLocation</code> respectively. If type-specific <code>Update</code> method does not exist, only the parameter values will be copied over to the Revit element, as explained here.</p> </li> </ul> <p>Finally, the successfully pushed BHoM objects are returned to <code>RevitAdapter</code> (using a Sockets bypass if <code>RevitAdapter</code> and <code>RevitUIAdapter</code> do not run on the same thread).</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Push%20to%20Revit%20Details/#flow-chart-explanation-for-coders","title":"Flow-chart explanation (for coders)","text":"<p>The diagram below maps out the above workflow - it should be read as an action-specific variation of the Adapter action stage of the general Adapter flowchart.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Remove%20from%20Revit%20Details/","title":"Remove from Revit Details","text":"<p>This chapter explains in detail the Remove action - it is recommended to read Revit Adapter details section first for the information about mechanics of the adapter itself.</p> <p>As explained in Remove from Revit basics, there are two action-specific inputs that drive Remove: - Request of type deriving from <code>IRequest</code> explained in more detail in a dedicated section - Action config of type <code>RevitRemoveConfig</code></p> <p>They are specified as arguments of the <code>Revit</code> method of <code>RevitAdapter</code>. Depending on the thread on which the <code>Remove</code> method is executed, they will be either sent via Sockets as a data package (if <code>Remove</code> is executed outside of Revit thread) or passed directly to <code>RevitUIAdapter</code> (if everything is run on a single Revit thread).</p> <p>Next, <code>RevitUIAdapter</code> triggers Remove action, which points directly to <code>Delete</code> CRUD method. <code>Delete</code> executes following tasks: 1. Collects ElementIds of Revit elements that meet requirements set by the Request (done in <code>BH.Revit.Engine.Core.Query.ElementIds</code>). 2. Deletes the Revit elements under ElementIds from point 1.</p> <p>Finally, the number of deleted elements is returned to <code>RevitAdapter</code> (using a Sockets bypass if <code>RevitAdapter</code> and <code>RevitUIAdapter</code> do not run on the same thread).</p> <p>The diagram below maps out the above workflow - it should be read as an action-specific variation of the Adapter action stage of the general Adapter flowchart.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Revit%20Adapter%20Details/","title":"Revit Adapter Details","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Revit%20Adapter%20Details/#code-structure","title":"Code structure","text":"<p>The code of Revit_Toolkit has some differences with other Toolkits, because we need to reference the Revit API, which needs to run inside a Revit thread. </p> <p>Therefore, Revit_Toolkit split into two realms:</p> <ul> <li>BHoM side - standard BHoM toolkit structure:<ul> <li>Revit_oM (<code>BH.oM.Adapters.Revit</code>) - Revit_Toolkit-specific classes, mainly settings/config and wrappers for Revit types</li> <li>Revit_Engine (<code>BH.Engine.Adapters.Revit</code>) - methods to process the objects from Revit_oM</li> <li>Revit_Adapter (<code>BH.Adapter.Revit</code>) - BHoM side of Revit-specific implementation of <code>BHoMAdapter</code> without CRUD, which is sitting on the Revit side of the solution (see below)</li> </ul> </li> <li>Revit side:<ul> <li>Revit_Core_Adapter (<code>BH.Revit.Adapter.Core</code>) - Revit side of Revit-specific implementation of <code>BHoMAdapter</code>, including adapter action methods, CRUD as well as Revit Listener plugin and event handlers</li> <li>Revit_Core_Engine (<code>BH.Revit.Engine.Core</code>) - methods to process Revit objects (filter, convert, query etc.)</li> </ul> </li> </ul> <p>Details of each of the adapter actions are presented in a dedicated section:</p> <ul> <li>Pull Details</li> <li>Push Details</li> <li>Remove Details</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Revit%20Adapter%20Details/#flowchart-and-dealing-with-threads","title":"Flowchart and dealing with threads","text":"<p>As already mentioned, the adapter is divided in two sides. On the code level this means the adapter instructions are being processed by two objects:</p> <ul> <li>BHoM side - <code>RevitAdapter</code></li> <li>Revit side - <code>RevitUIAdapter</code></li> </ul> <p>In most cases the above objects exist on two separate threads, one per each side. This means the data needs to be exchanged between the threads, which is done with the use of Sockets and data package dispatchers:</p> <ul> <li>BHoM side - <code>RevitAdapter</code></li> <li>Revit side - <code>RevitListener</code></li> </ul> <p>In general case, the adapter action procedure can be explained as follows: once <code>RevitAdapter</code> receives an adapter instruction, it passes it to <code>RevitListener</code> via Sockets, locks itself to wait, while <code>RevitListener</code> raises an event that triggers CRUD methods in <code>RevitUIAdapter</code>. Then, once CRUD methods return output, it is passed to <code>RevitListener</code>, which sends in back to <code>RevitAdapter</code> - it then unlocks itself and returns the output to the user.</p> <p>In a case when the UI runs on Revit thread, data exchange between the threads is not needed. Instead, an instance of <code>RevitUIAdapter</code> is assigned to <code>RevitAdapter.InternalAdapter</code> static property and CRUD methods get triggered directly based on instructions received by the <code>RevitAdapter</code>.</p> <p>Both scenarios are presented in the flowchart below. Flowchart explaining each of the adapter actions can be found in Pull/Push/Remove detail sections.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Unit%20Conventions/","title":"Unit Conventions","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Revit%20Toolkit/Unit%20Conventions/#unit-conventions","title":"Unit conventions","text":"<p>Revit_Toolkit follows the BHoM unit conventions. All Revit units are being converted to BHoM SI units with <code>BH.Revit.Engine.Core.Convert.FromSI</code> and <code>BH.Revit.Engine.Core.Convert.ToSI</code> methods. Please note that in order to account for the breaking changes in unit handling in Revit API, it is recommended to use the following to work with Revit units in BHoM to avoid applying preprocessor directives:</p> Action Revit 2020 and below Revit 2021 and above Get unit type of parameter Definition <code>BH.Revit.Engine.Core.Query.GetSpecTypeId</code> <code>Autodesk.Revit.DB.Definition.GetSpecTypeId</code> Get display unit type of Parameter <code>BH.Revit.Engine.Core.Query.GetUnitTypeId</code> <code>Autodesk.Revit.DB.Parameter.GetUnitTypeId</code> Get unit type by name <code>BH.Revit.Engine.Core.SpecTypeId</code> <code>Autodesk.Revit.DB.SpecTypeId</code> Get display unit type by name <code>BH.Revit.Engine.Core.UnitTypeId</code> <code>Autodesk.Revit.DB.UnitTypeId</code>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/","title":"BHoM Testing","text":"<p>BHoM allows to create tests of several types. We mainly distinguish between Unit Test/Functional Tests and Data-Driven Tests. This section explains in detail how to write Unit/Functional Tests for BHoM in Visual Studio. For Data-Driven Tests, please refer to their page; among other things, in this page you will also find a section dedicated to their comparison.</p> <p>The main sections of this page are:</p> <ul> <li>Setting up a Toolkit with a Test solution</li> <li>Creating Test projects</li> <li>Writing tests<ul> <li>Differences between Unit, Data-Driven and Functional tests</li> <li>Leveraging NUnit</li> </ul> </li> <li>Running tests</li> <li>Good practices like Test Driven Development (TDD)</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#test-solution-setup","title":"Test Solution setup","text":"<p>BHoM operates a separation between tests and functionality/object models. This is achieved by placing the tests in a different solution from the main repository solution.</p> <p>In this page, we will make an example where we want to create tests for the Robot_Toolkit.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#create-a-new-unit-tests-directory","title":"Create a new <code>unit-tests</code> directory","text":"<p>To add a new test solution, please create a new <code>unit-tests</code> folder in the Toolkit's <code>.ci</code> directory, e.g.:</p> <p></p> <p>If a <code>.ci</code> folder does not exist in your Toolkit yet, create that first.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#create-a-new-test-solution","title":"Create a new test solution","text":"<p>You can create a new Test solution in Visual Studio from the File menu as shown below.</p> <p></p> <p>Search for NUnit in the search bar and select it:</p> <p></p> <p>Make sure that you have \"create new solution\" and \"place solution and project in the same directory\" toggled on. </p> <p>Please name the new test solution with the same name as the main toolkit plus the suffix <code>_Tests</code>. For example, for Robot_Toolkit, the new test solution will be called <code>Robot_Toolkit_Tests</code>. </p> <p></p> <p>This will create a new solution with a dummy NUnit test project in it. For example, if we are setting up the <code>Robot_Toolkit_Tests</code> for the first time, we will end up with this:</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#add-the-existing-toolkit-projects-to-the-test-solution","title":"Add the existing Toolkit projects to the Test solution","text":"<p>In order to reference the main Toolkit projects, you can add \"Existing projects\" to the test solution. This will allow debugging the Toolkit code while running the unit tests. </p> <p>Right-click the solution name in the Solution Explorer and do \"Add existing project\":</p> <p></p> <p>Navigate to the Toolkit's repository and select the Toolkit's oM project, if it exists:</p> <p></p> <p>This will add the Toolkit's oM project to the Test solution.</p> <p>Repeat for all the Toolkit's projects, e.g. the Engine and Adapter ones, if they exist. In the example for the Robot_Toolkit, you will end up with this:</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#add-a-solution-configuration-for-more-efficient-testing","title":"Add a Solution Configuration for more efficient testing","text":"<p>After adding the Toolkit's existing projects to the Test solution, you can add a new \"Test\" Solution Configuration that can be used when running tests.</p> <p>Doing this allows to avoid time-consuming situations, like when you need to close software that locks the centralised assemblies (e.g. Rhino Grasshopper, Excel) whenever you want to compile or run Unit Tests. This is because BHoM relies on post-Build Events to copy assemblies in the <code>ProgramData/BHoM folder</code>, and if a software locks them, the project cannot build successfully. </p> <p>Go in the Configuration Manager as below:</p> <p></p> <p>Then select \"New\":</p> <p></p> <p>And do the following:</p> <p></p> <p>This will create a new Solution Configuration called \"Test\". Make sure it's always selected when running tests from the Test solution:</p> <p></p> <p>In order to get the benefits from this, we will need to edit the Post-build events of every non-test project in the Toolkit (in our example for the Robot_Toolkit, these are only 3: the Robot_oM, the Robot_Engine, and the Robot_Adapter). Let's take the example of Robot_oM. The post-build events can be accessed by right-clicking the project, selecting Properties, then looking for \"Post-build Events\". </p> <p></p> <p>The post build events should look something like this: <pre><code>xcopy \"$(TargetDir)$(TargetFileName)\" \"C:\\ProgramData\\BHoM\\Assemblies\" /Y\n</code></pre></p> <p>This instructs the MSBuild process to copy the compiled assembly to the BHoM central folder, from where they can be loaded by e.g. UIs like Grasshopper. We do not want this copy process to happen when we are only testing via NUnit. Therefore, we can modify the post build event by replacing it with:</p> <pre><code>if not \"$(ConfigurationName)\" == \"Test\" (xcopy \"$(TargetDir)$(TargetFileName)\" \"C:\\ProgramData\\BHoM\\Assemblies\" /Y)\n</code></pre> <p>This means that the post-build event is going to be triggered only when the Solution Configuration is not set to \"Test\". </p> <p>Solution Configuration</p> <p>Make sure that the Solution Configuration is always set to \"Test\" when you are in the Test solution (e.g. <code>GitHub/Robot_Toolkit/.ci/unit-tests/Robot_Toolkit_Tests.sln</code>) and not selected when you are in the normal toolkit solution (e.g. <code>GitHub/Robot_Toolkit/Robot_Toolkit.sln</code>).</p> <p>If you have followed the guide so far, this will work fine.</p> <p>The only thing that this changes is that the DLLs are not copied in the BHoM central location if the \"Test\" configuration is selected: in you are developing some new functionalty and you want the change to appear in e.g. a UI like Grasshopper, you need to make sure to compile the solution with the \"Debug\" configuration!</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#create-a-new-a-test-project","title":"Create a new a test project","text":"<p>At this point, you should have a Test solution <code>.sln</code> file in your Toolkit's <code>.ci</code> folder, e.g. something like <code>GitHub/Robot_Toolkit/.ci/unit-tests/Robot_Toolkit_Tests.sln</code>. You will now want to create a Test project where we can write tests.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#decide-what-the-test-project-should-target","title":"Decide what the Test project should target","text":"<p>In order to create a new test project, you should decide what kind of functionality you will want to test there. Because BHoM functionality only resides in Engine and Adapter projects (not oM projects), we can have one test project corresponding to each Engine/Adapter project.</p> <p>For example, say you want to write tests to verify the functionality that is contained in some Robot_Engine method, for example, <code>Robot.Query.GetStringFromEnum()</code>. Because this method resides in the Robot_Engine, we will need to place it into a Test project that is dedicated to testing Robot_Engine functionality.</p> <p>We can create a new test project for this. Right-click on the Solution in the Solution Explorer and do \"Add\" and then \"New Project\":</p> <p></p> <p>Search for NUnit in the search bar and select it:</p> <p></p> <p>Because this test project will target functionality in the Robot_Engine, let's name it appropriately as <code>Robot_Engine_Tests</code>:</p> <p></p> <p>Click next and accept <code>.NET 6.0</code> as the target framework, then click \"Create\".</p> <p></p> <p>We will end up with this new test project:</p> <p></p> <p>We can also delete the dummy test project at this point. Right-click the Robot_Toolkit_Test project and do \"remove\":</p> <p></p> <p>We end up with this situation:</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#configure-the-default-namespace-for-the-test-project","title":"Configure the default namespace for the test project","text":"<p>We want to set up the default namespace for tests included in this project. To do so, right-click the test project and go in Properties:</p> <p></p> <p>Type \"default namespace\" in the search bar at the top, then replace the text into the text box with an appropriate namespace. The convention is: start with <code>BH.Tests.</code>, then append <code>Engine.</code> or <code>Adapter.</code> depending on what the test project tests will target; then end with the name of the software/toolkit that the project targets, for example <code>Robot</code>. For our example so far, we will have <code>BH.Tests.Engine.Robot</code>.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#adding-references-to-a-test-project","title":"Adding references to a Test Project","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#add-existing-project-references","title":"Add existing project references","text":"<p>Because the test will verify some functionality placed in another project, namely the Robot_Engine, we need to add a reference to it. Right-click the project's dependencies and do \"add project reference\":</p> <p></p> <p>Then add the target project and any upstream dependency to the target project. For example, if adding an Engine project, make sure you add also the related oM project; if adding an Adapter project, add both the related Engine and oM projects.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#add-other-bhom-assemblies-dependencies","title":"Add other BHoM assemblies dependencies","text":"<p>Most likely you will need to reference also other assemblies in order to write unit tests. Again, right-click the project's dependencies and do \"add project reference\", then click on \"Browse\" and \"Browse\" again:</p> <p></p> <p>This will open a popup. Navigate to the central BHoM installation folder, typically <code>C:\\ProgramData\\BHoM\\Assemblies</code>. Add any assembly that you may need. These will appear under the \"Assemblies\" section of the project's Dependencies. </p> <p>Typically, a structural engineering Toolkit will need the following assembly references, although they will vary case by case:</p> <p></p> <p>Once you have added the assemblies, please select all of them as in the image above (click on the top one, then shift+click the bottom one) and then right click on one of them. Select \"Properties\" and under \"Copy Local\" make sure that \"True\" or \"Yes\" is selected:</p> <p></p> <p>This is required to make sure that NUnit can correctly grab the assemblies.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#adding-extra-nuget-packages","title":"Adding extra NuGet packages","text":"<p>We can leverage some other NuGet packages to make tests simpler and nicer. </p> <p>If you want your Unit test to be automatically invocable by CI/CD mechanisms, you should check with the DevOps lead if the NuGet packages you want to use are already supported or can be added to the CI/CD pipeline. The following packages are already supported.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#add-fluentassertions","title":"Add FluentAssertions","text":"<p>We use the FluentAssertions NuGet package for easier testing and logging. Please add it by right-clicking the Project's Packages and do \"Manage NuGet packages\":</p> <p></p> <p>Click \"Browse\", then type \"FluentAssertions\" in the search bar. Select the first result and then click \"Install\":</p> <p></p> <p>We will provide some examples on how to use this library below. Please refer to the FluentAssertions documentation to see all the nice and powerful features of this library.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#writing-tests","title":"Writing tests","text":"<p>Let's image we want to write some test functionality for the Robot Query method called <code>Robot.Query.GetStringFromEnum()</code>. Because this method resides in the Robot_Engine, we will need to place it into the <code>Robot_Engine_Tests</code> project (created as explained above).</p> <p>Because the method we want to test is a Query method, let's create a folder called <code>Query</code>:</p> <p></p> <p>Right-click the newly created Query folder and do Add new Item:</p> <p></p> <p>Let's call the new item as the method we want to test, e.g. <code>GetStringFromEnum</code>:</p> <p></p> <p>Let's edit the content of the generated file, so it looks like the following.</p> <pre><code>using NUnit;\nusing NUnit.Framework;\nusing FluentAssertions;\n\nnamespace BH.Tests.Engine.Robot.Query\n{\n    public class GetStringFromEnumTests\n    {\n        [Test]\n        public void GetStringFromEnum()\n        {\n\n        }\n    }\n}\n</code></pre> <p>In particular, note that: - we added a <code>using NUnit;</code>, <code>using NUnit.Framework;</code> and <code>using FluentAssertions;</code> at the top; - we edited the name of the class appending <code>Tests</code> - We added an empty test method called as the Engine method we want to verify (<code>GetStringFromEnum</code>). The test method is decorated with the <code>[Test]</code> attribute.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#test-sections-arrange-act-assert","title":"Test sections: Arrange, Act, Assert","text":"<p>Every good test should be composed by these 3 clearly identifiable main sections (please refer to Microsoft's Unit testing best practices for more info and examples):</p> <ul> <li>Arrange: any statement that defines the inputs and configurations required to do the verification;</li> <li>Act: execute the functionality that we want to verify, given the Arrange setup;</li> <li>Assert: statements that make sure that the result of the Act is as it should be.</li> </ul> <p>The test structure should always be clear and follow this structure. Each test should only verify a specific functionality. You can have multiple assertion statements if they all concur to test the same functionality, but it can be a red flag if you have more than two or three: it often means that you should split (or parameterise) the test.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#your-first-test-a-simplistic-example","title":"Your first test: a simplistic example","text":"<p>Following the example so far, we could write this code for the <code>GetStringFromEnum()</code> test method:</p> <pre><code>[Test]\n[Description(\"Verify that the GetStringFromEnum() method returns the correct string for a specific DesignCode_Steel enum value.\")]\npublic void GetStringFromEnum()\n{\n    // Arrange\n    // Set up any input or configuration for this test method.\n    var input = oM.Adapters.Robot.DesignCode_Steel.BS5950;\n\n    // Act\n    // Call the target method that we want to verify with the given input.\n    var result = BH.Engine.Adapters.Robot.Query.GetStringFromEnum(input);\n\n    // Assert\n    // Make sure that the result of the Act is how it should be.\n    result.Should().Be(\"BS5950\");\n}\n</code></pre> <p>Note that we use FluentAssertions' <code>Should().Be()</code> method to verify that the value of the result is equal to the string <code>BS5950</code>, as it is supposed to be when calling the <code>GetStringFromEnum</code> engine method with the input <code>DesignCode_Steel.BS5950</code>.</p> <p>Also note that a good practice is to add a test <code>[Description]</code> too! This is very helpful in case the test fails, so you get an explanation of what kind of functionality verification failed and what how it was supposed to work.</p> <p>Why this is a bad example of unit test</p> <p>This example is simplistic and shown for illustrative purposes. It's not a good unit test for several reasons:</p> <ul> <li>we are not testing every possible combination of inputs to the <code>GetStringFromEnum()</code> engine method and related outputs. </li> <li>it hard-codes the value <code>BS5950</code>. We took that value by copying it from the body of the <code>GetStringFromEnum()</code> method and putting it in the Assert statement. This effectively duplicates that value in two places. If the string in the engine method was modified, you would need to modify the test method too. You should avoid this kind of situation and limit yourself to verifying things variables defined as part of the \"Arrange\" step. If you need to verify multiple output value possibilities, you should be using a Data-Driven approach.</li> </ul> <p>See below for better examples of unit tests.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#better-examples-of-tests","title":"Better examples of tests","text":"<p>To illustrate good unit tests, let's look at another repository, the Base BHoM_Engine. Let's look at the test in the <code>IsNumericIntegralTypeTests</code> class, which looks like this (edited and with additional comments for illustrative purposes):</p> <pre><code>namespace BH.Tests.Engine.Base.Query\n{\n    public class IsNumericIntegralTypeTests\n    {\n        [Test]\n        public void AreEnumsIntegral()\n        {\n            // Arrange. Set up the test data\n            var input = typeof(DOFType);\n\n            // Act. Invoke the target engine method.\n            var result = BH.Engine.Base.Query.IsNumericIntegralType(input);\n\n            // Assert. Verify that the output of the Act is how it should be.\n            // If it fails the message in the string will be returned.\n            result.ShouldBe(true, \"By default, IsNumericIntegralType() considers enums as a numeric integral type.\");\n        }\n\n        [Test]\n        public void AreIntsIntegral()\n        {\n            // Arrange. Set up the test data\n            var input = 10.GetType();\n\n            // Act. Invoke the target engine method.\n            var result = BH.Engine.Base.Query.IsNumericIntegralType(input);\n\n            // Assert. Verify that the output of the Act is how it should be.\n            // If it fails the message in the string will be returned.\n            result.ShouldBe(true, \"Integers should be recongnised as Numeric integral types.\");\n        }\n    }\n}\n</code></pre> <p>As you can see, this class contains 2 tests: <code>AreEnumsIntegral()</code> and <code>AreIntsIntegral()</code>. A single test class should test the same \"topic\", in this case the <code>BH.Engine.Base.Query.IsNumericIntegralType()</code> method, but it can (and should) do so with as many tests as needed. The first test checks that C# Enums are recognised as integers by the method <code>IsNumericIntegralType</code> (they should be). The second test checks that the same method also recognises C# Integers are recognised as integers.  </p> <p>Why are these tests better examples of good unit tests than the one in the previous section?</p> <ul> <li>Test should be \"atomical\" like this, because if something goes wrong, there is going to be a specific test telling you what did go wrong.</li> <li>The possible outcomes are limited to True/False; it can be acceptable to \"hard-code\" True/False in the unit test itself. Writing <code>result.ShouldBe(true)</code> makes sense, as opposed to <code>result.ShouldBe(someVerySpecificString)</code> or <code>result.ShouldBe(someHugeDataset)</code>.</li> </ul> <p>A good idea would be to add a test that verifies that a non-integral numerical value is recognised as not an integer, for example a <code>double</code> like <code>0.15</code>. Another test could be verifying that a non-numerical type is also recognised as not an integer, for example a <code>string</code>.  </p> <p>If the possible outcomes of the output data were not limited to True/False, the target method would have been better suited to be verified with a Data-driven test. However, in certain situations, like when doing Test Driven Development, it can be acceptable to write tests that verify complex output data, although it's likely that a full test coverage will only be reached with Data-driven tests.</p> <p>For more examples of good tests, keep reading.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#unit-tests-vs-data-driven-vs-functional-tests","title":"Unit tests VS Data-Driven VS Functional tests","text":"<p>Unit tests verify that a particular piece of code, generally a function, works as expected. The perspective of a unit test is often that of the developer who authored the target function and that wants to make sure it works properly. The power of unit tests comes by creating many of them that verify the smallest possible functionality with many different input combinations. You should always strive to write small, simple unit tests. Please refer to Microsoft's Unit testing best practices for more information and examples.</p> <p>In some cases, as mentioned in the section above, the verification in a unit test may need to target a complex set of data. For example, you may want to test your method against a \"realistic\" set of object, for example, many different input objects that cannot be generated easily from the code itself, but that can be easily generated in e.g. Grasshopper. In these cases, you should rely on Data-driven testing. Data-driven testing provides for more robustness against changes, because it verifies that the target function always performs in the same way. If the test function needs to change, you will have to re-write also the expected output, and this procedure increases robustness.  However, in certain situations, like when doing Test Driven Development (TDD), it can be acceptable and even extremely helpful to write tests that verify against complex data. For example, Functional tests may well rely on complex set of data, and it's common to write them when doing TDD. In this scenario, it's still likely that a full test coverage will only be obtainable by also doing some Data-driven testing.</p> <p>Test that verify larger functionality are also possible, in which case we talk about Functional tests. Functional test often take the perspective of a user using a piece of software that does many things in the background, like Pushing or Pulling objects via a BHoM_Adapter (in the next section you can an example of this). Functional tests can be slow to execute and, when they fail, they do not always give good understanding of the possible causes for the failure, because they encompass many things. However, Functional tests can be very helpful to verify that large, complex pieces of functionality work as expected under precise conditions. They are also amazingly helpful when developing new pieces of functionality using the TDD approach. </p> <p>In many cases, the best practice is to have a good balance of Unit, Functional and Data-driven tests. This comes with experience, just start with something and you'll get there!</p> <p>unit test as an umbrella term</p> <p>Sometimes, people use the term \"unit tests\" as an umbrella term for all kinds of tests.  This is incorrect, as the only really generic umbrella term should be \"test\". However, it's a common misconception that it's often done in development. In BHoM we mistakenly perpetrate it in a couple of places:</p> <ul> <li>in the setup of the Test Solution parent folder (the <code>.ci/unit-tests</code> folder; we should have <code>.ci/tests</code>)</li> <li>in the name of the Data-Driven test component (which is called \"unit test\", but could be called \"data driven test\"). BHoM's data-driven tests are simply a type of unit test (equality assertion on the stored output data of a single method).</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#a-functional-test-example","title":"A Functional test example","text":"<p>Examples of Functional tests can be seen in the <code>Robot_Adapter_Tests</code> project. Adapter Test projects will likely contain lots of functional tests, as we care about testing complex behaviours like Push and Pull. </p> <p>For example, see below the test <code>PushBarsWithTagTwice()</code> (this is slightly edited and with additional comments for illustration purposes). We test the behaviour of the Push and Pull functionality, which in the backend is composed by a very large set of function calls. The test a first set of 3 bars, then a second set of 3 bars, and all bars are pushed with the same Tag; then it verifies that the second set of bars has overridden the first set.</p> <pre><code>[Test]\n[Description(\"Tests that pushing a new set of Bars with the same push tag correctly replaces previous pushed bars and nodes with the same tag.\")]\npublic void PushBarsWithTagTwice()\n{\n    // Arrange. Create two sets of 3 bars.\n    int count = 3;\n    List&lt;Bar&gt; bars1 = new List&lt;Bar&gt;();\n    List&lt;Bar&gt; bars2 = new List&lt;Bar&gt;();\n    for (int i = 0; i &lt; count; i++)\n    {\n        bars1.Add(Engine.Base.Create.RandomObject(typeof(Bar), i) as Bar);\n    }\n\n    for (int i = 0; i &lt; count; i++)\n    {\n        bars2.Add(Engine.Base.Create.RandomObject(typeof(Bar), i + count) as Bar);\n    }\n\n    // Act. Push both the sets of bars. Note that the second set of bars is pushed with the same tag as the first set of bars.\n    m_Adapter.Push(bars1, \"TestTag\");\n    m_Adapter.Push(bars2, \"TestTag\");\n\n    // Act. Pull the bars and the nodes.\n    List&lt;Bar&gt; pulledBars = m_Adapter.Pull(new FilterRequest { Type = typeof(Bar) }).Cast&lt;Bar&gt;().ToList();\n    List&lt;Node&gt; pulledNodes = m_Adapter.Pull(new FilterRequest { Type = typeof(Node) }).Cast&lt;Node&gt;().ToList();\n\n    // Assert. Verify that the count of the pulled bars is only 3, meaning that the second set of bars has overridden the first set of bars.\n    pulledBars.Count.ShouldBe(bars.Count, \"Bars storing the tag has not been correctly replaced.\");\n\n    // Assert. Verify that the count of the pulled nodes is only 6, meaning that the second set of bars has overridden the first set of bars.\n    pulledNodes.Count.ShouldBe(bars.Count * 2, \"Node storing the tag has not been correctly replaced.\");\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#leveraging-the-nunit-test-framework-setup-and-teardown","title":"Leveraging the NUnit test framework: setup and teardown","text":"<p>When writing unit tests, you should leverage the NUnit test framework and other libraries in order to write clear, simple and understandable tests.</p> <p>You may want to define NUnit \"startup\" methods like <code>[OneTimeSetup]</code> or <code>[Setup]</code> in order to execute some functionality when a test starts, for example starting up an adapter connection to a software. Similarly, you can define \"teardown\" methods to define some functionality that must be executed when a test finishes, for example closing some adapter connection. </p> <p>Please refer to the NUnit guide to learn how to define startup and teardown methods.</p> <p>For example, we defined such methods for the Robot_Adapter_Tests test project. Let's look at the OneTimeSetup done in Robot_Adapter_Tests:</p> <p><pre><code>namespace BH.Tests.Adapter.Robot\n{\n    public class PushTests\n    {\n        RobotAdapter m_Adapter;\n\n        [OneTimeSetUp]\n        public void OntimeSetup()\n        {\n            m_Adapter = new RobotAdapter(\"\", null, true);\n            //... more code ...\n        }\n\n        //... more code ...\n    }\n}\n</code></pre> Here, we use the OneTimeSetup method to define a behaviour that should be executed only once before the tests contained in the class <code>PushTests</code> are run. This behaviour is the initialization of the RobotAdapter, which is stored in a variable in the class. All tests are going to reuse the same RobotAdapter instance, avoiding things like having to re-start Robot for each and every test, which would be time-consuming.</p> <p>Check the Robot_Adapter_Tests test project for more examples of Setup and Teardown methods, and refer to the NUnit guide for more examples and info.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#running-tests","title":"Running tests","text":"<p>All tests existing in a Test solution can be found in the Test Explorer. If you can't find the Test Explorer, use the search bar at the top and type \"Test Explorer\":</p> <p></p> <p>You can run a single test by right-clicking the test and selecting Run or Debug. If you choose \"debug\", you will be able to hit break points placed anywhere in the code.</p> <p>By running tests often, you will be able to quickly develop new functionality while making sure you are not breaking any existing functionality.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/#test-driven-development-tdd","title":"Test Driven Development (TDD)","text":"<p>A good practice is Test Driven Development (TDD), which consists in writing tests first, and implement the functionality in the \"Act\" step later. You can create a stub of the implementation that does nothing, write the tests that should verify that it works fine, and then develop the functionality by adding code to the body of the stub. In other words:</p> <ol> <li>Write one or, better, many tests that verify a piece of functionality. They should have Arrange, Act and Assert phases. </li> <li> <p>In the \"Act\" phase, just write a function call to the new function you want to define. Get inspired by the Arrange step to define the signature of the function call. Don't be bothered by the compiler complaining that the function doesn't exist!</p> <p><pre><code>[Test]\npublic void ()\n{\n    // Arrange\n    var input = someData; // data that I know I will want to use.\n\n    // Act\n    // DoSomething() does't exist yet!\n    var output = BH.Engine.Something.Compute.DoSomething(input); \n\n    // Assert\n    output.Should().Be(expectedValue);\n}\n</code></pre> 2. Write a stub for the target function: <pre><code>public partial class Compute\n{\n    public static object DoSomething(object input)\n    {\n        // You will implement this later. Don't do anything.\n        return null;\n    }\n}\n</code></pre></p> </li> <li> <p>Run the tests. Make sure they all fail! Add as many tests you can think of: they should describe well the functionality you want to develop.</p> </li> <li>Write the target function until all the tests pass!</li> </ol> <p>Doing this allows focusing on the \"what\" first, and the \"how\" later. It helps to focus on the requirements and the target result that you want to achieve with the new function. In many cases, the implementation will then almost \"write itself\", and you will also end up with a nice collection of unit tests that can be re-run later to verify that everything keeps working (regression testing).</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/Data-Driven-Tests/","title":"Data driven tests","text":"<p>BHoM has several ways to cover developed functionality with Tests. An automated strategy for covering possible regression (i.e. loss of functionality erroneously introduced by code changes) can be done with \"Data driven tests\".</p> <p>Data driven tests are simply a way to take a \"snapshot\" of the input and output of a specific method. The input and output are stored in a dataset, together with the name of the method used to produce the output from the input. This data can be then used to automatically trigger the method at a later time, or periodically, to check that the method has not been broken e.g. with side-effects of other code changes elsewhere.</p> <p>To record the test data, you simply need to run a target Engine method with some specific input data. The input data and the ouput of the method, together with the method name, will be recorded. When the data-driven test will be run, it will simply call again the method in question with the stored input data, and compare it with the output data. This way, it is possible to check that Engine methods keep behaving reliably.</p> <p>This kind of \"Data-driven Unit test\" can be run automatically via CI/CD for an automated checking of the functionality.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/Data-Driven-Tests/#storing-test-data-for-engine-methods","title":"Storing test data for Engine Methods","text":"<p>To store data for tests, you can use the Test_Toolkit and the <code>Unit Test</code> component.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Testing/Data-Driven-Tests/#procedure","title":"Procedure","text":"<ol> <li>Compile the Test_Toolkit - it contains some useful methods that are not shipped in the BHoM installer.</li> <li>Drop a <code>Unit Test</code> component in a script.</li> <li>Right click the component. Use the search field to find and select method you want to store test data for. Once done, the component Unit test will transform into a <code>UT:MethodName</code> component.    For example, if you want to test the method called <code>BaseTypes()</code>, type and select its name. The component will transform into a <code>UT:BaseType</code> component. See screenshot below.    This component will have as many input as the selected method. What it will do is simply run the selected method with any provided input data.</li> <li>Produce some input test data for the method. This data is simply some objects that the method can take as an input. Don't just do random objects: think about what kind of test data an user may want to input to the test, and about particular \"edge\" situations you want to make sure that work. The input data should cover as many input combinations and \"particular inputs\" as it makes sense to, in order to have good test coverage.</li> <li>Connect the test data to the <code>Unit Test</code> component. The component will execute the target method with the provided data, and it will return one or more Unit Test objects, which contain the input and outputs related to the method execution.</li> <li>At this point, we will want to store the  Unit Test objects as a json somewhere where the automation can find them, so future testing can be done automatically. Our place of choice is the <code>.ci</code> folder of the repository where the method being tested can be found.    In order to do this easily and reliably, you can use the Test_Toolkit's <code>StoreUnitTests</code> function. Please refer to the screenshot below.    The <code>StoreUnitTests</code> function will save the test data in the <code>.ci</code> folder of the repository. </li> </ol> <ol> <li>Make sure to commit and push the data in your PR.</li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/","title":"What is BHoM versioning?","text":"<p>BHoM versioning provides a system to correctly load a method or component stored in a script that has had its code changed.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/#why-is-versioning-needed","title":"Why is Versioning needed?","text":"<p>When you save a script that contains BHoM stuff, all of the BHoM components save information about themselves so they can initialise properly when the script is re-opened. This information is about things like the component/method name, its inputs and outputs types and names; the information is simply stored in a text (Json serialised).</p> <p>If someone changes a BHoM method or object that was stored in a script, upon reopening of the script it will be impossible to reload that same method or object: the method initialisation will fail and the old component in the script will throw a warning or error, unable to work. </p> <p>Versioning fixes this by updating the old json text before using it to find the method. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/#what-does-bhom-versioning-support","title":"What does BHoM versioning support?","text":"<p>BHoM versioning supports the following changes:</p> <ul> <li> <p>Changes to methods (e.g. saved in a script): </p> <ul> <li>changes in the method name</li> <li>changes in their input/outputs names and types.</li> </ul> </li> <li> <p>Changes to Namespaces:</p> <ul> <li>renaming namespaces</li> <li>general modification to namespaces </li> </ul> </li> <li> <p>Changes to classes (object types): </p> <ul> <li>changes in class properties</li> <li>changes in their name</li> <li>complex structural changes</li> </ul> </li> <li> <p>Changes to Datasets:</p> <ul> <li>renaming or moving of location</li> <li>deletion </li> </ul> </li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/#ok-tell-me-how-to-do-versioning-for-my-changes","title":"Ok, tell me how to do versioning for my changes! \ud83d\ude80","text":"<p>To implement versioning when you do your changes, see Versioning guide.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/","title":"2022 Q1   Reflection oM Engine migration to Base oM Engine","text":"<p>Following the discussion in this issue and associated discussions in this issue and this issue, the Reflection oM was removed from BHoM, and significant changes made to the location of methods between Reflection_Engine and BHoM_Engine DLLs.</p> <p>Reflection_oM has been removed entirely, while Reflection_Engine has been modified. Moving forward, Reflection_Engine will house methods which allow the code base to ask questions about itself, following the traditional route of Reflection in programming, so the engine will continue to exist, but core methods that are more commonly used for general operation of the eco-system have been migrated to the Base_Engine.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#pull-requests","title":"Pull Requests","text":"<p>To jump straight into the code changes, see these PRs:</p> <ul> <li>BHoM: Reflection_oM: Migrate objects to Base_oM - Removing Reflection_oM</li> <li>BHoM_Engine: Align to changes in oM - moving Reflection_oM objects to Base_oM -&gt; updating usings and codings to the new object locations</li> </ul> <p>Further changes were made to all repositories within the installer. A full list is available in the following files. These links will take you to the commit states at the time this work was done, and will highlight which repositories received the updates at the time. All repositories received the updates described in this article to ensure they could compile against the base changes, with no other changes provided during this work.</p> <ul> <li>Dependencies</li> <li>Includes</li> <li>User Interfaces</li> <li>Alpha Includes</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#reflection_om-attributes","title":"Reflection_oM -&gt; Attributes","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhomreflectionattributes-bhombaseattributes","title":"<code>BH.oM.Reflection.Attributes</code> -&gt; <code>BH.oM.Base.Attributes</code>","text":"<p>The biggest impact to repositories was via the migration of all Reflection_oM objects to the BHoM project, falling under the <code>Base</code> namespace. This included <code>Attributes</code>, <code>Debugging</code>, and the interfaces for <code>MultiOutput</code> objects.</p> <p>The <code>Attributes</code> are a key part of BHoM documentation, providing <code>Input</code>, <code>Output</code>, and <code>MultiOutput</code> documentation attributes, as well as versioning attributes such as <code>ToBeRemoved</code> and <code>PreviousVersion</code>.</p> <p>Prior to this work, they were housed under the namespace <code>BH.oM.Reflection.Attributes</code>, but this has now become <code>BH.oM.Base.Attributes</code> following the migration. Updating your <code>using</code> statements and referencing <code>BHoM.dll</code> rather than <code>Reflection_oM.dll</code> should be sufficient to resolve compilation issues here.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#reflection_om-debugging","title":"Reflection_oM -&gt; Debugging","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhomreflectiondebugging-bhombasedebugging","title":"<code>BH.oM.Reflection.Debugging</code> -&gt; <code>BH.oM.Base.Debugging</code>","text":"<p>For anyone needing to use the <code>Debugging</code> objects of BHoM (such as <code>Event</code>), these are now housed in the <code>BH.oM.Base.Debugging</code> namespace. Existing uses of this should be sufficient to rename the <code>using</code> statement and ensure a reference to <code>BHoM.dll</code> rather than <code>Reflection_oM.dll</code>.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#reflection_om-output","title":"Reflection_oM -&gt; Output","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhomreflection-bhombase-bhomreflectionoutputt-bhombaseoutputt","title":"<code>BH.oM.Reflection</code> -&gt; <code>BH.oM.Base</code> (<code>BH.oM.Reflection.Output&lt;T&gt;</code> -&gt; <code>BH.oM.Base.Output&lt;T&gt;</code>)","text":"<p>The <code>Output&lt;T&gt;</code> objects were housed in the top level of the Reflection_oM in the namespace <code>BH.oM.Reflection</code>. These have been moved to the top level of the BHoM in the namespace <code>BH.oM.Base</code>.</p> <p>Anyone using <code>Output&lt;T, Tn&gt;</code> objects should find it sufficient to replace <code>using BH.oM.Reflection;</code> with <code>using BH.oM.Base;</code> and ensuring a reference to <code>BHoM.dll</code> rather than <code>Reflection_oM.dll</code> going forward.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#reflection_engine-loadingreflecting-assemblies","title":"Reflection_Engine -&gt; Loading/Reflecting Assemblies","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhenginereflection-bhenginebase","title":"<code>BH.Engine.Reflection</code> -&gt; <code>BH.Engine.Base</code>","text":"<p>These methods were primarily used by UIs to load DLLs appropriately into their platforms. These have moved to the Base Engine, in the <code>BHoM_Engine.dll</code> reference. Adding a reference to <code>BHoM_Engine.dll</code> and updating using statements and method calls should be sufficient.</p> <p>The use of the name <code>Reflect</code> has been removed from the Base Engine to avoid confusion with the ongoing use of Reflection_Engine, and has become <code>Extract</code>. See this file for more information.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#reflection_engine-errorwarningnote-recording","title":"Reflection_Engine -&gt; Error/Warning/Note recording","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhenginereflection-bhenginebase_1","title":"<code>BH.Engine.Reflection</code> -&gt; <code>BH.Engine.Base</code>","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhenginereflectioncomputerecorderror-bhenginebasecomputerecorderror","title":"<code>BH.Engine.Reflection.Compute.RecordError()</code> -&gt; <code>BH.Engine.Base.Compute.RecordError()</code>","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhenginereflectioncomputerecordwarning-bhenginebasecomputerecordwarning","title":"<code>BH.Engine.Reflection.Compute.RecordWarning()</code> -&gt; <code>BH.Engine.Base.Compute.RecordWarning()</code>","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#bhenginereflectioncomputerecordnote-bhenginebasecomputerecordnote","title":"<code>BH.Engine.Reflection.Compute.RecordNote()</code> -&gt; <code>BH.Engine.Base.Compute.RecordNote()</code>","text":"<p>Another big change with the migration is the housing of methods related to the logging system within BHoM. These have been updated as above, with the same functionality as before. If your code was using the logging system, updating <code>Reflection</code> to <code>Base</code> and ensuring a reference to <code>BHoM_Engine.dll</code> should be sufficient.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/2022-Q1---Reflection-oM-Engine-migration-to-Base-oM-Engine/#questionsissues","title":"Questions/Issues","text":"<p>If you encounter any problems following this migration, please reach out with discussion or issues as appropriate \ud83d\ude04 </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Backwards-compatibility/","title":"Backwards compatibility","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Backwards-compatibility/#backwards-compatibility","title":"Backwards compatibility","text":"<p>The two major subjects for backwards compatibility concerns methods/components and the objects/data itself.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Backwards-compatibility/#methodscomponents","title":"Methods/Components","text":"<p>Only time these should have to break is when a parameter has been updated. This will in the long run be covered by the <code>Version_Engine</code>. See object name or namespace changed.</p> <p>For all other cases the developer is responsible for ensuring that they never update public methods in a manner that can cause a script to break. Updates to methods will lead to scripts breaking if the interface of the method has been updated, which will be the case if at least one of the following is true:</p> <ol> <li>Method name is changed</li> <li>Method is moved to a different class</li> <li>Method namespace is changed</li> <li>Return type is changed</li> <li>Input parameters are changed, in type, number or order</li> </ol> <p>If none of the above holds true for the change being made, i.e. the change only concerns the body of the method, the change is free to do without any additional concern about versioning. (Obviously any fundamental change to the behavior of the method needs normal due care and documentation.)</p> <p>If any of the above holds true the following process should be applied:</p> <ol> <li> <p>Implement the new method without removing the old.</p> </li> <li> <p>Put a Deprecated tag on the old method you want to update. In the tag link over to the new method.</p> </li> <li> <p>The method with the <code>Deprecated</code> tag can be removed when at least 2 minor releases have passed. (For example a method deprecated in version 2.2 should not be removed before version 2.4 at the earliest.)</p> </li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Backwards-compatibility/#object-models-and-serialised-data","title":"Object models and serialised data","text":"<p>If an object schema is updated it will potentially lead to breaking previously serialized data and for some cases methods. </p> <p>If the deserialisation from BSON or JSON fails, the <code>Serialiser_Engine</code> will fall back to deserialise any failing object to a <code>CustomObject</code>, containing all the data as keys in the CustomData.</p> <p>To ensure that any old data is deserialised correctly to the updated object schema, methods in the <code>Versioning_Engine</code> will need to be implemented. Depending on the change made, different action needs to be taken as outlined below.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Backwards-compatibility/#object-name-or-namespace-changed","title":"Object name or namespace changed","text":"<p>When a change has been made to the object name or namespace, a renaming method needs to be implemented in the <code>Version_Engine</code>, taking the previous full name as a string, including namespace (for example BH.oM.Structure.Element.Bar) and returning the new name as a string.</p> <p>This will also be important when deserialising any method using the updated object as return type or input parameter.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Backwards-compatibility/#object-definition-changed","title":"Object definition changed","text":"<p>When the definition of an object has been changed, which could be:</p> <ul> <li>Adding a property</li> <li>Removing a property</li> <li>Change name or type of a property</li> </ul> <p>the object will be deserialised to a <code>CustomObject</code>, as outline above.</p> <p>To ensure that the object is being correctly deserialised covering the change being made, a convert method between versions needs to be implemented in the  <code>Version_Engine</code>, taking the <code>CustomObject</code> as an argument and returning a new <code>CustomObject</code> with properties updated to match the new object schema. The <code>Versioning_Engine</code> will then attempt to deserialize the updated schema to the correct object.</p> <p>The method implemented should just cover update from one version to the next (for example 2.3 -&gt; 2.4). This will make it possible to chain the updates when an object has gone through several changes over multiple versions.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Change-to-a-property-name/","title":"Change to a property name.","text":"<ol> <li>In the Audience Profile Parameters object I want to change the property <code>NumRows</code> to <code>Rows</code>.</li> <li> <p>Before any changes to the code I create the JSON string: </p> <p></p> </li> <li> <p>And save a Grasshopper file with a panel containing that string.</p> <p></p> </li> <li> <p>I make the property name change in the code:</p> <p></p> </li> <li> <p>Create the Versioning_XX.json:</p> <p></p> </li> <li> <p>Add it to the project.</p> </li> <li>Rebuild the Audience_oM and Engine.</li> <li>Rebuild the latest Versioning_Toolkit.</li> <li>Open Grasshopper and the test file.</li> <li> <p>Place the <code>ToNewVersion</code> component and pass in the JSON string of the old object.</p> <p></p> </li> <li> <p>Check the change has occurred as expected by inspecting the output string from <code>ToNewVersion</code>.</p> <p></p> </li> <li> <p>If that did not work then see below.</p> </li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/","title":"Creating your own versioning","text":"<p>The BHoM eco-system provides the Versioning_Toolkit to handle upgrading and versioning of any object, method, or dataset within the BHoM organisation/framework.</p> <p>If you have built toolkits on top of the BHoM, then you may want to have your own versioning occur on your own objects, without revealing their existence to the open-source community (though of course, we actively encourage sharing knowledge back to the community!). To this end, we have revamped the Versioning Toolkit in the 7.2 milestone to accommodate you building your own Versioning Toolkit without needing to copy what BHoM is doing to get our upgrades.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#bhom-versioning","title":"BHoM Versioning","text":"<p>When we version a milestone in BHoM, we produce an <code>Upgrader</code>, which is usually called <code>BHoMUpgraderXY</code> where <code>XY</code> refers to the development major (X)/minor (Y) milestone numbers. For example, <code>BHoMUpgrader63</code> refers to the 6.3 upgrader and upgrades objects/methods made prior to the 6.3 milestone to the 6.3 standard. This upgrader is an <code>exe</code> file which allows <code>Versioning_Engine</code> to pipe items to it for upgrade.</p> <p>In addition to the <code>exe</code> file, we also produce the upgrader as a <code>DLL</code> file, allowing other upgraders to reference is - this means when someone adds versioning to BHoM via the converter in a given upgrader, your versioning toolkit can benefit from it as well.</p> <p>Similarly, the <code>PostBuild</code> project which scrapes versioning data (<code>PreviousVersion</code> attributes, etc.) from compiled code is now placed within <code>$(ProgramData)\\BHoM\\Developer\\Versioning</code> when Versioning Toolkit is built - allowing other developers to utilise the <code>PostBuild.exe</code> from a central location rather than needing to update any relative path references, which is beneficial to the rest of this tutorial guide.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#technical-elements","title":"Technical elements","text":"<p>When building your versioning, you will be inheriting from the <code>Converter</code> class provided by BHoM's Versioning_Toolkit and overwriting the Upgrader <code>exe</code> file with your own. By inheriting from the BHoM <code>Converter</code>, you will obtain any upgrades contained in that <code>Converter</code> for BHoM related objects, and by using the same <code>PostBuild.exe</code> builder, providing you're building on top of the BHoM framework, you will scrape all <code>PreviousVersion</code> attributes (and other relevant attributes) from all compiled DLLs, which will include BHoM DLLs and your own - thus any versioning provided by the BHoM community will be scraped and picked up by your versioning when using this methodology. Then by overwriting the Upgrader <code>exe</code> deployed by the BHoM will allow it to be called by the Versioning_Engine when upgrading elements, allowing versioning to occur for the objects/methods/datasets within both BHoM and your own DLLs.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#setting-up-your-versioning-toolkit","title":"Setting up your versioning toolkit","text":"<p>You can start by having a solution in the same way as any other BHoM Toolkit. The differences will come in the projects the solution contains. Instead of <code>_oM</code>, <code>_Engine</code>, and <code>_Adapter</code> projects, a versioning solution will contain <code>BHoMUpgraderXY</code> projects, where <code>XY</code> refers to the milestone you want to handle upgrades for.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#adding-a-project","title":"Adding a project","text":"<p>Add a console application project targeting .NetFramework4.7.2. Ensure the project name is <code>BHoMUpgraderXY</code> where <code>XY</code> is the milestone - <code>70</code> for the 7.0 milestone, <code>73</code> for the 7.3 milestone, etc.</p> <p>Set up the namespace to be <code>BH.Upgrader.vXY</code> where <code>XY</code> is the milestone your project targets as above.</p> <p>Set up the output folder for all configurations to be <code>Build\\</code>.</p> <p>Set up the post build events to be one of the following:</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#adding-a-live-versioning-project","title":"Adding a live versioning project","text":"<p>If you're adding a versioning project for the current milestone being developed (and thus want fresh versioning changes to be captured each time you build the toolkit), use this post build:</p> <pre><code>xcopy /Y /I /E \"$(TargetDir)*.dll\" $(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\nxcopy /Y /I /E \"$(TargetDir)BHoMUpgraderXY.exe\" $(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\ncall \"$(ProgramData)\\BHoM\\Developer\\Versioning\\PostBuild.exe\" ..\\..\\..\\ \"$(ProgramData)\\BHoM\\Upgrades\"\n</code></pre> <p>Where <code>XY</code> refers to the project milestone.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#adding-a-fixed-versioning-project","title":"Adding a fixed versioning project","text":"<p>If you're adding a versioning project for a previous milestone, and want the versioning to be fixed and not scrape information every time you build the toolkit, use this post build:</p> <pre><code>xcopy /Y /I /E \"$(TargetDir)*.dll\" $(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\nxcopy /Y /I /E \"$(TargetDir)BHoMUpgraderXY.exe\" $(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\nxcopy /Y /I /E \"$(TargetDir)Upgrades.json\" $(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\n</code></pre> <p>Where again <code>XY</code> refers to the project milestone.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#json-upgrades","title":"JSON Upgrades","text":"<p>This file should be fixed after a milestone is completed, so if you're adding a project for a past milestone, simply add your versioning to the existing BHoM JSON Upgrades file for that milestone and add it to your project.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#adding-references","title":"Adding references","text":"<p>Add references to <code>$(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\\BHoMUpgrader.dll</code> and <code>$(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY\\BHoMUpgraderXY.dll</code> - where <code>XY</code> refers to the milestone your project targets. Ensure you add the DLLs that correspond to the same versioning version that your project targets.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#adding-the-converter","title":"Adding the Converter","text":"<p>Add a new file to your project - you can call it whatever you like but we recommend <code>Converter.cs</code> so you can map it to the Versioning_Toolkit.</p> <p>In this file you need to inherit from the Versioning_Toolkit <code>Converter</code> class which will come from the <code>BHoMUpgraderXY.dll</code> you referenced in the previous step. Ensuring your namespace is the same will help with this. Below is an example empty class you can copy into your <code>Converter</code> class.</p> <pre><code>namespace BH.Upgrader.v72\n{\n    public class YourToolConverter : Converter\n    {\n        public YourToolConverter() : base()\n        {\n\n        }\n    }\n}\n</code></pre> <p>In this example, the 7.2 <code>Converter</code> class is being inherited from. In here you can add versioning as you would to the BHoM versioning toolkit as outlined here.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#adding-the-program","title":"Adding the program","text":"<p>You will likely have had a <code>Program.cs</code> file added automatically - if you don't then add one now. If you do have one, ensure the namespace matches for your project, and then paste this code into it:</p> <pre><code>namespace BH.Upgrader.v72\n{\n    static class Program\n    {\n        /***************************************************/\n        /**** Entry Methods                             ****/\n        /***************************************************/\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 0)\n                return;\n\n            Base.Upgrader upgrader = new Base.Upgrader();\n            upgrader.ProcessingLoop(args[0], new YourToolConverter());\n        }\n\n        /***************************************************/\n    }\n}\n</code></pre> <p>This will be the entry point for Versioning_Engine to run your versioning upgrader later.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#add-your-upgrades-json-file","title":"Add your upgrades JSON file","text":"<p>Ensure your <code>Upgrades.json</code> file is added to the project, and that the <code>Copy to Output Directory</code> file property is set to <code>Copy Always</code>.</p> <p>This file can be empty (if a new milestone project) or contain existing versioning JSON (from BHoM or combined with your own) depending on your circumstances.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#compile","title":"Compile","text":"<p>Compile the project - you shouldn't encounter any errors and you should find that your <code>BHoMUpgrader</code> will have overwritten the BHoM <code>BHoMUpgrader</code> in the <code>$(ProgramData)\\BHoM\\Upgrades\\BHoMUpgraderXY</code> folder.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Creating-your-own-versioning/#complete","title":"Complete","text":"<p>Once you've reached this step, you will have your own versioning toolkit which you can add custom versioning to and it will work with the BHoM ecosystem.</p> <p>Any versioning for BHoM objects/methods/datasets will happen in BHoM's Versioning_Toolkit, so using this methodology will prevent you needing to keep an update of our versioning alongside your own. As mentioned, we encourage sharing knowledge back with the BHoM community if you are building off our toolkits, but if you need to have your own private versioning within our ecosystem, hopefully this documentation will aid you with that.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/How-to-check-your-versioned-changes-are-working/","title":"How to check your versioned changes are working ?","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/How-to-check-your-versioned-changes-are-working/#to-check-the-upgrade-of-a-property-type-or-namespace-upgrade","title":"To check the upgrade of a Property, Type or Namespace upgrade.","text":"<ol> <li>Before making any changes create an object from the Toolkit that will be upgraded.</li> <li>Use <code>ToJson</code> to create a JSON string of the object.</li> <li>Save a copy of that string.</li> <li>Make changes to the code and add versioning.</li> <li>Rebuild your Toolkit and the Versioning_Toolkit.</li> <li>Use <code>ToNewVersion</code> to and verify the output to check the upgrade worked.</li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Object-name-change-and-associated-custom-create-method/","title":"Object name change and associated custom create method","text":"<p>In the Audience_oM I want to change the object name for <code>ProfileParameters</code> to <code>TierProfileParameters</code>. There are two <code>Create</code> methods that will also need to be upgraded. This page describes the steps to achieve that.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Object-name-change-and-associated-custom-create-method/#first-i-am-going-to-set-up-some-files-and-data-to-help-with-the-process","title":"First I am going to set up some files and data to help with the process","text":"<ol> <li>Capture the JSON string of the object to change as described here.</li> <li> <p>Set up a simple file with the auto generated object create method component and related methods that the changes will impact:</p> <p> 1. Use the <code>VersioningKey</code> component to get the string that will later be used for the the <code>PreviousVersion</code> Attribute that I will add to the affected methods.</p> <p> 1. Copy the output of <code>VersioningKey</code> and paste into a text editor.</p> </li> <li> <p>Check the solution builds.</p> </li> <li>Create and add the versioning JSON file to the project. See here for the content of an empty <code>Versioning_XX.json</code> file.</li> <li> <p>Add the key value pairs to describe the <code>ToNew</code> and <code>ToOld</code> upgrade / downgrade.</p> <p>. 1. At this we can rebuild the solution and rebuild the <code>Versioning_Toolkit</code>. 1. First I'll check the upgrade using the json string and <code>ToNewVersion</code>:</p> <p> 1. If this fails double check all the steps above. 1. Open Rhino and the simple test file. 1. We'll see the auto generated create method has correctly upgraded, but the others show errors:</p> <p></p> </li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Object-name-change-and-associated-custom-create-method/#change-the-code-to-change-the-object-name","title":"Change the code to change the object name","text":"<ol> <li>Change the object name and the file name for this object.</li> <li>In the Engine and oM projects replace all instances of the old name with the new name.</li> </ol> <p> I'm using find and replace for the renaming - care should be taken here.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/Object-name-change-and-associated-custom-create-method/#change-the-code-to-change-the-methods","title":"Change the code to change the methods","text":"<ol> <li>I need to add the <code>PreviousVersion</code> attribute to ensure the methods are upgraded.</li> <li>The text we saved earlier looks like:     <pre><code>BH.Engine.Audience.Create.ProfileParameters(System.Double)\nBH.Engine.Audience.Create.ProfileParameters(System.Double, System.Double, System.Double, System.Double, System.Int32, System.Double, \nBH.oM.Humans.ViewQuality.EyePositionParameters, BH.oM.Audience.PlatformParameters)\n</code></pre></li> <li> <p>I'll use the first of those two as arguments to the <code>PreviousVersion</code> attribute which will be added to the first method like this:</p> <p> 1. And adding the <code>PreviousVersion</code> attribute to the second method with more arguments will look like this:</p> <p></p> </li> <li> <p>For compliance I will also change the name of the file containing those methods to match the renamed object type they return <code>TierProfileParameters</code>.</p> </li> <li> <p>We can now rebuild the solution and the <code>Versioning_Toolkit</code> and check again if this has worked.</p> <p></p> </li> </ol>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/technical-background-on-versioning/","title":"Technical background on Versioning","text":"<p>If you want to know about how the upgrader does its job, this section is for you. Otherwise, feel free to skip it.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/technical-background-on-versioning/#how-does-bhom-versioning-work","title":"How does BHoM Versioning work?","text":"<p>Alongside the dlls installed in <code>AppData\\Roaming\\BHoM\\Assemblies</code>, you can find in the <code>bin</code> sub-folder a series of <code>BHoMUpgrader</code> exe programs. When a type/method/object fails to deserialise from its string representation (json), those upgrader are called to the rescue.</p> <p>Every quarter, when we release a new beta installer, we also produce a new upgrader named <code>BHoMUpgrader</code> with the version number attached at the end (e.g. <code>BHoMUpgrader32</code> for version 3.2). That upgrader contains all the changes to the code that occurred during the quarter.</p> <p>When deserialisation fails in the BHoM, the BHoM version used to serialise the object is retrieved from the json. The json is then upgraded to the following version repeatedly until it reaches the current version where it can finally be deserialised into a BHoM object.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/technical-background-on-versioning/#decentralisation-of-the-upgrade-information","title":"Decentralisation of the upgrade information","text":"<p>We will go in details on how the upgrade information is stored inside an upgrader in the remaining sections. There is however one aspect worth mentioning already. Once a quarter is finished, an upgrader is never modified again and simply redistributed alongside the others. During that quarter however, the current upgrader is constantly updated to reflect the new changes. For everyone working on the BHoM to have to modify the exact same files inside the Versioning_Toolkit would be inconvenient and a frequent source of clashes. For that reason, the information related to the upgraded of the current quarter are stored locally at the root of each project where the change occurred. </p> <p></p> <p>Notice that the file name ends with the version of the BHoM it applies to.</p> <p>The content of an empty <code>Versioning_XX.json</code> file is as follow:</p> <pre><code>{\n  \"Namespace\": {\n    \"ToNew\": {\n    },\n    \"ToOld\": {\n    }\n  },\n  \"Type\": {\n    \"ToNew\": {\n\n    },\n    \"ToOld\": {\n    }\n  },\n  \"Property\": {\n    \"ToNew\": {\n    },\n    \"ToOld\": {\n    }\n  },\n  \"MessageForDeleted\": {\n  },\n  \"MessageForNoUpgrade\": {\n  }\n}\n</code></pre> <p>When the UI_PostBuild process that copies all the BHoM assemblies to the Roaming folder is ran (i.e. when BHoM_UI is compiled), the information from all the <code>Versioning_XX.json</code> files is collected and compiled in to a single json file copied to the roaming folder next to the BHoMUpgrader executable. It's content will look similar to the local json files with an extra section for the methods (more onto that later):</p> <pre><code>{\n  \"Namespace\": {\n    \"ToNew\": {\n      \"BH.Engine.XML\": \"BH.Engine.External.XML\",\n      \"BH.oM.XML\": \"BH.oM.External.XML\"\n    },\n    \"ToOld\": {\n      \"BH.Engine.External.XML\": \"BH.Engine.XML\",\n      \"BH.oM.External.XML\": \"BH.oM.XML\"\n    }\n  },\n  \"Type\": {\n    \"ToNew\": {\n      \"BH.oM.Base.IBHoMFragment\": \"BH.oM.Base.IFragment\",\n      \"BH.oM.Adapters.ETABS.EtabsConfig\": \"BH.oM.Adapters.ETABS.EtabsSettings\", \n    },\n    \"ToOld\": {\n      \"BH.oM.Base.IFragment\": \"BH.oM.Base.IBHoMFragment\",\n      \"BH.oM.Adapters.ETABS.EtabsSettings\":\"BH.oM.Adapters.ETABS.EtabsConfig\" \n    }\n  },\n  \"Method\": {\n    \"ToNew\": {\n        \"BH.Adapter.XML.XMLAdapter(BH.oM.Adapter.FileSettings, BH.oM.XML.Settings.XMLSettings)\": {\n            \"_t\": \"System.Reflection.MethodBase\", \n            \"TypeName\": \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.Adapter.XML.XMLAdapter, XML_Adapter, Version=3.0.0.0, Culture=neutral, PublicKeyToken=null\\\" }\",\n            \"MethodName\": \".ctor\",\n            \"Parameters\": [ \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.oM.Adapter.FileSettings\\\" }\" ]\n        },\n        \"BH.Engine.Geometry.Compute.ClipPolylines(BH.oM.Geometry.Polyline, BH.oM.Geometry.Polyline)\": {\n            \"_t\": \"System.Reflection.MethodBase\",\n            \"TypeName\": \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.Engine.Geometry.Compute, Geometry_Engine, Version=3.0.0.0, Culture=neutral, PublicKeyToken=null\\\" }\",\n            \"MethodName\": \"BooleanIntersection\",\n            \"Parameters\": [ \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.oM.Geometry.Polyline\\\" }\", \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.oM.Geometry.Polyline\\\" }\", \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"System.Double, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\\\" }\" ]\n        }\n    },\n    \"ToOld\": {\n\n    }\n  },\n  \"Property\": {\n    \"ToNew\": {\n        \"BH.oM.Structure.Elements.Bar.StartNode\": \"BH.oM.Structure.Elements.Bar.Start\",\n        \"BH.oM.Structure.Elements.Bar.EndNode\": \"BH.oM.Structure.Elements.Bar.End\"\n    },\n    \"ToOld\": {\n        \"BH.oM.Structure.Elements.Bar.Start\": \"BH.oM.Structure.Elements.Bar.StartNode\",\n        \"BH.oM.Structure.Elements.Bar.End\": \"BH.oM.Structure.Elements.Bar.End\",\n    }\n  },\n  \"MessageForDeleted\": {\n  },\n  \"MessageForNoUpgrade\": {\n  }\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/technical-background-on-versioning/#how-does-the-upgrader-work","title":"How does the upgrader work?","text":"<p>The diagram below show the chains of calls between the 3 main upgrade methods: - UpgradeMethod - UpgradeType - UPgradeObject</p> <p>Note that <code>UpgradeType</code> is actually covering both the namespace replacement and the type name replacement. The reason behind it is that they come down to the same string replacement principles both at the beginning of an item full name (since types include their namespace in their full name too).</p> <p>Also note that those three are the 3 places where an older upgrader can be called if needed.</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/","title":"Versioning guide: implementing versioning for your changes","text":"<p>Versioning can be implemented in one or two ways, depending on the situation:</p> <ol> <li>by adding the required information to a <code>Versioning_XX.json</code> file; and/or</li> <li>by adding a <code>PreviousVersion</code> attribute to your changed method.</li> </ol> <p>The choice of the appropriate one depends on the change you are doing, as explained in detail in the following sections. </p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#supported-changes","title":"Supported changes","text":"<p>BHoM Versioning supports:</p> <ul> <li> <p>Changes to methods (e.g. saved in a script): </p> <ul> <li>changes in the method name</li> <li>changes in their input/outputs names and types.</li> </ul> </li> <li> <p>Changes to Namespaces:</p> <ul> <li>renaming namespaces</li> <li>general modification to namespaces </li> </ul> </li> <li> <p>Changes to classes (object types): </p> <ul> <li>changes in class properties</li> <li>changes in their name</li> <li>complex structural changes</li> </ul> </li> <li> <p>Changes to Datasets:</p> <ul> <li>renaming or moving of location</li> <li>deletion </li> </ul> </li> </ul> <p>Head to the section below that is the most relevant to your case.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-methods","title":"Changes to methods","text":"<p>This section addresses how to do Versioning for code changes done to methods, which are probably the most common. There are two possibilites here, and the first is simpler and to be preferred. Both options apply to either method renamings and/or changes in method inputs.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#via-the-previousversion-attribute","title":"Via the <code>PreviousVersion</code> attribute","text":"<p>We recommend to simply add a <code>PreviousVersion</code> attribute on top of the method you are modifying. This attribute takes two arguments:</p> <ul> <li>The first argument of the attribute is the current version of BHoM, e.g. <code>6.1</code>. </li> <li>The second argument is the method's Versioning key, obtainable as explained in its dedicated section.</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#example-previousversion-for-a-method-renaming","title":"Example: <code>PreviousVersion</code> for a method renaming","text":"<p>In this example, a method whose full name was <code>FilterFamilyTypesOfFamily</code>, located in the namespace <code>BH.Engine.Adapters.Revit</code> and hosted under the static class <code>Create</code>, is renamed to <code>FilterTypesOfFamily</code>.</p> <p>Versioning using the <code>PreviousVersion</code> attribute for a method being renamed</p> <pre><code>public static partial class Create\n{\n    [PreviousVersion(\"3.2\", \"BH.Engine.Adapters.Revit.Create.FilterFamilyTypesOfFamily(BH.oM.Base.IBHoMObject)\")]\n    [Description(\"Creates an IRequest that filters Revit Family Types of input Family.\")]\n    [Input(\"bHoMObject\", \"BHoMObject that contains ElementId of a correspondent Revit element under Revit_elementId CustomData key - usually previously pulled from Revit.\")]\n    [Output(\"F\", \"IRequest to be used to filter Revit Family Types of a Family.\")]\n    public static FilterTypesOfFamily FilterTypesOfFamily(IBHoMObject bHoMObject)\n    {\n        //....\n    }\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#example-previousversion-for-a-methods-inputs-change","title":"Example: <code>PreviousVersion</code> for a method's inputs change","text":"<p>In this example, a method inputs are being changed: an input (the second one) is being removed. The method in the example is a constructor, but the same example applies to any method. Constructors are rarely used in BHoM \u2013 we prefer <code>Create</code> Engine methods, which get exposed to UIs \u2013 but some types, in particular <code>BHoM_Adapter</code> implementations, make use of them.</p> <p>Versioning using the <code>PreviousVersion</code> attribute for a method whose inputs are being changed</p> <pre><code>public partial class XMLAdapter : BHoMAdapter\n{\n    [PreviousVersion(\"3.2\", \"BH.Adapter.XML.XMLAdapter(BH.oM.Adapter.FileSettings, BH.oM.XML.Settings.XMLSettings)\")]\n    [Description(\"Specify XML file and properties for data transfer\")]\n    [Input(\"fileSettings\", \"Input the file settings to get the file name and directory the XML Adapter should use\")]\n    [Input(\"xmlSettings\", \"Input the additional XML Settings the adapter should use. Only used when pushing to an XML file. Default null\")]\n    [Output(\"adapter\", \"Adapter to XML\")]\n    public XMLAdapter(BH.oM.Adapter.FileSettings fileSettings = null)\n    {\n        //....\n    }\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#via-the-versioning-json-file","title":"Via the versioning json file","text":"<p>This alternative is trickier and not required in most cases.</p> <p>The way to do it is to provide a <code>Method</code> section in the <code>VersioningXX.json</code> file:</p> <ul> <li>Add a <code>VersioningXX.json</code> file to the project, if it does not yet exists for the current version of BHoM, as explained here.</li> <li>Create a Versioning key as explained here. </li> <li>Get a representational string of the method, like this. If you are changing a constructor method, just leave the <code>methodName</code> input empty.</li> <li>Add the following to the <code>Method</code> section of the <code>VersioningXX.json</code> file, as shown in the below example; make sure to place your changing method's Versioning key and representational string.</li> </ul> <p>Versioning using the <code>Versioning.json</code> file for a method whose inputs are being changed</p> <pre><code>  \"Method\": {\n    \"ToNew\": {\n      \"BH.Adapter.XML.XMLAdapter(BH.oM.Adapter.FileSettings, BH.oM.XML.Settings.XMLSettings)\": {\n        \"_t\": \"System.Reflection.MethodBase\",\n        \"TypeName\": \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.Adapter.XML.XMLAdapter, XML_Adapter, Version=3.0.0.0, Culture=neutral, PublicKeyToken=null\\\" }\",\n        \"MethodName\": \".ctor\",\n        \"Parameters\": [\n          \"{ \\\"_t\\\" : \\\"System.Type\\\", \\\"Name\\\" : \\\"BH.oM.Adapter.FileSettings\\\" }\"\n        ]\n      }\n    },\n    \"ToOld\": {\n\n    }\n  }\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-namespaces","title":"Changes to namespaces","text":"<p>This applies to the case where an entire namespace is renamed. This means all the elements inside that namespace will now belong to a new namespace. </p> <p>To record that change:</p> <ul> <li>Add a <code>VersioningXX.json</code> file to the project, if it does not yet exists for the current version of BHoM, as explained here.</li> <li>provide the old namespace as key and the new namespace as value to the <code>Namespace.ToNew</code> section of the json file. </li> </ul> <p>In order to make the change backward compatible (i.e. to allow downgrading, i.e. to open a newer BHoM script from a machine running an older version of BHoM), you can fill the <code>ToOld</code> section with mirrored information.</p> <p>Change in namespace</p> <pre><code>{\n  \"Namespace\": {\n    \"ToNew\": {\n      \"BH.oM.XML\":  \"BH.oM.External.XML\",\n    },\n    \"ToOld\": {\n      \"BH.oM.External.XML\": \"BH.oM.XML\",\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-objects","title":"Changes to objects","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-class-name","title":"Changes to class name","text":"<p>Modifying the name of a type (i.e. of a class, an object's type) requires to:</p> <ul> <li>add a <code>VersioningXX.json</code> file to the project, if it does not yet exists for the current version of BHoM, as explained here.</li> <li>add versioning information to the Versioning json file: provide the full name of the old type (namespace + type name) as key and the full name of the new type as value. </li> </ul> <p>In order to make the change backward compatible (i.e. to allow downgrading, i.e. to open a newer BHoM script from a machine running an older version of BHoM), you can fill the <code>ToOld</code> section with mirrored information. </p> <p>In the example below, we show how the Versioning json file looks like for two classes being renamed, respectively from <code>DocumentBuilder</code> to <code>GBXMLDocumentBuilder</code> and from <code>XMLSettings</code> to <code>GBXMLSettings</code>.</p> <p>Adding information to the <code>Versioning.json</code> file regarding two classes being renamed</p> <pre><code>{\n  ...\n  \"Type\": {\n    \"ToNew\": {\n      \"BH.oM.XML.Settings.XMLSettings\": \"BH.oM.External.XML.Settings.GBXMLSettings\",\n      \"BH.oM.XML.Environment.DocumentBuilder\": \"BH.oM.External.XML.GBXML.GBXMLDocumentBuilder\"\n    },\n    \"ToOld\": {\n      \"BH.oM.External.XML.Settings.GBXMLSettings\": \"BH.oM.XML.Settings.XMLSettings\",\n      \"BH.oM.External.XML.GBXML.GBXMLDocumentBuilder\": \"BH.oM.XML.Environment.DocumentBuilder\"\n    }\n  }\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-class-property-names","title":"Changes to class property names","text":"<p>For the case where an object type (i.e. class) was only modified by renaming some of its property, we have a simple solution relying on the Versioning json file. It requires to:</p> <ul> <li>add a <code>VersioningXX.json</code> file to the project, if it does not yet exists for the current version of BHoM, as explained here.</li> <li>add versioning information to the Versioning json file under the <code>Property.ToNew</code> entry. As a key, provide the full name of the type that contains the property you are renaming (namespace + type name) followed by the old property name. The value must be the new property name. </li> </ul> <p>In order to make the change backward compatible (i.e. to allow downgrading, i.e. to open a newer BHoM script from a machine running an older version of BHoM), you can fill the <code>ToOld</code> section with mirrored information. </p> <p>In the following example, two properties of the object <code>Bar</code> that lives in the namespace <code>BH.oM.Structure.Elements</code> are being renamed repectively from <code>StartNode</code> to <code>Start</code> and from <code>EndNode</code> to <code>End</code>.</p> <p>Changes in an object's property names</p> <pre><code>\"Property\": {\n    \"ToNew\": {\n        \"BH.oM.Structure.Elements.Bar.StartNode\": \"Start\",\n        \"BH.oM.Structure.Elements.Bar.EndNode\": \"End\"\n    },\n    \"ToOld\": {\n        \"BH.oM.Structure.Elements.Bar.Start\": \"StartNode\",\n        \"BH.oM.Structure.Elements.Bar.End\": \"End\",\n    }\n  }\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#structural-changes-to-a-class","title":"Structural changes to a class","text":"<p>What if you completely redesigned a type of object and changed the properties that define it?</p> <p>This case cannot be solved by a simple replacement of a string and will most likely require some calculations to go from the old object to the new one. This means we need a method that takes the old object in and return the new. This fact presents two challenges: </p> <ul> <li>The old object definition will not exist anymore, so we cannot use that as the input of the conversion method. Instead we will use a Dictionary containing the properties for both input and output of that conversion method. The other benefit is that the upgrader will not have to depend on BHoM dlls to be able to do the conversion.</li> <li>The conversion method needs to be compile and the upgrader needs to be able to access it. While there are ways to keep the conversion method decentralised, it is way simpler to have it in the versioning toolkit directly. This means this is the only case where you cannot just write the upgrade from your own repo. Luckily, this case is less frequent than the others.</li> </ul> <p>So what do you need to do to cover the upgrade?</p> <ul> <li>First, locate the <code>vXX.cs</code> file in the <code>CustomUpgrades</code> folder of the <code>BHoMUpgrades</code> project (with <code>XX</code> corresponding to the current version of the BHoM).</li> <li>In that file, write a conversion method with the following signature:  <pre><code>[VersioningTarget(\"&lt;Object type full name (namespace + type name)&gt;\")]\npublic static Dictionary&lt;string, object&gt; UpgradeOldClassName(Dictionary&lt;string, object&gt; old)\n{\n    // Your upgrade code here\n}\n</code></pre></li> <li>If you want to cover backward compatibility, you can also have to do the same in the CustomDowngrades folder. We generally don't provide downgraders so, if there isn't any, you will have to create a folder and a containing class. That class can be name what you want but make sure you attach a <code>Downgrader</code> attribute to it.</li> </ul> <p>Here's an example.</p> <p>Structural changes to an object</p> <pre><code>namespace BH.Upgraders\n{\n    [Upgrader(8, 2)]\n    public static class v82\n    {\n        /***************************************************/\n        /**** Public Methods                           ****/\n        /***************************************************/\n\n        [VersioningTarget(\"BH.oM.Versioning.OldVersion\")]\n        public static Dictionary&lt;string, object&gt; UpgradeOldVersion(Dictionary&lt;string, object&gt; old)\n        {\n            if (old == null)\n                return null;\n\n            double A = 0;\n            if (old.ContainsKey(\"A\")) \n                A = (double)old[\"A\"];\n\n            double B = 0;\n            if (old.ContainsKey(\"B\"))\n                B = (double)old[\"B\"];\n\n            return new Dictionary&lt;string, object&gt;\n            {\n                { \"_t\",  \"BH.oM.Versioning.NewVersion\" },\n                { \"AplusB\", A + B },\n                { \"AminusB\", A - B }\n            };\n        }\n\n        /***************************************************/\n    }\n}\n</code></pre> <p>A few things to notice:</p> <ul> <li>You are working from a Dictionary so make sure that the properties exist before using them</li> <li>You will also need to cast them since the dictionary values are all objects</li> <li>Make sure to provide the new object type in the dictionary by defining the \"_t\" property.</li> </ul>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-datasets","title":"Changes to Datasets","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#changes-to-a-dataset-name-or-location","title":"Changes to a Dataset name or location","text":"<p>Updating the path to a Dataset works in a similar manner to changes to names of types. The path to a dataset is changed the path from C:\\ProgramData\\BHoM\\Datasets leading up to the json file has been changed in any way. This could be for example be one or more of the following:</p> <ul> <li>The name of the json file has been changed</li> <li>The name of the folder or any super-folder of the json file has been changed</li> <li>An additional folder has been added to the path</li> <li>A folder has been removed from the path</li> </ul> <p>When this has happened, you will need to:</p> <ul> <li>add a <code>VersioningXX.json</code> file to the project, if it does not yet exists for the current version of BHoM, as explained here.</li> <li>add versioning information to the Versioning json file under the <code>Dataset</code> entries, as shown in the example below.</li> </ul> <p>In the example below, the Versioning json file specifies the move of some structural material files to a parent folder called <code>Structure</code>.</p> <p>Changes in a Dataset name or location</p> <pre><code>{\n  \"Dataset\": {\n    \"ToNew\": {\n      \"Materials\\\\MaterialsEurope\\\\Concrete\": \"Structure\\\\Materials\\\\MaterialsEurope\\\\Concrete\",\n      \"Materials\\\\MaterialsEurope\\\\Rebar\": \"Structure\\\\Materials\\\\MaterialsEurope\\\\Rebar\",\n      \"Materials\\\\MaterialsEurope\\\\Steel(Grade)\": \"Structure\\\\Materials\\\\MaterialsEurope\\\\Steel(Grade)\",\n      \"Materials\\\\MaterialsEurope\\\\Steel\": \"Structure\\\\Materials\\\\MaterialsEurope\\\\Steel\",\n      \"Materials\\\\MaterialsUSA\\\\Concrete\": \"Structure\\\\Materials\\\\MaterialsUSA\\\\Concrete\",\n      \"Materials\\\\MaterialsUSA\\\\Steel\": \"Structure\\\\Materials\\\\MaterialsUSA\\\\Steel\",\n    },\n    \"ToOld\": {\n      \"Structure\\\\Materials\\\\MaterialsEurope\\\\Concrete\": \"Materials\\\\MaterialsEurope\\\\Concrete\",\n      \"Structure\\\\Materials\\\\MaterialsEurope\\\\Rebar\": \"Materials\\\\MaterialsEurope\\\\Rebar\",\n      \"Structure\\\\Materials\\\\MaterialsEurope\\\\Steel(Grade)\": \"Materials\\\\MaterialsEurope\\\\Steel(Grade)\",\n      \"Structure\\\\Materials\\\\MaterialsEurope\\\\Steel\": \"Materials\\\\MaterialsEurope\\\\Steel\",\n      \"Structure\\\\Materials\\\\MaterialsUSA\\\\Concrete\": \"Materials\\\\MaterialsUSA\\\\Concrete\",\n      \"Structure\\\\Materials\\\\MaterialsUSA\\\\Steel\": \"Materials\\\\MaterialsUSA\\\\Steel\",\n    }\n  }\n}\n</code></pre> <p>When versioning Dataset the <code>ToNew</code> segment is required, and not optional. This is for the BHoM_UI to be able to update components linking to the Dataset.</p> <p>The <code>ToOld</code>versioning of Dataset is optional, but should be done if the developer wants to ensure that the Dataset still is acessible from the same serach paths as before, for calls to the methods in the Library_Engine to still work. This could for example be to ensure the call <code>BH.Engine.Library.Libraries(\"Materials\\\\MaterialsEurope\\\\Concrete\")</code> still returns the same Dataset as before the change was made. It is strongly recomended that calls like the above from  code is updated at the same time as the change to the dataset is made, but generally recomended that the <code>ToOld</code> versioning is done to ensure calls from any UI and that code calls to the methods outside the control of the developer making the change is still functions as before.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#deletion-of-a-dataset","title":"Deletion of a Dataset","text":"<p>When a dataset is removed without a replacement, a message should be provided, similar to how it is done for objects and methods. For datasets this is done via the MessageForDeleted section of the Dataset part of the upgrade. Example below showcasing a case where the European concrete and rebar materials have been removed:</p> <p>Removed Dataset</p> <pre><code>{\n  \"Dataset\": {\n    \"ToNew\": {\n    },\n    \"ToOld\": {\n    }\n    \"MessageForDeleted\": {\n      \"Materials\\\\MaterialsEurope\\\\Concrete\": \"Clear message why this dataset has been removed. Point of contact (could be a github repository) where the user can ask questions about why this was removed.\",\n      \"Materials\\\\MaterialsEurope\\\\Rebar\": \"Clear message why this dataset has been removed. Point of contact (could be a github repository) where the user can ask questions about why this was removed.\",\n    }\n  }\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#items-that-cannot-be-versioned-deletions-or-foundational-changes","title":"Items that cannot be versioned: deletions or foundational changes","text":"<p>In some cases, an upgrade/downgrade of a method or object is simply not possible:</p> <ul> <li>The item was deleted without replacement</li> <li>A replacement exists but is so different from the original that an automatic conversion is impossible.</li> </ul> <p>In such cases, it is important to inform the user and provide them with as much information as possible to facilitate the transition to the new version of the code. You will need to:</p> <ul> <li>add a <code>VersioningXX.json</code> file to the project, if it does not yet exists for the current version of BHoM, as explained here.</li> <li>add versioning information to the Versioning json file under the <code>MessageForDeleted</code> and/or <code>MessageForNoUpgrade</code> entries. As shown in the example below.</li> </ul> <p>Items that cannot be versioned</p> <pre><code>{\n  ...\n  \"MessageForDeleted\": {\n    \"BH.oM.Adapters.DIALux.Furnishing\": \"This object was provided to build up DIALux models within a BHoM UI, but was deemed to be unnecessary with the suitable conversions between existing Environmental objects and DIALux provided by the DIALux Adapter. To avoid confusion, this object has been removed. If further assistance is needed, please raise an issue on https://github.com/BHoM/DIALux_Toolkit/issues\",\n    \"BH.Engine.Grasshopper.Compute.IRenderMeshes(BH.oM.Geometry.IGeometry, Grasshopper.Kernel.GH_PreviewMeshArgs)\": \"The method was made internal to the Grasshopper Toolkit. If you still need to render objects, consider using one of the Render methods from BH.Engine.Representation instead\",\n    \"BH.Engine.Adapters.Revit.Query.Location(BH.oM.Adapters.Revit.Elements.ModelInstance)\": \"This method was a duplicate of GetProperty method, please use the latter instead.\",\n    \"BH.Engine.BuildingEnvironment.Convert.ToConstruction(BH.oM.Base.CustomObject)\": \"This method was providing a highly specific conversion between a specific custom data schema and Environment Materials that is no longer relevant to the workflows provided in Environments. It is advised to create materials manually using the Solid or Gas types as appropriate. For more assistance please raise an issue for discussion on https://github.com/BuroHappoldEngineering/BuildingEnvironments_Toolkit/issues\",\n  },\n  \"MessageForNoUpgrade\": {\n    \"BH.oM.Structure.Loads.BarVaryingDistributedLoad\": \"The object has been redefined in such a way that automatic versioning is not possible. To reinstate the objects you could try exploding the CustomObject that will have been returned and make use of the BH.Enigne.Structure.Create.BarVaryingDistributedLoadDistanceBothEnds method from the Structures_Engine. If doing this, treat DistanceFromA as startToStartDistance and DistanceFromB as endToEndDistance. Also, treat ForceA and MomentA as ForceAtStart and MomentAtStart, and ForceB and MomentB as ForceAtEnd and MomentAtEnd. If you have any issues with the above, please feel free to raise an issue at https://github.com/BHoM/BHoM_Engine/issues.\",\n    \"BH.Engine.Reflection.Modify.SetPropertyValue(System.Collections.Generic.List&lt;BH.oM.Base.IBHoMObject&gt;, System.Type, System.String, System.Object)\": \"Please use BH.Engine.Reflection.Modify.SetPropertyValue(object obj, string propName, object value) instead.\",\n    \"BH.Engine.Base.Compute.Hash(BH.oM.Base.IObject, System.Collections.Generic.List&lt;System.String&gt;, System.Collections.Generic.List&lt;System.String&gt;, System.Collections.Generic.List&lt;System.String&gt;, System.Collections.Generic.List&lt;System.Type&gt;, System.Int32)\": \"This method's functionality has changed deeply with respect to an older version of BHoM. Please replace this component with BH.Engine.Base.Query.Hash(), then plug the inputs as needed.\",\n    \"BH.Engine.Adapters.Revit.Create.ViewPlan\": \"This method is not available any more. To reinstate the object, please use BH.Engine.Adapters.Revit.Create(string, string) instead.\",\n    \"BH.oM.LifeCycleAssessment.MEPScope\": \"This object has been updated to include new features to enhance calculations for LifeCycleAssesment workflows. Please update the object on the canvas using the default create component to update this component. For further assistance, please raise an issue on https://github.com/BHoM/LifeCycleAssessment_Toolkit/issues\",\n  }\n}\n</code></pre>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#obtaining-a-versioning-key","title":"Obtaining a Versioning Key","text":"<p>A versioning key is like a signature identifying a method or object.  You can obtain it by using the <code>BH.Engine.Versioning.VersioningKey()</code> method, as explained below.</p> <p>Important: get the versioning key before the change</p> <p>You need to get the versioning key of the object/method before it was changed. If you have already done your code changes, no worries: you can simply commit your changes on your branch, then switch back to the <code>develop</code> branch and recompile, then use the <code>BH.Engine.Versioning.VersioningKey()</code> as explained below.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#get-the-key-for-objects","title":"Get the key for objects","text":"<p>Use the method <code>BH.Engine.Versioning.VersioningKey()</code> and just provide the input <code>declaringType</code>, which is the Full Name of the object that you are modifying (i.e. the name of the class preceded by its namespace).</p> <p>Get the Versioning key for objects</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#get-the-key-for-methods","title":"Get the key for methods","text":"<p>Use the method <code>BH.Engine.Versioning.VersioningKey()</code> and provide both:</p> <ul> <li>the input <code>declaringType</code>, which is the Full Name of the Query/Compute/Create/Modify/Convert class (i.e. the name of the class, preceded by its namespace) which contains the method that you are modifying;</li> <li>the input <code>methodName</code>, which is the name of the method that you are modifying (in case you are renaming the method, this needs to be its name before the rename).</li> </ul> <p>Get the Versioning key for methods</p> <p></p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#adding-a-versioning_xxjson-file-to-the-project","title":"Adding a <code>Versioning_XX.json</code> file to the project","text":"<p>Adding a <code>Versioning_XX.json</code> file to the project is needed for certain versioning scenarios, but not all. In some cases (e.g. changes in a method) it may be sufficient to use the <code>PreviousVersion</code> attribute.</p> <p>This is as simple as adding an empty json file to the project, named <code>Versioning_XX.json</code>, where the <code>XX</code> must be replaced with the current BHoM version. For example:</p> <p></p> <p>The empty file should then be immediately populated with the following content (copy-paste it!):</p> <pre><code>{\n  \"Namespace\": {\n    \"ToNew\": {\n    },\n    \"ToOld\": {\n    }\n  },\n  \"Type\": {\n    \"ToNew\": {\n\n    },\n    \"ToOld\": {\n    }\n  },\n  \"Property\": {\n    \"ToNew\": {\n    },\n    \"ToOld\": {\n    }\n  },\n  \"MessageForDeleted\": {\n  },\n  \"MessageForNoUpgrade\": {\n  }\n}\n</code></pre> <p>Then you can fill it in as described by the relevant \"changes\" section.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#why-having-a-versioning_xxjson-file","title":"Why having a <code>Versioning_XX.json</code> file?","text":"<p>BHoM Versioning is implemented via a specific, stand-alone mechanism, hosted in the Versioning_Toolkit.</p> <p>By adding a <code>Versioning_XX.json</code> file, the information related to code changes are stored locally in each project where the change occurred. This enables decentralisation, i.e. many people can independently code and change BHoM objects or methods in different Toolkits without the need to modify the Versioning_Toolkit, avoiding clashes.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#troubleshooting-on-versioning","title":"Troubleshooting on Versioning","text":""},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#the-upgrade-doesnt-happen-how-can-i-debug","title":"The upgrade doesn't happen - How can I debug ?","text":"<p>The upgrader are independent exe files so you cannot reach them by attaching to your UI process as you would normally do when debugging the BHoM. They are also hidden processed so you don't have command windows popping up when opening old scripts. In case, you need to figure out what is going on in there, you can always have those upgrade processes visible by commenting two lines of code in the Versioning_Engine (situated on the code <code>BHoM_Engine</code> repo):</p> <ul> <li>In the Versioning-Engine project, find the <code>ToNewVersion</code> file</li> <li>In that file, find the <code>GetPipe</code> method </li> <li>Toward the end of that method, comment out the following line:</li> </ul> <p><pre><code>process.StartInfo.UseShellExecute = false;\nprocess.StartInfo.CreateNoWindow = true;\n</code></pre> - recompile the solution and the BHoM_UI as usual</p> <p>You should now have command windows popping up as soon as the upgrader are needed. You should also find the BHoMUpgrader processes in your task manager.</p>"},{"location":"Guides-and-Tutorials/Coding-with-BHoM/Versioning/versioning-guide/#walkthroughs-on-versioning","title":"Walkthroughs on Versioning","text":"<ul> <li>How to check your versioned changes are working</li> <li>Property name change</li> <li>Object name change and associated custom create method</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/","title":"Getting started for visual programmers","text":"<p>For this introduction, we will be using Grasshopper as a model but be aware that the same general principles will apply to other UIs (Excel, ...) too. </p> <p>Have you already installed the BHoM?</p> <p>Not yet? To follow along with the examples below you might want to first get the BHoM Plugins. </p> <p>See our Guide to installing the BHoM</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#key-concept","title":"Key Concept","text":"<p>The UI layer has been designed so that it will automatically pick everything implemented in the BHoM, the Engines and the Adapters without the need to change anything on the code of the UI. This means that, instead of having one component for every single piece of functionality, it will group them under common components. This way, the number of component there doesn't have to change when more functionality is added to the rest of the code. Here's what it looks like in Grasshopper:</p> <p></p> <p>In a few words, the oM section is for creating object, the Engine section is for manipulating objects, using them to derive information, or running some form of calculation, and the Adapter section is for exchanging data with external softwares.</p> <p>In order to explain how most of those components work, let's start with the Create BHoM Object that can be found in the oM section:</p> <p></p> <p>As you can see, you first drop a dummy component on the canvas that has no input nor output. You then select in its menu what you want it to be to turn it into its final form.</p> <p>The principle is exactly the same for the Compute, Convert, Modify, and Query components in the Engine section as well as for the Create Adapter and Create Query components in the Adapter section. Here's the example for the Create and Create Adapter components:</p> <p></p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#search-menus","title":"Search Menus","text":"<p>Notice that there are a couple more ways to create the final component you need: </p> <ul> <li>Use the search menu from the component:</li> </ul> <p></p> <ul> <li>Use the Ctrl+Shift+B shortcut and then do a search from that menu</li> </ul> <p></p> <p>If you want to search for something that include a series of words, just separate them by a space like done above.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#create-custom-objects","title":"Create Custom Objects","text":"<p>We have seen how to Create BHoM objects using the Create BHoMObject component. There will be situations where you need a type of object that is not part of the BHoM (yet?). For this, we have the CustomObject component:</p> <p></p> <p>This component allows you to define your own objects with a custom set of properties. You will notice that the Component start with two inputs: Name and Tags. This is because a CustomObject is also a BHoMObject and every BHoMObject has a property for Name and a property for Tags. IF you don't want to use those two, just remove them.</p> <p>Usually, that component is automatically figuring out the type of each property based on the data plugged in its inputs. There might be times when it got it wrong. For that reason, you can always specify manually the type of each input from its context menu. This is especially useful when the input is a list. In that case, just tick the box for List to tell Grasshopper you want that list as a single input instead of one value in the list per object.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#alternative-ways-to-create-known-types-of-objects","title":"Alternative Ways to Create Known Types of Objects","text":"<p>The CreateObject component provides a series of recommended ways to create known objects. Those correspond to the methods defined in the Create section of the BHoM_Engine. There might be rare cases where you cannot find a constructor that suits your needs. In that situation, you can use the CreateCustom component to define your own way to build a known object, just select the type of object you want to create from the contextual menu and select your own inputs. Inputs that are not properties of the object will be stored in CustomData.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#other-types-of-objects","title":"Other Types of Objects","text":"<p>Sometimes, you will find a component requiring an input that is not a BHoM object and not something you can create in Grasshopper either. The Enum, Type and Dictionary components are exactly there to cover those situations. One case you will probably encounter soon is when using the FilterQuery component from the Adapter section. </p> <p></p> <p>The Dictionary and Enum work from the same principle: you select their final form from their menu. </p> <p>The Enum component has a slightly different form though:</p> <p></p> <p>The Data component shown above is allowing you to select data from one of our static databases. Its output type will therefore vary based on the data you select. Those will generally be a BHoM object though.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#engine-components","title":"Engine components","text":"<p>The 4 components on the left correspond to the 4 categories of methods you can find in the Engine: Compute, Convert, Modify, and Query (Create being in the oM section). </p> <p>The 3 components in the middle are for extracting or updating properties of BHoM objects. The one you will probably use most of the time is the Explode component:</p> <p></p> <p>The last two components are for converting any BHoM object to and from JSON. This stand for JavaScript Object Notation. This is the langage we use when we represent BHoM objects as string. Unless you see straight away how those components can be of used to you, you can safely ignore them.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#adapter-components","title":"Adapter components","text":"<p>We have already mentioned the Create Adapter and the Create Query components from the right part of the Adapter section. The 6 components on the left part correspond to the 6 operations provided by the interface of every BHoM adapter: Push, Pull, UpdateProperty, Delete, Excecute and Move. Most likely than not, you will generally use the Push and Pull components so we'll show how those two work here. </p> <p></p> <p>Here we have the Socket adapter to send data across and get it back. Obviously, you would use sockets to send data between two different UIs or computers instead of just within Grasshopper but this example is just to show how the Push and Pull components are working.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/#things-to-remember","title":"Things to Remember","text":"<p>While we have shown quite a few things here, the main thing to remember is that most of the components in our UIs require you to select something from their menu before they switch to their final state. You can do that by either navigation the menu tree or using the search box. Those menu trees are organised exactly the same way has the code you will find on GitHub. You can also use Ctrl+Shift+B to create the final component directly. </p> <p>On top of that concept, remember the CustomObject and Explode components. They are a very convenient way to pack and unpack groups of data.</p> <p>From there, the best way to learn how to use those tools is to play with them in your UI of choice or to browse the documentation provided on the Wiki of each repository.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-Revit-objects-comparison-%28RevitComparisonConfig%29/","title":"Configuring Revit objects comparison (RevitComparisonConfig)","text":"<p>As we've seen in the Diffing and Hash pages, we can customise how objects are compared to each other (either using Diffing or by comparing their Hashes) through the <code>ComparisonConfig</code> object.</p> <p>In addition to the basic <code>ComparisonConfig</code> that we can use with any object, we also have a Revit-specific <code>RevitComparisonConfig</code> object that expands the available options.</p> <p>Below is an example of how the <code>RevitComparisonConfig</code> looks in Grasshopper. Note that most of them are already covered by the <code>ComparisonConfig</code> object base wiki, while the Revit-specific options are only the first 4 (explained below).</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-Revit-objects-comparison-%28RevitComparisonConfig%29/#note-for-developers-toolkit-specific-comparisonconfig-objects","title":"Note for developers: Toolkit-specific <code>ComparisonConfig</code> objects","text":"<p>The \"default\" <code>comparisonConfig</code> object inherits from the <code>BaseComparisonConfig</code> abstract class, which defines all the \"basic\" options. This abstract class can be extended by the \"Toolkit-specific\" <code>comparisonConfig</code>s, so you can include additional options to deal with certain objects in your Toolkit, of which <code>RevitComparisonConfig</code> is an example.  </p> <p>In general, if you implement your own Toolkit-specific <code>comparisonConfig</code> object, you will need to implement the functions that deal with it, i.e. a toolkit-specific <code>Diffing()</code> method and a toolkit-specific <code>HashString()</code> method.</p> <p>The <code>RevitComparisonConfig</code> is in fact used by the <code>RevitDiffing()</code> method, and, when hashing, by Revit's <code>HashString()</code> method. These two methods can be invoked manually, to deal with Revit Objects, or are automatically invoked by the IDiffing() method when the input objects are Revit objects.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-Revit-objects-comparison-%28RevitComparisonConfig%29/#parametersexceptions","title":"<code>ParametersExceptions</code>","text":"<p>Allows to specify Revit Parameter names that should not be considered while Diffing or computing an object's Hash.</p> <p>This supports <code>*</code> wildcard matching.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-Revit-objects-comparison-%28RevitComparisonConfig%29/#parameterstoconsider","title":"<code>ParametersToConsider</code>","text":"<p>The <code>ParametersToConsider</code> input allows you to add parameter names that should be considered while Diffing or computing an object's Hash.</p> <p>If you add a parameter name in this field, only the value held in that parameter will be considered.</p> <p>If the parameter name that you specified is not found on the object, then no parameter will be considered for that object.</p> <p>This input supports <code>*</code> wildcard matching.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-Revit-objects-comparison-%28RevitComparisonConfig%29/#parameternumerictolerance","title":"<code>ParameterNumericTolerance</code>","text":"<p>This works similarly to the <code>PropertyNumericTolerance</code> option, but it applies to Revit Parameters only. See that wiki section for more details on how to use it.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-Revit-objects-comparison-%28RevitComparisonConfig%29/#parametersignificantfigures","title":"<code>ParameterSignificantFigures</code>","text":"<p>This works similarly to the <code>PropertySignificantFigures</code> option, but it applies to Revit Parameters only. See that wiki section for more details on how to use it.</p> <p></p> <p>For a description of all remaining options, see /Configuring-objects-comparison:-%60ComparisonConfig%60.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/","title":"Configuring object comparison: <code>ComparisonConfig</code>","text":"<p>As seen in the Diffing and the Hash wiki pages, the real power of object comparison is given by the options that you have when performing it. For this reason, we expose options to customise these operations via the <code>ComparisonConfig</code> object. </p> <p>Here is an example of the ComparisonConfig object seen from Grasshopper:</p> <p></p> <p>There are also \"Toolkit-specific\" <code>ComparisonConfig</code> objects that extend the available options when dealing with certain objects, for example Revit's <code>RevitComparisonConfig</code> gives further options when dealing with Revit objects. More details on it in its dedicated page.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#note-for-developers","title":"Note for developers","text":"<p>The \"default\" <code>comparisonConfig</code> object inherits from the <code>BaseComparisonConfig</code> abstract class, which defines all the \"basic\" options. This abstract class can be extended by the \"Toolkit-specific\" <code>comparisonConfig</code>s, so you can include additional options to deal with certain objects in your Toolkit, of which <code>RevitComparisonConfig</code> is an example. If you implement your own Toolkit-specific <code>comparisonConfig</code> object, you will need to implement the functions that deal with it too, which are a  toolkit-specific <code>Diffing()</code> method (example in Revit), a toolkit-specific <code>HashString()</code> method (example in Revit), and any  number of <code>ComparisonInclusion()</code> methods that you might need (example in Revit). More details can be found in the diffing guide for developers.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#description-of-the-comparisonconfig-options","title":"Description of the <code>ComparisonConfig</code> options","text":"<p>Let's see the <code>ComparisonConfig</code> options in detail.  </p> <p>Many of the following examples use the <code>Bar</code> class as a reference object.</p> <ul> <li>PropertyExceptions</li> <li>PropertiesToConsider</li> <li>CustomDataKeysExceptions</li> <li>CustomDataKeysToConsider</li> <li>TypeExceptions</li> <li>NamespaceExceptions</li> <li>MaxNesting</li> <li>MaxPropertyDifferences</li> <li>NumericTolerance</li> <li>PropertyNumericTolerance</li> <li>SignificantFigures</li> <li>PropertySignificantFigures</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#propertyexceptions","title":"PropertyExceptions","text":"<p>You can specify one or more names of properties that you want to ignore (not consider, take as exceptions) when comparing objects.  This allows to ignore properties and also sub-properties (i.e., properties of properties) of any object. This also supports <code>*</code> wildcard within property names, so you can match multiple properties. You can specify either the simple name of the property (e.g. <code>StartNode</code>), or the FullName of the property (e.g. <code>BH.oM.Structure.Elements.Bar.StartNode</code>) if you want to be more precise and avoid confusion in case you have properties/sub-properties with the same name.</p> <p>To clarify the above, here are examples using the <code>Bar</code> class as a reference: </p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#property-name-vs-property-full-name-examples","title":"Property name VS Property Full Name - examples","text":"<ul> <li>Specifying the property name <code>StartNode</code> would ignore the <code>StartNode</code> property. It follows that any sub-property of <code>StartNode</code> will also be ignored.</li> <li>Specifying the property Full Name <code>BH.oM.Structure.Element.Bar.StartNode</code> would achieve the same result, but it is safer than using only the simple name <code>StartNode</code> (and may as well save computation time, like in the case of PropertiesToConsider when Hashing).</li> </ul> <p>To explain why using the property Full Name is safer, consider the example where you are Diffing a mix of objects which include both <code>Bar</code>s and also <code>GraphLink</code>s, both of which own a <code>StartNode</code> property. If you input <code>StartNode</code> in the <code>PropertyExceptions</code>, you must be aware that both properties <code>BH.oM.Structure.Elements.Bar.StartNode</code> and <code>BH.oM.Data.Collections.GraphLink.StartNode</code> will be treated as exceptions, hence ignored. Specifying the property full name is safer.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#sub-properties-examples","title":"Sub-properties examples","text":"<ul> <li>Specifying <code>StartNode.Position</code>, would ignore any change in the <code>Position</code> property of the start Node, but all the other properties of <code>StartNode</code> would still be considered.</li> <li>Specifying <code>StartNode.Position.X</code>, would ignore any change in the <code>X</code> property of the start Node's Position property, but all the other properties of <code>StartNode.Position</code> would still be considered.</li> <li>Again, you can specify the Full Name even for sub-properties, like <code>BH.oM.Structure.Elements.Bar.StartNode.Position.X</code>, and as seen above, this is safer.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#wildcard-examples","title":"Wildcard examples","text":"<p>You can specify <code>*</code> wildcards within property names, so you can match multiple properties with a single text.</p> <ul> <li>Specifying <code>BH.oM.Structure.Elements.Bar.*.Position.Y</code> would match:</li> <li><code>BH.oM.Structure.Elements.Bar.StartNode.Position.Y</code></li> <li><code>BH.oM.Structure.Elements.Bar.EndNode.Position.Y</code></li> </ul> <p>so if this is specified in the <code>PropertyExceptions</code>, those 2 properties will be ignored.</p> <ul> <li>Specifying <code>BH.oM.Structure.Elements.Bar.*.Y</code> would match:</li> <li><code>BH.oM.Structure.Elements.Bar.StartNode.Position.Y</code></li> <li><code>BH.oM.Structure.Elements.Bar.EndNode.Position.Y</code></li> <li><code>BH.oM.Structure.Elements.Bar.StartNode.Orientation.Y</code></li> <li><code>BH.oM.Structure.Elements.Bar.EndNode.Orientation.Y</code> </li> </ul> <p>so if this is specified in the <code>PropertyExceptions</code>, those 4 properties will be ignored.</p> <ul> <li> <p>Again, you can specify only the name instead of the Full Name to obtain the same result, i.e. <code>*.Position.Y</code> would achieve the same result as <code>BH.oM.Structure.Elements.Bar.*.Position.Y</code> when the input objects are only <code>Bar</code>s, but you incur in the same risks illustrated above if your input objects are of different types (see property name VS property Full Name).</p> </li> <li> <p>You can add as many <code>*</code> wildcards as you wish, which is especially handy when you have input objects of different types. Specifying <code>BH.oM.Structure.*.Start*.*Y</code> with both <code>Bar</code>s and <code>BarRelease</code>s input objects would match all of the following properties:</p> </li> <li><code>BH.oM.Structure.Elements.Bar.StartNode.Position.Y</code></li> <li><code>BH.oM.Structure.Elements.Bar.StartNode.Orientation.Y</code></li> <li><code>BH.oM.Structure.Elements.Bar.StartNode.Offset.Start.Y</code></li> <li><code>BH.oM.Structure.Constraints.BarRelease.StartRelease.TranslationalStiffnessY</code></li> <li><code>BH.oM.Structure.Constraints.BarRelease.StartRelease.RotationalStiffnessY</code></li> <li><code>BH.oM.Structure.Constraints.BarRelease.StartRelease.TranslationY</code></li> <li><code>BH.oM.Structure.Constraints.BarRelease.StartRelease.RotationY</code></li> </ul> <p>so if this is specified in the <code>PropertyExceptions</code>, and both <code>Bar</code>s and <code>BarRelease</code>s are in the input objects, all those 7 properties will be ignored. If instead you only had <code>Bar</code>s in the input objects, the <code>BH.oM.Structure.*.Start*.*Y</code> would only match the first 3 properties in the list above.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#propertiestoconsider","title":"PropertiesToConsider","text":"<p>The <code>PropertiesToConsider</code> input allows you to add property names that should be considered in the comparison.  </p> <p>If you add a property name in this field, only the value held in that property will be considered. </p> <p>If the property name that you specified is not found on the object, then no properties will be considered. Therefore, make sure you input property names that exist on the object.</p> <p>Like for the <code>PropertyExceptions</code> option, you can specify the property names as just the Name (e.g. <code>StartNode</code>), as a Full Name (e.g. <code>BH.oM.Structure.Elements.Bar.StartNode</code>) and/or using wildcards (e.g. <code>BH.oM.Structure.Elements.*.StartNode</code>) to get different matching results. See the section on <code>PropertyExceptions</code> for more details on Full Names and using wildcards.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#note-hash-performance-when-using-propertiestoconsider","title":"Note: Hash performance when using <code>PropertiesToConsider</code>","text":"<p>Using <code>PropertiesToConsider</code> can be a resource-intensive operation when calculating an object's Hash (Diffing instead is only slightly affected). To speed up the Hash computation: - use only property Full Names as an input to <code>PropertiesToConsider</code>; - do not use Wildcards in <code>PropertiesToConsider</code>; - limit the amount of property names in <code>PropertiesToConsider</code>.</p> <p>Technical explanation in the details below.</p> <p>The Hash of an object is calculated by recursively navigating all properties of the object and taking their value. If you specify some <code>PropertiesToConsider</code>, the property value is only considered if its name matches a property name in there. Then, the recursion continues, and if the current property has some sub-property, the algorithm checks the sub-property, and so on. When checking a certain property, the algorithm doesn't know the names of all its sub-properties until it gets there. </p> <p>If the property names include Wildcards or are not specified as Full Names, there can be situations where some nested sub-property needs to be considered, but then its parent's siblings must be ignored. When computing the <code>Hash()</code>, we are traversing the property tree of the object, but we do not know all the properties during the traversal. For example, say that your input object is a <code>Bar</code>, and you want to consider exclusively properties that match <code>*.Name</code>. The situation is:</p> <p></p> <p>One way of solving this could be to \"consider\" all the properties of the object while doing the Hash, and, at the end, cull away those that do not match any <code>PropertiesToConsider</code>. This basically is like saying that we build our knowledge of the object while computing its Hash. However, this can be wasteful for two reasons: - speed: many other operations may be done to the object values being considered when computing the Hash (e.g. numerical approximations); - space: we would need to store in RAM many values that we may never use.</p> <p>For this reason, we instead build the knowledge of the property tree before computing the hash; in other words, we traverse the entire object once and look at the property names, and get the \"consequent\" PropertiesToConsider, i.e. all the properties of the object that match your wildcard or partial property name, translated to their Full Name form. By using Full Names, it the becomes easy for the Hash algorithm to consider or not a property: just check if the property full name matches any of the <code>PropertiesToConsider</code>.</p> <p>The cost of this can be cut by specifying Full Names instead of just the name (i.e. <code>BH.oM.Structure.Elements.Bar.StartNode</code> instead of <code>StartNode</code>) and avoiding wildcards <code>*</code> when using <code>PropertiesToConsider</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#customdatakeysexceptions","title":"CustomDataKeysExceptions","text":"<p>This works similarly to <code>PropertyExceptions</code>, but is used only for BHoMObjects CustomData dictionary keys. </p> <p>Setting a key name in <code>CustomDataKeysExceptions</code> means that if that key is found on in the CustomData dictionary of an object, it will not be considered.</p> <p>This option does not support wildcard, unlike <code>PropertyExceptions</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#customdatakeystoconsider","title":"CustomDataKeysToConsider","text":"<p>Setting a key name in <code>CustomDataKeysToConsider</code> means that only that dictionary key will be considered amongst any BHoMObject's CustomData. If no matching CustomData key is found on the object, no CustomData entry will be considered.</p> <p>This option does not support wildcard.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#typeexceptions","title":"TypeExceptions","text":"<p>You can input any Type here. Any object or property of corresponding types will not be considered.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#namespaceexceptions","title":"NamespaceExceptions","text":"<p>You can input the name of any namespace here. An example of a namespace is <code>BH.oM.Structure.Elements</code>.</p> <p>Any object or property that belong to the corresponding namespace will not be considered.</p> <p>This option does not support wildcard.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#maxnesting","title":"MaxNesting","text":"<p>This option limits the depth of property discovery when computing Diffing or an object's Hash.</p> <p>Properties whose Nesting Level is equal to or larger than <code>MaxNesting</code> will not be considered.</p> <p>Top-level properties are at level 1. Setting <code>MaxNesting</code> to 1 will make the Hash or Diffing consider only top-level properties. Setting <code>MaxNesting</code> to 0 will disregard any object property (only the class name will end up in the Hash, and Diffing will not find any differences).</p> <p>This option is better used as a safety measure to avoid excessive computation time when diffing or computing the hash for objects that may occasionally have one or more deeply nested properties of which we do not care about.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#property-nesting-level-definition","title":"Property Nesting Level definition","text":"<p>The nesting level of a property defines how deep we are in the object property tree. For example:</p> <ul> <li>a <code>Bar</code>'s <code>StartNode</code> property is at Nesting Level 1 (it is also called a  \"top-level\" property of the object)</li> <li>a <code>Bar</code>'s <code>StartNode.Position</code> property is at Nesting Level 2, because <code>Position</code> is a sub-property of <code>StartNode</code>.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#maxpropertydifferences","title":"MaxPropertyDifferences","text":"<p>When Diffing, this indicates the maximum number of Property Differences that will be collected and returned. This setting does not affect the Hash calculation (in fact, this option should be moved in DiffingConfig instead). </p> <p>You can not control what properties are returned and what remain excluded due to this numeric limit. Hence, this option is better used as a safety measure to avoid excessive computation time when:</p> <ul> <li>we care about finding different objects, but do not care about what properties did change between them, although a better and faster option for this would be to use <code>DiffingConfig.EnablePropertyDiffing</code> set to <code>false</code>;</li> <li>we are okay with finding only the first n differences between objects, whatever those may be.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#numerictolerance","title":"NumericTolerance","text":"<p>This option sets the Numeric tolerance applied when considering any numerical property of objects. For example, a <code>Bar</code>'s <code>StartNode.Position.X</code> property is a numerical property.</p> <p>When a numerical property is encountered, the function <code>BH.Engine.Base.Round()</code> is applied to its value, which becomes approximated with the given <code>NumericTolerance</code>.</p> <p>Therefore, when Hashing, the property's approximate value will be recorded in the Hash. When Diffing, the property approximate value will be used for the comparison.</p> <p>If both <code>NumericTolerance</code> and <code>SignificantFigures</code> are provided in the ComparisonConfig, both approximations are executed, and the largest approximation among all (the least precise number) is registered.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#round-details","title":"<code>Round()</code> details","text":"<p>The function <code>BH.Engine.Base.Round()</code> will approximate the input value with the given tolerance, which is done by rounding to the nearest tolerance multiplier.</p> <p>Some examples of <code>Round()</code> are:</p> Input number Input Tolerance Result (approximated number) 12 20 20 121 2 122 1.2345 1.1 1.1 0.014 0.01 0.01 0.014 0.02 0.02"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#propertynumerictolerance","title":"PropertyNumericTolerance","text":"<p>This option applies a given Numeric Tolerance to a specific property, therefore considering its value approximated using the given tolerance.</p> <p>In order to use it, you have to create and input in <code>PropertyNumericTolerance</code> one or more <code>NamedNumericTolerance</code> objects, where you set:</p> <ul> <li>the <code>Name</code> of the property you want to target; this supports <code>*</code> wildcard usage;</li> <li>the <code>Tolerance</code> that you want to apply to the given property.</li> </ul> <p>The approximation will work exactly as per the <code>NumericTolerance</code> option, only it will target exclusively the properties with the name specified via the <code>NamedNumericTolerance</code> objects.</p> <p>If a match is found, this takes precedence over the <code>NumericTolerance</code> option. If conflicting values/multiple matches are found among the <code>ComparisonConfig</code>'s numerical precision options, the largest approximation among all (least precise number) is registered.</p> <p>The <code>Name</code> field supports wildcard usage. Some examples:</p> <ul> <li><code>BH.oM.Geometry.Vector</code>: applies the corresponding tolerance to all numerical properties of Vectors, i.e. X, Y, Z</li> <li><code>BH.oM.Structure.Elements.*.Position</code>: applies the corresponding tolerance to all numerical properties of properties named <code>Position</code> under any Structural Element, e.g. <code>Bar.Position.X</code>, <code>Bar.Position.Y</code>, <code>Bar.Position.Z</code> and at the same time also <code>Node.Position.X</code>, <code>Node.Position.Y,</code> <code>Node.Position.Z</code>.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#significantfigures","title":"SignificantFigures","text":"<p>This option sets the Significant Figures considered for any numerical property of objects. For example, a <code>Bar</code>'s <code>StartNode.Position.X</code> property is a numerical property.</p> <p>When a numerical property is encountered, the function <code>BH.Engine.Base.RoundToSignificantFigures()</code> is applied to its value, which becomes approximated with the given <code>SignificantFigures</code>.</p> <p>Therefore, when Hashing, the property's approximate value will be recorded in the Hash. When Diffing, the property approximate value will be used for the comparison.</p> <p>If both <code>SignificantFigures</code> and <code>NumericTolerance</code> are provided in the ComparisonConfig, both approximations are executed, and the largest approximation among all (the least precise number) is registered.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#roundtosignificantfigures-details","title":"<code>RoundToSignificantFigures()</code> details","text":"<p>The function <code>BH.Engine.Base.RoundToSignificantFigures()</code> will approximate the input value with the given Significant Figures. Some examples:</p> Input number Input Significant Figures Result (approximated number) 1050.67 1 1000 1050.67 2 1100 1050.67 3 1050 1050.67 4 1051 1050.67 5 1050.7 123456.123 7 123456.1 123456.123 1 100000 0.0000000000000000000123456789 5 1.2346E-20 0.0000000000000000000123456789 99 1.23456789E-20"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Configuring-objects-comparison-%28ComparisonConfig%29/#propertysignificantfigures","title":"PropertySignificantFigures","text":"<p>This option applies the approximation with given Significant Figures to a specific property.</p> <p>In order to use it, you have to create and input in <code>PropertyNumericTolerance</code> one or more <code>NamedSignificantFigures</code> objects, where you set:</p> <ul> <li>the <code>Name</code> of the property you want to target; this supports <code>*</code> wildcard usage;</li> <li>the <code>SignificantFigures</code> that you want to consider when evaluating the given property.</li> </ul> <p>The approximation will work exactly as per the <code>SignificantFigures</code> option, only it will target exclusively the properties with the name specified via the <code>NamedSignificantFigures</code> objects.</p> <p>If a match is found, this takes precedence over the <code>SignificantFigures</code> option. If conflicting values/multiple matches are found among the <code>ComparisonConfig</code>'s numerical precision options, the largest approximation among all (least precise number) is registered.</p> <p>The <code>Name</code> field supports wildcard usage. Some examples:</p> <ul> <li><code>BH.oM.Geometry.Vector</code>: applies the corresponding tolerance to all numerical properties of Vectors, i.e. X, Y, Z</li> <li><code>BH.oM.Structure.Elements.*.Position</code>: applies the corresponding tolerance to all numerical properties of properties named <code>Position</code> under any Structural Element, e.g. <code>Bar.Position.X</code>, <code>Bar.Position.Y</code>, <code>Bar.Position.Z</code> and at the same time also <code>Node.Position.X</code>, <code>Node.Position.Y,</code> <code>Node.Position.Z</code>.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/","title":"Diffing: tracking changes between objects","text":"<p>Diffing is the process of determining what changed between two sets of objects. </p> <p>Typically, the two sets of objects are two versions of the same thing (of a pulled Revit model, of a Structural Model that we want to Push to an Adapter, etc), in which case Diffing can effectively be used as a Version Control tool.</p> <p>\ud83e\udd16 Developers: check out also the Diffing and Hash: Guide for developers.</p> <p></p> <p>The Diffing_Engine gives many ways to perform diffing on sets of objects. Let's see them.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#idiffing-method","title":"IDiffing method","text":"<p>The most versatile method for diffing is the <code>BH.Engine.Diffing.Compute.Diffing()</code> method, also called <code>IDiffing</code>. Ideally, you should always use this Diffing method, although other alternatives exist for specific cases (see Other diffing methods below). A detailed technical explanation of the IDiffing can be found in the guide for developers.</p> <p>This method can be found in any UI by simply looking for <code>diffing</code>. See the below for an example file:</p> <p>Diffing main method</p> GrasshopperExcel <p>Example file (right click -&gt; download): DiffingExample-00-RevitDiffing.zip</p> <p> </p> <p>Example file (right click -&gt; download): DiffingInExcel.xlsx</p> <p></p> <p>The method takes three inputs:</p> <ul> <li><code>pastObject</code>: objects belonging to a past version, a version that precedes the <code>followingObjects</code>'s version.</li> <li><code>followingObjects</code>: objects belonging to a following version, a version that was created after the <code>pastObject</code>'s version.</li> <li><code>diffingConfig</code>: configurations for the diffing, where you can set your <code>ComparisonConfig</code> object, see below.</li> </ul> <p>The output of every diffing method is always a <code>diff</code> object, which we will describe in a section below.</p> <p>How diffing works: identifiers</p> <p>The IDiffing, like all diffing methods, relies on an identifier assigned to each object, which can be used to match objects, so it knows which to compare to which.</p> <p>The identifer is generally a unique \"signature\" assigned to each object, and this signature is assumed to remain always the same even if the object is modified. </p> <p>The identifier is typically stored on objects after they have been Pulled from an Adapter. This means that the IDiffing works best with objects pulled from a BHoM Adapter that stores the object Id on the object (most of them do).</p> <p>In case no Identifier can be found on the objects, the IDiffing attempts to use alternative methods e.g. compare one-by-one the objects; it will give you a note if this happens. </p> <p>(Technical sidenote: the identifier object is of a type called <code>IPersistentAdapterId</code>, searched in the object's Fragments. More on this in the diffing guide for developers.) </p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#the-diffing-output-the-diff-object","title":"The Diffing output: the <code>Diff</code> object","text":"<p>The output of any Diffing method is an object of type <code>Diff</code>. The <code>diff</code> output can be <code>Explode</code>d to reveal all the available outputs: </p> <p>the Diff object</p> GrasshopperExcel <p>Example file (right click -&gt; download): DiffingExample-00-RevitDiffing.zip</p> <p></p> <p>Example file (right click -&gt; download): DiffingInExcel.xlsx</p> <p></p> <ul> <li><code>AddedObjects</code>: objects present in the second set that are not present in the first set.</li> <li><code>RemovedObjects</code>: objects not present in the second set that were present in the first set.</li> <li><code>ModifiedObjects</code>: objects that are recognised as present both in the first set and the second set, but that have some property that is different. The rules that were used to recognise modification are in the <code>DiffingConfig.ComparisonConfig</code>.</li> <li><code>UnchangedObjects</code>: objects that are recognised as the same in the first and second set.</li> <li><code>ModifiedObjectsDifferences</code>: all the differences found between the two input sets of objects.</li> <li><code>DiffingConfig</code>: the specific instance of <code>DiffingConfig</code> that was used to calculate this <code>Diff</code>. Useful in scenarios where a <code>Diff</code> is stored and later inspected.</li> </ul> <p>The <code>ModifiedObjectDifferences</code> output contains a List of  <code>ObjectDifferences</code> objects, one for each modified object, that contains information about the modified objects. These can be further <code>Explode</code>d:</p> <p>The Diff object's properties</p> GrasshopperExcel <p>Example file (right click -&gt; download): DiffingExample-00-RevitDiffing.zip</p> <p></p> <p>Example file (right click -&gt; download): DiffingInExcel.xlsx</p> <p></p> <ul> <li><code>PastObject</code>: the object in the <code>pastObjs</code> set that was identified as modified (i.e., a different version of the same object was found in the <code>followingObjs</code> set).</li> <li><code>FollowingObject</code>: the object in the <code>followingObjs</code> set that was identified as modified (i.e., a different version of the same object was found in the <code>pastObjs</code> set).</li> <li><code>Differences</code>: all the differences found between the two versions of the modified object. This is a List of <code>PropertyDifference</code> objects, one for each difference found on the modified object.</li> </ul> <p>Finally, exploding the <code>Differences</code> object, we find:</p> <p>The Differences property</p> GrasshopperExcel <p>Example file (right click -&gt; download): DiffingExample-00-RevitDiffing.zip</p> <p></p> <p>Example file (right click -&gt; download): DiffingInExcel.xlsx</p> <p>(Sorry, missing a more accurate screenshot here -- just keep exploding as in the grasshopper example) </p> <ul> <li><code>DisplayName</code>: name given to the difference found. This is generally the PropertyName (name of the property that changed), but it can also indicate other things. For example, if a <code>ComparisonInclusion()</code> extension method is defined for some of the input objects (like it happens for Revit's <code>RevitParameter</code>s), then the <code>DisplayName</code> may also contain some specific naming useful to identify the difference (in the case of <code>RevitParameter</code>, this is the name of the RevitParameter that changed in the modified object). An example of a DisplayName could be <code>StartNode.Position.X</code> (given a modified object of type <code>BH.oM.Structure.Elements.Bar</code>).</li> <li><code>PastValue</code>: the modified value in the <code>PastObject</code>.</li> <li><code>FollowingValue</code>: the modified value in the <code>FollowingObject</code>.</li> <li><code>FullName</code>: this is the modified property Full Name. An object difference can always be linked to a precise object property that is different; this is given in the Full Name form, which includes the namespace. An example of this could be <code>BH.oM.Structure.Elements.Bar.StartNode.Position.X</code>. Note that this FullName can be significantly different from <code>DisplayName</code> (as happens for <code>RevitParameter</code>s, where the Full Name will be something like e.g. <code>BH.oM.Adapters.Revit.Parameters[3].RevitParameter.Value</code>).</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#options-for-the-diffing-diffingconfig-and-comparisonconfig","title":"Options for the diffing: <code>DiffingConfig</code> (and <code>ComparisonConfig</code>)","text":"<p>The <code>DiffingConfig</code> object can be attached to any Diffing method and allows you to specify options for the Diffing comparison. </p> <p> The Diffing config has the following inputs:</p> <ul> <li><code>ComparisonConfig</code> allows you to specify all the object comparison options; it has many settings, please see its dedicated page.</li> <li><code>EnablePropertyDiffing</code>: optional, defaults to <code>true</code>. If disabled, Diffing does not checks all the property-level differences, running much faster but potentially ignoring important changes.</li> <li><code>IncludedUnchangedObjects</code>: optional, defaults to <code>true</code>. When diffing large sets of objects, you may want to not include the objects that did not change in the diffing output, to save RAM.</li> <li><code>AllowDuplicateIds</code>: optional, defaults to <code>false</code>. The diffing generally uses identifiers to track \"who is who\" and decide which objects to compare; in such operations, duplicates should never be allowed, but there could be edge cases where it is useful to keep them.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#other-diffing-methods","title":"Other Diffing methods","text":"<p>In addition to the main Diffing method <code>IDiffing()</code>, there are several other methods that can be used to perform Diffing. These are a bit more advanced and should be used only for specific cases. The additional diffing methods can be found in the Compute folder of Diffing_Engine. </p> <p>Other than these, Toolkit-specific diffing methods exist to deal with the subtleties of comparing Objects defined in a Toolkit. Users do not generally need to know about these, as Toolkit-specific diffing methods will be automatically called for you if needed by the generic IDiffing method. Just for reference, a Toolkit-specific Diffing method is <code>RevitDiffing()</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#diffwithfragmentid-and-diffwithcustomdatakeyid","title":"<code>DiffWithFragmentId()</code> and <code>DiffWithCustomDataKeyId()</code>","text":"<p>These two methods are \"ID-based\" diffing methods. They simply retrieve an Identifier associated to the input objects, and use it to match objects from the <code>pastObjs</code> set to objects in the <code>followingObjs</code> set, deciding who should be compared to who.</p> <ul> <li>The <code>DiffWithFragmentId()</code> retrieves object identifiers from the objects' Fragments. You can specify which Fragment you want to get the ID from, and which property of the fragment is the ID. </li> <li>The <code>DiffWithCustomDataKeyId()</code> retrieves object identifiers from the objects' CustomData dictionary. You can specify which dictionary Key you want to get the ID from.</li> </ul> <p>Both method then call the <code>DiffWithCustomIds()</code> to perform the comparison with the extracted Ids, see below.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#diffwithcustomids","title":"<code>DiffWithCustomIds()</code>","text":"<p>The <code>DiffWithCustomIds()</code> method allows you to provide:</p> <ul> <li>Two input objects sets that you want to compare, <code>pastObjs</code> and <code>followingObjs</code>;</li> <li>Two input identifiers sets, <code>pastObjsIds</code> and <code>followingObjsIds</code>, with the Ids associated to the <code>pastObjs</code> and <code>followingObjs</code>.</li> </ul> <p>You can specify some <code>null</code> Ids in the <code>pastObjsIds</code> and <code>followingObjsIds</code>; however these two lists must have the same number of elements as <code>pastObjs</code> and <code>followingObjs</code>, respectively.</p> <p>The IDs are then used to match the objects from the <code>pastObjs</code> set to objects in the <code>followingObjs</code> set, to decide who should be compared to who:</p> <ul> <li>If an object in the <code>pastObjs</code> does not have a corresponding object in the <code>followingObjs</code> set, it means that it has been deleted in the following version, so it is identified as \"Removed\" (old).</li> <li>If an object in the <code>followingObjs</code> does not have a corresponding object in the <code>pastObjs</code> set, it means that it has been deleted in the past version, so it is identified as \"Added\" (new).</li> <li>If an object in the <code>pastObjs</code> matches by ID an object in the <code>followingObjs</code>, then it is identified as \"Modified\" (it changed between the two versions). This means that the two objects will be compared and all their differences will be found. This is done by invoking the <code>ObjectDifferences()</code> method, that is explained in detail here.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#diffonebyone","title":"DiffOneByOne()","text":"<p>The <code>DiffOneByOne()</code> method simply takes two input lists, <code>pastObjs</code> and <code>followingObjects</code>, and these have the objects in the same identical order. It then simply compares each object one-by-one. If matched objects are equal, they are \"Unchanged\", otherwise, they are \"Modified\" and their property difference is returned. </p> <p>For this reason, this method is not able to discover \"Added\" (new) or \"Removed\" (old) objects.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#diffwithhash","title":"DiffWithHash()","text":"<p>The <code>DiffWithHash()</code> method simply does a Venn Diagram of the input objects' Hashes:</p> <p></p> <p>The Venn Diagram is computed by means of a <code>HashComparer</code>, which simply means that the Hash of all input objects gets computed.  </p> <p>If objects with the same hash are found they are identified as \"Unchanged\"; otherwise, objects are either \"Added\" (new) or \"Removed\" (old) depending if their hash exists exclusively in following or past set. For this reason, this method is not able to discover \"Modified\" objects.</p> <p>The Hash is leveraged by this method so you are able to customise how the diffing behaves by specifying a <code>ComparisonConfig</code> options in the <code>DiffingConfig</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Diffing-%E2%80%93-tracking-changes-in-your-BHoM-objects/#diffrevisions","title":"DiffRevisions","text":"<p>This method was designed for the AECDeltas workflow and is currently not widely used. </p> <p>It essentially expects the input objects to be wrapped into a <code>Revision</code> object, which is useful to attach additional Versioning properties to them.  The Revisions can then be provided as an input to <code>DiffRevisions()</code>, and the logic works very similarly to the other diffing methods seen above.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Hash-%E2%80%93-an-object%27s-identity/","title":"Hash \u2013 an object's identity","text":""},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Hash-%E2%80%93-an-object%27s-identity/#hash-definition","title":"Hash definition","text":"<p>A Hash, sometimes called also hash code, is the \"unique signature\" or \"identity\" of an object.</p> <p>The hash is generally a string (a text) containing alphanumeric characters. It is composed by applying a Hash algorithm to an object, which parses the input object, all its properties, and the values assigned to those properties. The returned hash is a \"combination of all the variables\" present in the object. It follows that its most important feature is that the hash remains the same as long as the object remains the same (under certain criteria, which can be customised).</p> <p>The Hash for objects can be used in many different kinds of comparisons, or for any case where a unique identification of an object is needed. Examples include: - you can compute hash for objects to quickly and safely compare objects with each other, so you can determine unique objects (i.e., what objects are duplicates or not) - you can compare an object's hash at different points in time. You can store the hash of an object in a certain moment; then, some time later, you can check if the object changed (i.e., even a slight variation of one of its properties) by checking if its hash changed.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Hash-%E2%80%93-an-object%27s-identity/#bhoms-hash-method","title":"BHoM's <code>Hash()</code> method","text":"<p>BHoM exposes a <code>Hash()</code> method to calculate the Hash for any BHoM object (any object implementing the <code>IObject</code> interface).</p> <p>This method is defined in the base BHoM_Engine: <code>BH.Engine.Base.Query.Hash()</code>. Here is an example of how the method can be used in Grasshopper:</p> <p></p> <p>The method returns a <code>string</code>, a textual Hash code that uniquely represents the input object.</p> <p>This method's most parameters are: - the <code>IObject</code> you want to get the Hash for; - <code>comparisonConfig</code> configurations on how the Hash is calculated (see the dedicated section); - <code>hashFromFragment</code>: if instead of computing the Hash of the object, you want to retrieve a Hash that was previously stored in the object's Fragments.   In order to set the HashFragment on a BHoMObject's Fragment, you can use the <code>SetHashFrament()</code> method: </p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Hash-%E2%80%93-an-object%27s-identity/#hash-comparisonconfig-options-to-compute-the-hash","title":"Hash <code>ComparisonConfig</code>: options to compute the Hash","text":"<p>The real potential of the Hash algorithm is given by its customisation options, which we call ComparisonConfig (comparison configurations).</p> <p>For example, you may want to configure the Hash algorithm so it only considers numerical properties that changed within a certain tolerance. This way, you can determine if an object changed by looking at changes in the Hash, and you will be alerted only if the change was a numerical change greater than the given tolerance.</p> <p>For this reasons, we expose many configurations in a <code>ComparisonConfig</code> object:</p> <p></p> <p>See the page dedicated to <code>ComparisonConfig</code> for details on it.</p> <p>Note that some ComparisonConfig options may slow down the computation of the Hash, which becomes particularly noticeable when hashing large sets of objects. An option that may have particular negative impact when computing the Hash is <code>PropertiesToConsider</code>, as explained here.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Diffing%20and%20Hashing/Hash-%E2%80%93-an-object%27s-identity/#note-for-developers-customising-an-objects-hash","title":"Note for developers: customising an object's Hash","text":"<p>If you want a specific object to be Hashed in a particular way, you can implement a specific <code>HashString()</code> method for that object in your Toolkit.</p> <p>Here is an example for Revit's <code>RevitParameter</code> object. The <code>HashString()</code> method will get invoked when computing the Hash(). </p> <p>More info in the Diffing and Hash: guide for developers wiki page.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/","title":"Revit Toolkit intro","text":"<p>Welcome to the Revit Toolkit documentation! </p> <p>Here you will find information on what Revit_Toolkit can do for you as well as how to make that (and even more) happen. </p> <p>Feel free to explore and raise an issue if you need or do not like something. Enjoy!</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/#overview","title":"Overview","text":"<p>Revit_Toolkit is a set of tools that enable and support exchange of information between BHoM and Revit. The heart of the process is the Adapter that links Revit with BHoM. It allows for the following actions:</p> <ul> <li>Pull from Revit to BHoM</li> <li>Push from BHoM to Revit</li> <li>Remove Revit elements</li> </ul> <p>All Adapter actions can be taken from any of the BHoM-supported UIs: Grasshopper and Excel. Push and Pull include conversion from Revit and to Revit, which is being triggered on the fly. This conversion is an integral part of Push and Pull Adapter actions - besides simply translating Revit elements into BHoM objects, it ensures correctness of the units and, in general, allows representing Revit objects outside of Revit context.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/#more-info","title":"More info","text":"<p>Sections below explain the practicalities of that process, while its code mechanics is discussed in Coding-with-BHoM section.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/","title":"Revit Pull","text":"<p>Pulling elements from Revit to BHoM means extracting them from the Revit model combined with converting them to BHoM. In order to perform that action, the adapter needs to be set up correctly first. Once this is done, the user needs to specify two basic Pull inputs:</p> <ul> <li>Request (which Revit elements are meant to be pulled?) </li> <li>Action config (settings of this particular action - optional, if not specified, default values are used)</li> </ul> <p>Once the adapter and inputs are ready, the Pull action needs to be activated - in visual programming environment this is done by setting its <code>active</code> property to <code>true</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Action%20Config/","title":"Action config","text":"<p>Pull action config is represented by <code>RevitPullConfig</code> and allows to specify the following settings:</p> <ul> <li><code>Discipline</code> - discipline, in which the user works (Physical - default, Structural, Building Environments, Architecture, Facade) - this determines types of BHoM objects, to which the requested Revit elements are converted - more on that subject can be found in Revit BHoM conversion</li> <li><code>IncludeClosedWorksets</code> - if true, Revit elements from closed worksets will be pulled (default is <code>false</code>)</li> <li><code>IncludeNestedElements</code> - if true, Revit family instances will be pulled together with their subelements (default is <code>true</code>)</li> <li><code>GeometryConfig</code> - settings defining the geometrical representation (the actual geometrical object representing the element in Revit) to be pulled (by default nothing) - more information available in Pull of Geometry and Representation</li> <li><code>RepresentationConfig</code> - settings defining the mesh representation to be pulled (by default nothing) - more information available in Pull of Geometry and Representation</li> <li><code>PullMaterialTakeOff</code> - if true, <code>RevitMaterialTakeOff</code> fragment will be added to the pulled BHoM object, which can then be converted into an <code>ExplicitBulk</code> using <code>MaterialTakeoff</code> query</li> </ul> <p>If <code>RevitPullConfig</code> is left empty, default values will be used.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Conversion%20from%20Revit/","title":"Conversion from Revit","text":"<p>Due to multidisciplinarity of both BHoM and Revit, conversion from Revit is not always a singular problem: some elements can be converted into multiple BHoM types, depending on user's discipline preference set in <code>RevitPullConfig</code>. Table below contains a matrix of possible converts organized by discipline.</p> Revit Category Revit Type BHoM Physical BHoM Structural BHoM Envinronments BHoM Architecture BHoM Facade Grids <code>Autodesk.Revit.DB.Grid</code> <code>BH.oM.Geometry.SettingOut.Grid</code> <code>BH.oM.Geometry.SettingOut.Grid</code> <code>BH.oM.Geometry.SettingOut.Grid</code> <code>BH.oM.Geometry.SettingOut.Grid</code> <code>BH.oM.Geometry.SettingOut.Grid</code> Levels <code>Autodesk.Revit.DB.Level</code> <code>BH.oM.Geometry.SettingOut.Level</code> <code>BH.oM.Geometry.SettingOut.Level</code> <code>BH.oM.Geometry.SettingOut.Level</code> <code>BH.oM.Geometry.SettingOut.Level</code> <code>BH.oM.Geometry.SettingOut.Level</code> Walls <code>Autodesk.Revit.DB.Wall</code> <code>BH.oM.Physical.Elements.Wall</code> <code>BH.oM.Structure.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Physical.Elements.Wall</code> <code>BH.oM.Facade.Elements.CurtainWall</code> Floors / Foundation Slabs <code>Autodesk.Revit.DB.Floor</code> <code>BH.oM.Physical.Elements.Floor</code> <code>BH.oM.Structure.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Physical.Elements.Floor</code> <code>BH.oM.Physical.Elements.Floor</code> Roofs <code>Autodesk.Revit.DB.RoofBase</code> <code>BH.oM.Physical.Elements.Roof</code> <code>BH.oM.Structure.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Physical.Elements.Roof</code> <code>BH.oM.Physical.Elements.Roof</code> Structural Columns <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Physical.Elements.Column</code> <code>List&lt;BH.oM.Structure.Elements.Bar&gt;</code> <code>BH.oM.Physical.Elements.Column</code> Structural Framing <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Physical.Elements.Beam</code> / <code>BH.oM.Physical.Elements.Bracing</code> <code>List&lt;BH.oM.Structure.Elements.Bar&gt;</code> <code>BH.oM.Physical.Elements.Beam</code> / <code>BH.oM.Physical.Elements.Bracing</code> Windows <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Physical.Elements.Window</code> <code>BH.oM.Physical.Elements.Window</code> <code>BH.oM.Physical.Elements.Window</code> <code>BH.oM.Facade.Elements.Opening</code> Doors <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Physical.Elements.Door</code> <code>BH.oM.Physical.Elements.Door</code> <code>BH.oM.Physical.Elements.Door</code> <code>BH.oM.Facade.Elements.Opening</code> Curtain Panels <code>Autodesk.Revit.DB.Panel</code> <code>BH.oM.Physical.Elements.Window</code> <code>BH.oM.Physical.Elements.Window</code> <code>BH.oM.Physical.Elements.Window</code> <code>BH.oM.Facade.Elements.Opening</code> Ceilings <code>Autodesk.Revit.DB.Ceiling</code> <code>BH.oM.Architecture.Elements.Ceiling</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Architecture.Elements.Ceiling</code> <code>BH.oM.Architecture.Elements.Ceiling</code> Spaces / Rooms <code>Autodesk.Revit.DB.SpatialElement</code> <code>BHoM.Architecture.Elements.Room</code> <code>BH.oM.Environment.Elements.Space</code> <code>BHoM.Architecture.Elements.Room</code> <code>BHoM.Architecture.Elements.Room</code> Project Information <code>Autodesk.Revit.DB.ProjectInfo</code> <code>BH.oM.Environment.Elements.Building</code> Analytical Surfaces <code>Autodesk.Revit.DB.Analysis.EnergyAnalysisSpace</code> <code>BH.oM.Environment.Elements.Space</code> <code>BH.oM.Environment.Elements.Space</code> <code>BH.oM.Environment.Elements.Space</code> <code>BH.oM.Environment.Elements.Space</code> Interior, Exterior, Shades <code>Autodesk.Revit.DB.Analysis.EnergyAnalysisSurface</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> Opening <code>Autodesk.Revit.DB.Analysis.EnergyAnalysisOpening</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> <code>BH.oM.Environment.Elements.Panel</code> Families <code>Autodesk.Revit.DB.Family</code> <code>BH.oM.Adapters.Revit.Elements.Family</code> <code>BH.oM.Adapters.Revit.Elements.Family</code> <code>BH.oM.Adapters.Revit.Elements.Family</code> <code>BH.oM.Adapters.Revit.Elements.Family</code> <code>BH.oM.Adapters.Revit.Elements.Family</code> Materials <code>Autodesk.Revit.DB.Material</code> <code>BH.oM.Physical.Materials.Material</code> <code>BH.oM.Structure.MaterialFragments.IMaterialFragment</code> <code>BH.oM.Environment.MaterialFragments.SolidMaterial</code> <code>BH.oM.Physical.Materials.Material</code> <code>BH.oM.Physical.Materials.Material</code> Sheets <code>Autodesk.Revit.DB.Sheet</code> <code>BH.oM.Adapters.Revit.Elements.ViewSheet</code> <code>BH.oM.Adapters.Revit.Elements.ViewSheet</code> <code>BH.oM.Adapters.Revit.Elements.ViewSheet</code> <code>BH.oM.Adapters.Revit.Elements.ViewSheet</code> <code>BH.oM.Adapters.Revit.Elements.ViewSheet</code> Viewports <code>Autodesk.Revit.DB.Viewport</code> <code>BH.oM.Adapters.Revit.Elements.Viewport</code> <code>BH.oM.Adapters.Revit.Elements.Viewport</code> <code>BH.oM.Adapters.Revit.Elements.Viewport</code> <code>BH.oM.Adapters.Revit.Elements.Viewport</code> <code>BH.oM.Adapters.Revit.Elements.Viewport</code> Views (Plan) <code>Autodesk.Revit.DB.ViewPlan</code> <code>BH.oM.Adapters.Revit.Elements.ViewPlan</code> <code>BH.oM.Adapters.Revit.Elements.ViewPlan</code> <code>BH.oM.Adapters.Revit.Elements.ViewPlan</code> <code>BH.oM.Adapters.Revit.Elements.ViewPlan</code> <code>BH.oM.Adapters.Revit.Elements.ViewPlan</code> Ducts <code>Autodesk.Revit.DB.Mechanical.Duct</code> <code>BH.oM.MEP.System.Duct</code> <code>BH.oM.MEP.System.Duct</code> <code>BH.oM.MEP.System.Duct</code> Pipes <code>Autodesk.Revit.DB.Plumbing.Pipe</code> <code>BH.oM.MEP.System.Pipe</code> <code>BH.oM.MEP.System.Pipe</code> <code>BH.oM.MEP.System.Pipe</code> Wires <code>Autodesk.Revit.DB.Electrical.Wire</code> <code>BH.oM.MEP.System.Wire</code> <code>BH.oM.MEP.System.Wire</code> <code>BH.oM.MEP.System.Wire</code> Cable Trays <code>Autodesk.Revit.DB.Electrical.CableTray</code> <code>BH.oM.MEP.System.CableTray</code> <code>BH.oM.MEP.System.CableTray</code> <code>BH.oM.MEP.System.CableTray</code> Fittings <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.MEP.System.Fittings.Fitting</code> <code>BH.oM.MEP.System.Fittings.Fitting</code> <code>BH.oM.MEP.System.Fittings.Fitting</code> Builders Work Openings <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Architecture.BuildersWork.Opening</code> <code>BH.oM.Architecture.BuildersWork.Opening</code> Mullions <code>Autodesk.Revit.DB.Mullion</code> <code>BH.oM.Facade.Elements.FrameEdge</code> <p>In case of conversion to structural BHoM types, Revit element is first queried for its analytical model, and its physical representation is used only if the former does not exist.</p> <p>If a Revit element is requested to be pulled and there is no explicit convert method for its type and given discipline, it will get converted into a <code>ModelInstance</code>, <code>DraftingInstance</code> or <code>InstanceProperties</code>, which are generic BHoM wrappers for Revit elements. If that fails too, a <code>BHoMObject</code> with only basic information is returned. The conversion procedure is shown in the flowchart below.</p> <p></p> <p>Every time a Revit element is converted, its element type is converted along it. The information about the latter can be stored in 2 ways:</p> <ul> <li>in defining BHoM property, e.g. <code>Construction</code> of <code>Wall</code> - the characteristics of the element type as well as its parameters are converted and attached to this property (<code>Wall.Construction</code> contains the information about the Revit wall type and its parameters)</li> <li>in <code>RevitTypeFragment</code> attached to the BHoM object representing the element (in case the BHoM object does not have a defining property that could correspond to the Revit element type, e.g. <code>Architecture.Room</code>) - only parameters of the element type are converted and stored in the fragment to allow querying and updating them</li> </ul> <p>To find out where is the Revit element type information stored inside a particular BHoM object, it is recommended to call <code>GetRevitElementType</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Family%20and%20Type%20Mapping/","title":"Explicit mapping of Revit families to BHoM types on Pull","text":"<p>In some cases, on Pull, the elements of one Revit API type and belonging to one Revit category are meant to be converted into a few different BHoM types. An example of this may be <code>FamilyInstance</code> belonging to Mechanical Equipment category - this potentially could be converted to multiple BHoM types, such as <code>Exhaust</code>, <code>Fan</code> etc. This would not be possible out of the box, but can be achieved using family maps in <code>MappingSettings</code>.</p> <p>The picture below shows an example of <code>MappingSettings</code> structured in a way that will map elements from families BHE_GenericModels_OpeningRectangular_Wall and BHE_GenericModels_OpeningRectangular_Floor to <code>BH.oM.Architecture.BuildersWork.Opening</code>, plus it will map the BHE_Height parameter to <code>Height</code> property of the output BHoM object as well as BHE_Width to <code>Width</code>.</p> <p>Mapping has been also covered in the Pull examples.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Handling%20of%20Parameters/","title":"Handling of parameters on Pull","text":"<p>On Pull, the parameters of a Revit element get wrapped into <code>RevitParameter</code> objects, which are collected in <code>RevitPulledParameters</code> fragment attached to the BHoM object representing the element. Such parameters can be queried in two ways:</p> <ul> <li>all in one go using <code>GetRevitParameters</code> method</li> <li>value of a particular one using <code>GetRevitParameterValue</code> method</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Handling%20of%20Parameters/#parameter-mapping","title":"Parameter mapping","text":"<p>It may sometimes happen that different families have the same value stored under different parameter names. In such case, there is a need to map the values from more than one source into a single set. This can be done with the use of custom mapping settings that are part of Revit adapter settings.</p> <p>Note: The concept of parameter mapping is easy to use, but complex to explain. Therefore, it is recommended to first look at the examples here and here in order to understand the practicalities of it. More details can be found here.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Material%20Takeoffs/","title":"Pull of material takeoffs","text":"<p>It is possible to pull a material take-off of any Revit element on <code>Pull</code>. It can be achieved by using <code>RevitPullConfig</code> with <code>PullMaterialTakeOff</code> property set to <code>true</code>. Once that is done, <code>RevitMaterialTakeOff</code> fragment will be added to each pulled BHoM object, which can then be converted into an <code>ExplicitBulk</code> using <code>MaterialTakeoff</code> query.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/","title":"Revit Pull examples","text":"<p>Note</p> <ul> <li>It's worth having a look at Using the BHoM section and the rest of Revit_Toolkit Wiki before reading this page.</li> <li>Most of the scripts are presented in Grasshopper. All source files are available in samples.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#pulling-selection","title":"Pulling selection","text":"<p>One of the more practical ways to specify elements for pull is simply selecting them in Revit and using <code>FilterBySelection</code>.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#inspecting-parameters","title":"Inspecting parameters","text":"<p>As explained in Handling of parameters section, each BHoM object representing a pulled Revit element has a fragment containing information about all parameters of the latter. These can be queried either as a batch or only value of a chosen one can be extracted. The example below shows both options excercised on a pulled wall.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#advanced-filters","title":"Advanced filters","text":"<p>It is possible to combine multiple filters with each other to create very specified queries. The example below shows how to pull all elements that can be converted to either structural bars or structural panels, which also have a parameter Enable Analytical Model (checkbox type) equal to <code>true</code>.</p> <p></p> <p>Sometimes pull needs to be done in more than one step. Below it is shown how to first pull the active view and then use it to pull all detail items that belong to it. As can be seen, FilterByViewSpecific takes BHoMObject as an argument - it knows that this object represents a given Revit view thanks to relationship explained in BHoM vs Revit identity section.</p> <p></p> <p>Another example of two step pull is pulling family type: first the family itself is pulled, then it is queried for all its types. Worth noting is the fact that error in Grasshopper component is caused by the empty input - once the pull is executed successfully, it will turn standard gray.</p> <p></p> <p>It is important to distinguish pulling types (above) from pulling elements of a given type. Example below shows the latter (pulling actual HEA 300 beams, instead of HEA 300 family type).</p> <p></p> <p>The next example shows how to pull plan views, which name starts with Structural prefix. Such view can be then manipulated (with Push) or used for further queries.</p> <p></p> <p>For those familiar with Revit API, it is possible to filter the elements by their API type. It is worth noticing that this method works only for types that inherit from <code>Autodesk.Revit.DB.Element</code>.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#disciplines","title":"Disciplines","text":"<p>As mentioned in Conversion from Revit section, depending on the discipline set in Action config, Revit elements can be converted to different BHoM objects. A vivid example of that is shown in the script below. Revit walls are being converted to: - <code>BH.oM.Physical.Elements.Wall</code> for Physical discipline - <code>BH.oM.Structure.Elements.Panel</code> for Structural discipline - <code>BH.oM.Environment.Elements.Panel</code> for Environmental discipline</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#pulling-energy-analysis-model","title":"Pulling energy analysis model","text":"<p>Energy analysis is a specific discipline that requires information about meta information (e.g. topology or building location) that is often not needed for other disciplines. Therefore <code>EnergyAnalysisModelRequest</code> in order to ease the process of pulling comprehensive data from Revit energy analysis model.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#pulling-edges","title":"Pulling edges","text":"<p>A hidden feature of action config: pulling any elements together with their geometry as shown in Revit! In case below, of framing elements. As explained in Pull of Geometry and Representation section, the edges are stored in BHoM object's <code>CustomData</code> under Revit_edges key - easiest way to retrieve it is to use <code>GetProperty</code> component (only in Grasshopper), alternatively the object and its <code>CustomData</code> can be decomposed with <code>Explode</code>.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#pulling-representations","title":"Pulling representations","text":"<p>Is it also possible to pull the mesh representation of a Revit element - this can be achieved by setting <code>RepresentationConfig</code> of the <code>RevitPullConfig</code> as explained in Pull of Geometry and Representation section.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20Examples/#mapping-parameters-on-pull","title":"Mapping parameters on Pull","text":"<p>As explained in Parameter mapping section, values stored in parameters of a Revit element or its type under different names can be mapped into a single parameter wrapper in BHoM. The script below pulls all columns from the model and copies over from their type parameter values named b or Height to a single BHoM parameter named ProfileHeight. What is more, it overwrites BHoM objects' names with Column Location Mark parameter values.</p> <p>Note: The script is meant to be run with the Revit sample named rst_basic_sample_project.rvt available in Revit samples folder. </p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20from%20Links/","title":"Pull from links","text":"<p>It is possible to pull elements directly from Revit link documents, in the coordinate system of the host model. This can be achieved using <code>FilterByLink</code> request combined with other filters using the <code>LogicalAndRequest</code>. For example, the script below would pull all beams from the link named MyLinkDocument.</p> <p></p> <p>Please note that pulling from link has a few limitations caused by the way in which Revit works:</p> <ul> <li>it is impossible to pull selection from link</li> <li>it is impossible to filter link elements by visibility in view</li> <li>pull of walls/floors/roofs as well as doors/windows uses different method of extracting their geometry, which may lead to slight degradation of the output</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20in%20Excel/","title":"Revit Pull in Excel","text":"<p>Under construction.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20in%20Grasshopper/","title":"Revit Pull in Grasshopper","text":"<p>Note: Before reading this page, it is recommended to have a look at Using the BHoM section.</p> <p>Important: on the first run it may happen that pull will fail with connection error \u2013 simply refreshing <code>active</code> to <code>true</code> should help in that case.</p> <p>Having the Revit adapter set up, one can start interacting with Revit. <code>Pull</code> behaves like a standard Grasshopper component, so can be placed on canvas with a standard double left click action. Request, on the other hand, is a solely BHoM type, therefore it is easiest to invoke it with Ctrl+Shift+B menu, with an alternative of using either <code>CreateRequest</code> or <code>CreateObject</code> component.</p> <p>The example below shows a simple exercise of pulling all Revit elements that can be converted into BHoM <code>IFramingElements</code> (which capture both columns and framing). There is a few details that might be worth noticing:</p> <ul> <li><code>FilterByBHoMType</code> expects a type and not an instance. In Revit language, the user is expected to provide a element type and not the element itself. Therefore, <code>CreateType</code> component is being used.</li> <li><code>Explode</code> is a general use component that allows to quickly see all properties of any BHoM object. It is very useful and can be applied almost anywhere.</li> <li>Pull will not run as long as it is not activated (<code>active == true</code>).</li> <li>The pull component is turning orange indicating that it threw a warning. That is often acceptable, although should never be left unnoticed.</li> </ul> <p></p> <p>More examples is available in Pull examples page.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Pull%20of%20Geometry%20and%20Representation/","title":"Pull of geometry and object representations","text":"<p>By default, Revit elements are pulled and converted to the BHoM objects as explained in Revit BHoM conversion. However, on top of that, it is possible to extract additional information about the actual geometry of an element in Revit, as well as its representation including colours. Instruction about that extra information to pull is passed to the adapter via <code>GeometryConfig</code> and <code>RepresentationConfig</code> properties of <code>RevitPullConfig</code>.</p> <p><code>PullGeometryConfig</code> object allows to set following geometry-related instructions:</p> <ul> <li><code>PullEdges</code> - if true, edges of elements will be pulled and stored in <code>RevitRepresentation</code> fragment, queryable using <code>RevitEdges</code> method</li> <li><code>PullSurfaces</code> - if true, surfaces of elements will be pulled and stored in <code>RevitRepresentation</code> fragment, queryable using <code>RevitSurfaces</code> method</li> <li><code>PullMeshes</code> - if true, meshed surfaces of elements will be pulled and stored in <code>RevitRepresentation</code> fragment, queryable using <code>RevitMeshes</code> method</li> <li><code>MeshDetailLevel</code> - detail level of mesh to be pulled, correspondent to level of detail in Revit</li> <li><code>IncludeNonVisible</code> - invisible element parts will be pulled and passed to <code>RevitRepresentation</code> fragment if true</li> </ul> <p><code>PullRepresentationConfig</code> specifies render mesh settings:</p> <ul> <li><code>PullRenderMesh</code> - if true, mesh representation of elements will be pulled and stored in <code>RevitRepresentation</code> fragment, queryable using <code>RenderMeshes</code> method</li> <li><code>DetailLevel</code> - detail level of representation, correspondent to level of detail in Revit</li> <li><code>IncludeNonVisible</code> - invisible element parts will be pulled and passed to <code>RevitRepresentation</code> fragment if true</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Requests%20and%20Filtering/","title":"Requests and data filtering","text":"<p>Requests are used to filter the elements in Revit document that are meant to be processed (e.g. pulled or removed). Currently there is over 20 requests available in Revit_Toolkit that could be divided into three categories presented below. Practical implementation of the requests is discussed in Pull examples.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Requests%20and%20Filtering/#filtering-all-revit-elements-by-properties","title":"Filtering all Revit elements by properties","text":"<p>First category that could be distinguished, are Requests that force parsing all elements in the model looking for certain feature, e.g. workset or parameter value. Name of such requests start with a prefix FilterBy.</p> Request Description <code>FilterByBHoMType</code> Filters Revit elements based on their correspondent BHoM Type. Wrapper for <code>BH.oM.Data.Requests.FilterRequest</code>. <code>FilterBySelection</code> Filters elements selected in Revit. Wrapper for <code>BH.oM.Data.Requests.SelectionRequest</code>. <code>FilterByActiveWorkset</code> Filters all elements in active Revit workset. <code>FilterByCategory</code> Filters all elements of a Revit category. <code>FilterByDBTypeName</code> Filters all elements of given Autodesk.Revit.DB type. Information about types can be found in the Revit API documentation. <code>FilterByElementIds</code> Filters elements by their ElementIds. <code>FilterByFamilyType</code> Filters all elements of given Revit family type. <code>FilterByFamilyAndTypeName</code> Filters all elements of given Revit family and type, with option to loose the search by leaving one of the input names blank. <code>FilterByParameterBool</code> Filters elements based on given Boolean parameter value criterion. <code>FilterByParameterElementId</code> Filters elements based on given ElementId parameter value criterion.\" <code>FilterByParameterExistence</code> Filters elements the have (or do not have) a parameter with given name. <code>FilterByParameterInteger</code> Filters elements based on given integer parameter value criterion. <code>FilterByParameterNumber</code> Filters elements based on given floating point number parameter value criterion. <code>FilterByParameterText</code> Filters elements based on given text parameter value criterion. <code>FilterByScopeBox</code> Filters elements located at least partially inside a given Revit Scope Box. <code>FilterBySelectionSet</code> Filters elements contained in a given Revit Selection Set. <code>FilterByUniqueIds</code> Filters elements by their UniqueIds. <code>FilterByUsage</code> Filters used/unused elements in a Revit document. <code>FilterByViewSpecific</code> Filters elements specific to (owned by) a given view in Revit. <code>FilterByVisibleInView</code> Filters all elements visible in a given Revit view. <code>FilterByWorkset</code> Filters all elements in a given Revit workset."},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Requests%20and%20Filtering/#filtering-revit-elements-of-given-feature","title":"Filtering Revit elements of given feature","text":"<p>Another specific group of Requests are the ones parsing only elements that have a given feature, e.g. are families or model elements. Names of such requests start with a prefix Filter[FeatureName].</p> Request Description <code>FilterActiveView</code> Filters the active view in Revit. <code>FilterFamilyByName</code> Filters Revit families by name. If the family name is left blank, all families will be filtered. <code>FilterFamilyTypeByName</code> Filters Revit family types by names of theirs and their parent family, with option to loose the search by leaving one or both of the input names blank. <code>FilterMemberElements</code> Filters elements being members of selection sets, assemblies, systems etc. <code>FilterModelElements</code> Filters elements that have geometrical representation in the Revit model. <code>FilterTypesOfFamily</code> Filters Revit family types that belong to a given Revit family. <code>FilterViewByName</code> Filters Revit views by name. If the view name is left blank, all families will be filtered. <code>FilterViewsByTemplate</code> Filters all Revit views that implement a given view template. <code>FilterViewsByType</code> Filters all views of given type. <code>FilterViewTemplateByName</code> Filters Revit view templates by name. If the template name is left blank, all view templates will be filtered."},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Pull/Requests%20and%20Filtering/#special-requests","title":"Special Requests","text":"<p>Last group of Requests are the special ones that do not fall into neither of the above categories.</p> Request Description <code>EnergyAnalysisModelRequest</code> Filters all elements that are contained in Revit's energy analysis model. <code>FilterEverything</code> Filters all elements in the model. This means a lot of data - please use carefully! <code>LogicalOrRequest</code> Logical structure that allows joining multiple requests using OR statement. <code>LogicalAndRequest</code> Logical structure that allows joining multiple requests using AND statement. <code>LogicalNotRequest</code> Logical structure that inverts the query specified by the input request, i.e. any object that fits this request will be excluded from a pull."},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/","title":"Revit Push","text":"<p>Pushing from BHoM to Revit can be simply explained as creation of Revit elements based on BHoM objects. In order to perform that action, the adapter needs to be set up correctly first. Once this is done, the user needs to specify the first 2 of these 3 inputs:</p> <ol> <li>Objects: the objects you want to push to Revit from BHoM.</li> <li>Push type: decides whether the existing Revit elements should be replaced by the new ones, or just updated, or never replaced, etc.</li> <li>Action config (optional) settings of this particular Action.</li> </ol> <p>Besides that, a tag can be added to all newly created elements. Once the adapter and inputs are ready, the Push action needs to be activated - in visual programming environment this is done by setting its <code>active</code> property to <code>true</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Action%20Config/","title":"Action config","text":"<p>Push action config is represented by <code>RevitPushConfig</code> and allows to specify the following settings:</p> <ul> <li><code>SuppressFailureMessages</code> - if true, Revit warnings are suppressed in order not to interrupt the element creation procedure (default is <code>false</code>)</li> <li><code>IncludeClosedWorksets</code> - if true, Revit elements from closed worksets will be processed (default is <code>false</code>)</li> <li><code>SetLocationOnUpdate</code> - if true, only parameters of the updated Revit element will be processed, without overwriting its location based on the BHoM object (for more see Pushing Revit elements with parameters section).</li> </ul> <p>If <code>RevitPushConfig</code> is left empty, default values will be used.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Conversion%20to%20Revit/","title":"Conversion to Revit","text":"<p>Revit Toolkit support conversion of many BHoM object types to Revit: they are listed in the table below together with their relevant Revit types. As a general rule, analytical objects (of types that belong to namespaces <code>BH.oM.Structure</code> or <code>BH.oM.Environment</code>) are not allowed to be pushed to Revit - their physical equivalents (objects of types from <code>BH.oM.Physical</code> namespace) should be used instead. So far, the only exception from that rule is <code>BH.oM.Environment.Elements.Space</code>.</p> BHoM Type Revit Category Revit Type <code>BH.oM.Geometry.SettingOut.Grid</code> Grids <code>Autodesk.Revit.DB.Grid</code> <code>BH.oM.Geometry.SettingOut.Level</code> Levels <code>Autodesk.Revit.DB.Level</code> <code>BH.oM.Physical.Elements.Wall</code> Walls <code>Autodesk.Revit.DB.Wall</code> <code>BH.oM.Physical.Elements.Floor</code> Floors / Structural Foundations <code>Autodesk.Revit.DB.Floor</code> <code>BH.oM.Physical.Elements.Roof</code> Roofs <code>Autodesk.Revit.DB.RoofBase</code> <code>BH.oM.Physical.Elements.Column</code> Structural Columns <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Physical.Elements.Beam</code> Structural Framing <code>Autodesk.Revit.DB.FamilyInstance</code> <code>BH.oM.Physical.Reinforcement.IReinforcingBar</code> Structural Rebar <code>Autodesk.Revit.DB.Structure.Rebar</code> <code>BH.oM.Environment.Elements.Space</code> Spaces <code>Autodesk.Revit.DB.Mechanical.Space</code> <code>BH.oM.Adapters.Revit.Elements.ViewPlan</code> Views (Plan) <code>Autodesk.Revit.DB.ViewPlan</code> <code>BH.oM.Adapters.Revit.Elements.Viewport</code> Viewports <code>Autodesk.Revit.DB.Viewport</code> <code>BH.oM.Adapters.Revit.Elements.ViewSheet</code> Sheets <code>Autodesk.Revit.DB.Sheet</code> <code>BH.oM.MEP.System.Duct</code> Ducts <code>Autodesk.Revit.DB.Mechanical.Duct</code> <code>BH.oM.MEP.System.Pipe</code> Pipes <code>Autodesk.Revit.DB.Plumbing.Pipe</code> <code>BH.oM.MEP.System.CableTray</code> Cable Trays <code>Autodesk.Revit.DB.Electrical.CableTray</code> <code>BH.oM.Adapters.Revit.Parameters.ParameterDefinition</code> - <code>Autodesk.Revit.DB.ParameterElement</code> <code>BH.oM.Adapters.Revit.Elements.Family</code> - <code>Autodesk.Revit.DB.Family</code> <code>BH.oM.Adapters.Revit.Elements.InstanceProperties</code> - <code>Autodesk.Revit.DB.ElementType</code> <p>Conversion of BHoM object properties such as <code>Construction</code> or <code>FramingProperties</code> to Revit is currently not supported - Revit element type is applied based on name matching with defining property of a BHoM object (e.g. <code>Construction</code> of a wall or <code>Property</code> of a beam). Therefore, to create a Revit element of given family type, one needs to set BHoM object's property name to same value. Example of Push using this approach is available in examples.</p> <p>On top of the above list, there are three powerful generic types in Revit_Adapter that can wrap any Revit element. These are:</p> <ul> <li><code>ModelInstance</code> - any Revit view independent element that has <code>Location</code> property</li> <li><code>DraftingInstance</code> - any Revit view dependent element that has <code>Location</code> property</li> <li><code>InstanceProperties</code> - any Revit <code>ElementType</code> or <code>GraphicsStyle</code></li> </ul> <p>The above types can be used on Push to create Revit elements that do not have a correspondent BHoM type, e.g. mechanical equipment, generic annotations or filled regions - examples of these can be found in examples.</p> <p>It is worth noting that pushing BHoM geometries directly to Revit is not allowed - they always need to be wrapped into some type of object (if are meant to be pushed as primitives, <code>ModelInstance</code> or <code>DraftingInstance</code> is recommended. Similarly, on pull, each geometrical Revit element will be wrapped into a non-primitive BHoM type.</p> <p>A limited ability to create Revit types is provided by <code>BH.oM.Adapters.Revit.ClonedType</code> object - pushing it creates a clone of an existing Revit element type with a new name, which then can be updated freely.</p> <p>The last two rows of the table, <code>Family</code> and <code>InstanceProperties</code>, correspond to an action of loading the families or chosen types to the model - this works only in combination with FamilyLibrary.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Family%20Library/","title":"Revit family library","text":"<p><code>FamilyLibrary</code> is a settings object allowing for loading missing Families and Family Types to the project. It can be attached to <code>RevitAdapter</code> by setting <code>RevitSettings.FamilyLoadSettings.FamilyLibrary</code> property. On <code>Push</code>, if a requested Family or Family or Family Type is not loaded to the project, the adapter will parse the specified library in search for it. Once found, it will be loaded on the fly.</p> <p>Following order will be considered when seeking requested Family or Family Type:</p> <ol> <li>Families already loaded into the project</li> <li>Families found in <code>FamilyLibrary</code> provided</li> </ol> <p>The script below shows how to supply families from C:\\Desktop\\MyLibrary folders to the adapter, so that it could load them automatically.</p> <p></p> <p><code>FamilyLibrary</code> also helps querying the .rfa files present in the folder. Once created, it contains a collection of <code>RevitFilePreview</code> objects that contain basic information about the family contained in each file: category, family name, names of family types etc. All this information can be easily extracted by using a sequence of <code>Explode</code> components.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Handling%20of%20Parameters/","title":"Handling of parameters on Push","text":""},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Handling%20of%20Parameters/#setting-parameters-on-push","title":"Setting Parameters on Push","text":"<p>Out of the box, default parameter values will be assigned when creating a Revit element based on a BHoM object. This can be overwritten by setting the parameters to push with <code>SetRevitParameter</code> method. Similarly, when an existing element is updated on Push, only the parameters explicitly instructed to be overwritten (<code>SetRevitParameter</code> method) will change.</p> <p>By default, when a Revit element gets updated, first its parameters are overwritten and then the location is updated. This means that if the user sets values to location-related parameters, the change may not take place due to being superseded by location update. To avoid that, it is possible to prevent the element's location from being updated by switching <code>SetLocationOnUpdate</code> property of <code>RevitPushConfig</code> to <code>false</code>.</p> <p>Basic examples are available here.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Handling%20of%20Parameters/#pushing-new-parameter-definitions","title":"Pushing new Parameter definitions","text":"<p>It is possible to create new Revit parameters (project or shared ones) by pushing a <code>BH.oM.Adapters.Revit.Parameters.ParameterDefinition</code> object.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Handling%20of%20Parameters/#parameter-mapping","title":"Parameter mapping","text":"<p>It may sometimes happen that different families have the same value stored under different parameter names. In such case, there is a need to map the values from more than one source into a single set. This can be done with the use of custom mapping settings that are part of Revit adapter settings.</p> <p>Note: The concept of parameter mapping is easy to use, but complex to explain. Therefore, it is recommended to first look at the examples here and here in order to understand the practicalities of it. More details can be found here.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/","title":"Revit Push examples","text":"<p>Note</p> <ul> <li>It's worth having a look at Using the BHoM section and the rest of Revit_Toolkit Wiki before reading this page.</li> <li>Most of the scripts are presented in Grasshopper. All source files are available in samples.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#pushing-elements","title":"Pushing elements","text":"<p>As mentioned in Push to Revit basics section, Revit element types are name matched BHoM object properties. Therefore, the only property that is relevant for <code>Construction</code> of BHoM walls and floors as well as <code>Property</code> of BHoM framing elements is their name - all others will be simply ignored on Push.</p> <p>The scripts below show how to push a primitive building to Revit. To make that happen, family types with names used in the script need to be loaded to the model. <code>PushType</code> is set to <code>CreateOnly</code>, which means that the attempt to update the existing elements will not be made.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#pushing-elements-with-parameters","title":"Pushing elements with parameters","text":"<p>In order to create a Revit element with predefined values of parameters or to update it, the user first needs to set parameter value using <code>SetRevitParameter</code> or <code>SetRevitParameters</code> method. First allows to set only one parameter at a time, while the second can take lists of parameter names and values. The example below shows how to push a grid of columns with predefined parameters, either by setting the parameters one by one or in batch.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#pushing-framing-elements","title":"Pushing framing elements","text":"<p>When pushing framing elements to Revit, they get created exactly in the physical location of the BHoM object regardless the values of parameters, i.e. if the pushed beam is meant to be adjusted to its top face, its final location in space will be exactly same as in BHoM, with vertical adjustment parameter set to Top (its driving curve will move up with regard to the driving curve of the framing in BHoM).</p> <p>To match the driving curves of a BHoM framing with the adjusted Revit element, one first needs to push the element with the parameters unset, and then update only the parameters using <code>RevitPushConfig.SetLocationOnUpdate == false</code>. Both scenarios are shown in the script below.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#modelinstances-and-draftinginstances","title":"ModelInstances and DraftingInstances","text":"<p><code>ModelInstances</code> can be used to push objects of types that are not natively supported by BHoM. A sample below shows how to apply this technique to mechanical ducts.</p> <p></p> <p>Similar approach can be used to drafting instances: the next script generates a line load representation of family Linear Loads and type Load Label 2mm in view named Load Plan Level 0.</p> <p></p> <p>If only the name is specified on definition of a model instance or drafting instance, it will be converted into a primitive (model line, detail line, filled region etc.):</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#update","title":"Update","text":"<p>Note: Update is currently in prototype stage and might not always work as expected.</p> <p>Once the element is pulled from Revit, one can e.g. change one of its parameters (by using <code>SetProperty</code>) and push back to Revit, as shown in the example below. To update the elements instead of creating new, <code>PushType</code> needs to be set either to <code>UpdateOnly</code> or <code>DeleteThenCreate</code>.</p> <p>Worth noting is the fact that error in Grasshopper component is caused by the empty input - once the pull is executed successfully, it will turn standard gray. Similarily, the warning on Push does not always need to mean that the push had not succeeded - it might happen that e.g. the update of location had not worked, but it was not meant to happen actually.</p> <p></p> <p>Not only elements can be manipulated. Update can be successfully applied to families or types as well, for example to batch rename or changing any other settings. It is worth noting that if the name parameter is left blank on family pull, all families in the model are being pulled in one go.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#type-update","title":"Type update","text":"<p>Revit element type can be updated in 2 ways, either by setting Type parameter to the desired type (or its name) or by setting the defining property of a BHoM object to the name of the desired type. All options are shown in the screenshot below.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Examples/#mapping-parameters-on-push","title":"Mapping parameters on Push","text":"<p>As explained in Parameter mapping section, values stored in BHoM object's properties and Revit parameter wrappers attached to it can be mapped into parameters of a Revit element or its type under different names. The script below pushes a wall and copies over the name of the BHoM object to the wall's Mark parameter, plus it copies over a single value attached to the BHoM object to two parameters of the wall and its type.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20Types/","title":"Revit Push modes","text":"<p><code>PushType</code> is being set when specifying the Push action. It drives what is meant to happen depending on whether a Revit element correspondent to the pushed BHoM object already exists in the model. The way in which the Revit elements get linked to BHoM objects is explained in BHoM vs Revit identity section.</p> <p>Currently following <code>PushTypes</code> are provided by the Adapter, with following actions being taken for each:</p> PushType Revit element exists Revit element does not exist <code>CreateOnly</code> do nothing create new element <code>UpdateOnly</code> update existing element do nothing <code>DeleteThenCreate</code> delete existing element and create new one create new element <code>CreateNonExisting</code> not implemented not implemented <code>FullPush</code> not implemented not implemented <p>Default <code>PushType</code> for Revit Adapter is <code>PushType.DeleteThenCreate</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20in%20Excel/","title":"Revit Push in Excel","text":"<p>Under construction.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20in%20Grasshopper/","title":"Revit Push in Grasshopper","text":"<p>Note</p> <p>Before reading this page, it is recommended to have a look at Using the BHoM section.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Push%20in%20Grasshopper/#basics","title":"Basics","text":"<p>Having the adapter successfully set up, one can start interacting with Revit. Similar to <code>Pull</code>, <code>Push</code> behaves like a standard Grasshopper component, so can be placed on canvas with a standard double left click action. The objects to be pushed need to be BHoM objects and should generally be one of the types supported by BHoM conversion to Revit.</p> <p>The example below shows a simple exercise of pushing a few sheets to Revit. Please note that <code>Push</code> will not run as long as it is not activated (<code>active == true</code>).</p> <p></p> <p>More examples is available in Push examples page.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Push/Updating%20Revit%20Types/","title":"Updating Revit types","text":"<p>In many scenarios, one may want to update the type of a Revit element previously pulled to BHoM. There are three ways to achieve that: - setting the name of the defining property of a BHoM object (e.g. <code>Construction</code> of a wall or <code>Property</code> of a beam) to the name of the desired element type using <code>SetProperty</code> method - this is the standard way leveraging the name matching mechanism as explained in Conversion to Revit section - setting the Type parameter to the name of the desired new type using <code>SetRevitParameter</code> - setting the Type parameter to the object representing the desired new type using <code>SetRevitParameter</code> (the name will be extracted from the provided object)</p> <p>Each of the above should yield same result, leading to updating the element type in Revit.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Remove/","title":"Revit Remove","text":"<p>Removing elements from Revit to BHoM works very similar to [pulling], with the difference that the Revit elements get removed instead of extracted and converted to BHoM. In order to perform Remove action, the adapter needs to be set up correctly first. Once this is done, the user needs to specify two basic Remove inputs:</p> <ul> <li>Request (which Revit elements are meant to be removed?) </li> <li>Action config (settings of this particular action - optional, if not specified, default values are used)</li> </ul> <p>Once the adapter and inputs are ready, the Remove action needs to be activated: in visual scripting environments, this is done by setting its <code>active</code> property to <code>true</code>.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Remove/Action%20Config/","title":"Action config","text":"<p>Remove action config is represented by <code>RevitRemoveConfig</code> and allows to specify the following settings:</p> <ul> <li><code>SuppressFailureMessages</code> - if true, Revit warnings are suppressed in order not to interrupt the removal procedure (default is <code>false</code>)</li> <li><code>IncludeClosedWorksets</code> - if true, Revit elements from closed worksets will be removed (default is <code>false</code>)</li> <li><code>RemovePinned</code> - if true, pinned Revit elements will be removed (default is <code>false</code>)</li> </ul> <p>If <code>RevitRemoveConfig</code> is left empty, default values will be used.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Remove/Remove%20Examples/","title":"Revit Remove examples","text":"<p>Note</p> <ul> <li>It is worth having a look at Using the BHoM section and the rest of Revit_Toolkit Wiki before reading this page.</li> <li>All source files are available in samples.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Remove/Remove%20Examples/#removing-pinned-elements-and-closed-worksets","title":"Removing pinned elements and closed worksets","text":"<p>By default, <code>Remove</code> will not delete pinned elements as well as the ones on closed worksets. To enable processing the mentioned groups, the user needs to set the action config (typically created with Ctrl+Shift+B menu in Grasshopper and/or the <code>CreateObject</code> component). The script below shows how to delete all generic annotations from the model, incl. pinned ones and ones on closed worksets. </p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Remove/Remove%20in%20Excel/","title":"Revit Remove in Excel","text":"<p>Under construction.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Remove/Remove%20in%20Grasshopper/","title":"Revit Remove in Grasshopper","text":"<p>Note: Before reading this page, it is recommended to have a look at Using the BHoM section.</p> <p>Having the adapter successfully set up, one can start interacting with Revit. In general, <code>Remove</code> action is very similar to <code>Pull</code> (although instead of pulling it deletes elements). <code>Remove</code> component behaves like a standard Grasshopper component, so can be placed on canvas with a standard double left click action. Request, on the other hand, is a solely BHoM type, therefore it is easiest to invoke it with Ctrl+Shift+B menu, with an alternative of using <code>CreateObject</code> component (<code>CreateRequest</code> is currently on prototype stage and does not capture all Requests).</p> <p>The example below shows a simple exercise of deleting all Revit sheets using category filter. There is a few details that might be worth noticing: - <code>FilterByCategory</code> allows to switch off case sensitivity. This is a general use for most name matching components in Revit_Toolkit. - Remove will not run as long as it is not activated (<code>active == true</code>).</p> <p></p> <p>More examples is available in Remove examples page.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/","title":"Introduction to the Revit Adapter","text":"<p>The Revit Adapter is the heart of the data exchange process between BHoM and Revit. No interaction can happen without it, therefore activating it should be the first step to take when working with Revit_Toolkit. In order to activate, you need to:</p> <ul> <li>Set up the Revit_Adapter in Revit</li> <li>Set up the Revit_Adapter in one or more of the UIs:<ul> <li>Set up in Grasshopper</li> <li>Set up in Excel</li> </ul> </li> </ul> <p>Both ends of the Adapter communicate with each other based on Sockets - it is important to set same socket ports on both ends (otherwise they will not see each other). There should be only one Revit instance open per each port couple, therefore, if one wants to work with more than one instance of Revit at the same time, it is recommended to change ports. In case of only one Revit instance running, default ports (14128, 14129) are suggested.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/#adapter-actions","title":"Adapter actions","text":"<p>Once the Adapter is successfully set up, adapter actions can be performed:</p> <ul> <li>Pull elements from Revit</li> <li>Push BHoM objects to Revit</li> <li>Remove elements from Revit</li> </ul> <p>Push and Pull include conversion from Revit and to Revit, which is being triggered on the fly.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/#settings","title":"Settings","text":"<p>There is a range of settings that can be specified in <code>RevitSettings</code> for each adapter instance. These are:</p> <ul> <li><code>ConnectionSettings</code> - socket connection settings for Revit Adapter</li> <li><code>FamilyLoadSettings</code> - Revit family load settings for Revit Adapter</li> <li><code>MappingSettings</code> - relationships between property names of BHoM types and parameter names of correspondent Revit elements as well as relationships between Revit family names and BHoM types to explicitly convert them to on Pull</li> <li><code>DistanceTolerance</code> - used in geometry processing</li> <li><code>AngleTolerance</code> - used in geometry processing</li> </ul> <p>If <code>RevitSettings</code> are not set, default settings will be used (which should be perfectly fine in most cases).</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/Adapter%20Setup%20in%20Excel/","title":"Revit Adapter setup in Excel","text":"<p>Under construction.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/Adapter%20Setup%20in%20Grasshopper/","title":"Revit Adapter setup in Grasshopper","text":"<p>Note: Before reading this page, it is recommended to have a look at Using the BHoM section.</p> <p>In Grasshopper, Revit Adapter with different values can be set up in literally few clicks. The adapter component can either be created based on CreateAdapter component or with Ctrl+Shift+B menu. Once the Adapter component is placed on canvas, its <code>active</code> input needs to be set to <code>true</code> - that is the moment when the connection between Revit and the Adapter is being established. <code>IsValid</code> query allows to check if the adapter has been set up correctly on the BHoM side. </p> <p>In case of any issues, as a first line of bugfixing, it is recommended to deactivate and activate the adapter again (switch <code>active == false</code> and again, <code>active == true</code>).</p> <p></p> <p>Once the adapter can be successfully activated, settings can be further specified - the animation below shows how maximum timeout has been quickly changed to 60 minutes (default is 10, which may be not enough for massive adapter actions) using Ctrl+Shift+B. It is worth noting that required input type can be looked up by hovering the mouse over a certain input.</p> <p></p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/Adapter%20Setup%20in%20Revit/","title":"Revit Adapter setup in Revit","text":"<p>BHoM is communicating with Revit via a dedicated plugin. Once BHoM is installed (or Revit_Toolkit compiled, if built from source), it should automatically load on startup of Revit 2018, 2019, 2020 and 2021. </p> <p>Activation of the plugin may be required upon starting Revit for the first time after BHoM installation. Simply click Always Load not to see the popup again:</p> <p></p> <p>After that, if the adapter has been successfully loaded, it should be visible in the BHoM ribbon tab in Revit Adapter panel.</p> <p></p> <p>In order to activate the adapter, the user needs to click Activate - Revit then starts to listen for BHoM instructions on default ports (14128 and 14129). As explained in the introduction, only one Revit instance is allowed per each port couple - the latter can be changed by clicking Update Ports button.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/BHoM%20vs%20Revit%20Identity/","title":"Matching Revit elements with BHoM objects","text":"<p>Exchange of information between Revit and BHoM often requires linking the objects from both sides with each other, e.g. when querying the model for changes or updating it. The mutual relationship is being created and maintained as follows:</p> <ul> <li>On Pull, the identifiers of pulled Revit element are stored in <code>RevitIdentifiers</code> fragment attached to the resultant BHoM object.</li> <li>On Push, Revit element is being considered correspondent to a BHoM object when the latter contains a <code>RevitIdentifiers</code> fragment with value of <code>ElementId</code> property equal to the ElementId of the former.</li> </ul>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/BHoM%20vs%20Revit%20Identity/#revitidentifiers","title":"RevitIdentifiers","text":"<p>As mentioned in the previous section, the information about identity of a Revit element correspondent to a BHoM object is stored in <code>RevitIdentifiers</code> fragment of the latter. That fragment contains a few important pieces of information:</p> <ul> <li><code>PersistentId</code> - global, software-agnostic identifier used by BHoM, in Revit correspondent to element's UniqueId</li> <li><code>ElementId</code> - ElementId of the Revit element correspondent to the BHoM object</li> <li><code>CategoryName</code> - Category of the Revit element correspondent to the BHoM object</li> <li><code>FamilyName</code> - Family of the Revit element correspondent to the BHoM object</li> <li><code>FamilyTypeName</code> - Family type of the Revit element correspondent to the BHoM object</li> <li><code>FamilyTypeId</code> - ElementId of family type of the Revit element correspondent to the BHoM object</li> <li><code>Workset</code> - Workset of the Revit element correspondent to the BHoM object</li> <li><code>HostId</code> - ElementId of the Revit element hosting the Revit element correspondent to the BHoM object</li> <li><code>OwnerViewId</code> - ElementId of view that owns the Revit element correspondent to the BHoM object</li> <li><code>ParentElementId</code> - ElementId of the parent element of the Revit element correspondent to the BHoM object</li> <li><code>LinkPath</code> - path to the link document that owns the Revit element correspondent to the BHoM object</li> </ul> <p>The identifiers of a BHoM object can be retrieved with <code>GetRevitIdentifiers</code> method.</p>"},{"location":"Guides-and-Tutorials/Visual-Programming-with-BHoM/Revit%20Toolkit/Revit%20Adapter/Warnings%20and%20Errors/","title":"Warnings and Errors","text":"<p>It is likely that the adapter will generate warnings on converts. This is related to the fact that each Revit object consists of a multitude of information that often cannot be translated to BHoM one to one. It is important to read warning messages as they usually explain what issue has been found.</p> <p>Error messages, on the other hand, usually mean that a serious issue occurred on convert: either the object has not been converted due to an error in the method, or the conversion method simply does not exist. Same as with warnings, error messages should provide detailed information about the problem.</p>"},{"location":"oM/","title":"documentation","text":""},{"location":"oM/#documentation","title":"Documentation","text":"<p>For object model documentation please see BHoM oM documentation</p>"}]}